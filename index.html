<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Gioco del Fato</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html { scroll-behavior: smooth; -webkit-text-size-adjust: 100%; }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #08080f;
            background-image: 
                radial-gradient(circle at 15% 50%, rgba(99, 102, 241, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 85% 20%, rgba(236, 72, 153, 0.12) 0%, transparent 50%),
                radial-gradient(circle at 50% 80%, rgba(34, 211, 238, 0.08) 0%, transparent 50%);
            background-attachment: fixed;
            color: #e2e8f0;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            padding: max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right)) max(10px, env(safe-area-inset-bottom)) max(10px, env(safe-area-inset-left));
            overflow-x: hidden;
            transition: box-shadow 0.3s ease;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        body::before { display: none; }
        
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        body.my-turn { box-shadow: inset 0 0 0 4px #22d3ee; }
        
        @keyframes damageFlash { 0% { background-color: rgba(255,0,0,0); } 50% { background-color: rgba(255,0,0,0.25); } 100% { background-color: rgba(255,0,0,0); } }
        @keyframes healFlash { 0% { background-color: rgba(34,211,238,0); } 50% { background-color: rgba(34,211,238,0.2); } 100% { background-color: rgba(34,211,238,0); } }
        @keyframes reviveFlash { 0% { background-color: rgba(250,204,21,0); } 25% { background-color: rgba(250,204,21,0.25); } 50% { background-color: rgba(34,211,238,0.25); } 75% { background-color: rgba(250,204,21,0.25); } 100% { background-color: rgba(250,204,21,0); } }
        
        .screen-flash { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 999; }
        .screen-flash.damage { animation: damageFlash 0.4s ease-out; }
        .screen-flash.heal { animation: healFlash 0.5s ease-out; }
        .screen-flash.revive { animation: reviveFlash 1s ease-out; }
        
        .particle { position: fixed; pointer-events: none; z-index: 1000; font-size: 2em; animation: particleFloat 1.5s ease-out forwards; }
        @keyframes particleFloat { 0% { opacity: 1; transform: translate(0,0) scale(1) rotate(0deg); } 100% { opacity: 0; transform: translate(var(--tx), var(--ty)) scale(0.3) rotate(360deg); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); } 20%, 40%, 60%, 80% { transform: translateX(8px); } }
        body.shake { animation: shake 0.5s ease; }

        .container { max-width: 600px; margin: 0 auto; padding: 12px; position: relative; z-index: 1; }

        h1 {
            text-align: center;
            background: linear-gradient(135deg, #818cf8 0%, #22d3ee 50%, #f472b6 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
            margin-bottom: 16px; font-size: 1.8em; font-weight: 900; letter-spacing: 2px;
            filter: drop-shadow(0 0 12px rgba(99,102,241,0.5));
            text-transform: uppercase;
        }
        h1::before { content: 'üé≤ '; } h1::after { content: ' üé≤'; }

        .setup-screen, .game-screen {
            background: rgba(15, 15, 30, 0.95);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 20px;
            padding: 22px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05);
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
        }

        .input-group { margin-bottom: 14px; }

        label {
            display: block; margin-bottom: 6px;
            color: #94a3b8; font-weight: 600; font-size: 0.88em;
            letter-spacing: 0.5px; text-transform: uppercase;
        }

        input, select {
            width: 100%; padding: 14px; min-height: 48px;
            border: 1px solid rgba(99,102,241,0.3); border-radius: 12px;
            background: rgba(15,15,35,0.8); color: #e2e8f0; font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.3);
            font-weight: 500;
        }
        input:focus, select:focus {
            outline: none; border-color: #818cf8;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.3), 0 0 0 3px rgba(99,102,241,0.15);
        }
        input::placeholder { color: rgba(148,163,184,0.5); }

        button {
            width: 100%; padding: 14px; min-height: 48px;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: #fff; border: none; border-radius: 12px;
            font-size: 15px; font-weight: 700; cursor: pointer;
            margin-top: 10px; transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(99,102,241,0.3);
            letter-spacing: 0.5px;
        }
        button:active { transform: scale(0.97); opacity: 0.9; }
        button:disabled { background: linear-gradient(135deg, #374151 0%, #4b5563 100%); cursor: not-allowed; opacity: 0.5; box-shadow: none; }

        .player-input { display: flex; gap: 8px; margin-bottom: 8px; }
        .player-input input { flex: 1; }
        .player-input button { width: auto; padding: 10px 18px; margin: 0; background: #ef4444; }

        #qrcode-container { text-align: center; margin: 18px 0; padding: 18px; background: #fff; border-radius: 16px; }
        #qrcode { display: inline-block; max-width: 100%; height: auto; }
        #qrcode canvas, #qrcode img { max-width: 100% !important; height: auto !important; width: auto !important; }

        .share-link {
            margin-top: 16px; padding: 14px;
            background: rgba(15,15,30,0.8); border: 1px solid rgba(250,204,21,0.3);
            border-radius: 12px; word-break: break-all; font-size: 14px;
        }
        .share-link strong { color: #facc15; }

        /* ===== PLAYER CARDS ===== */
        .players-list { margin: 16px 0; }
        
        .player-card {
            background: linear-gradient(135deg, rgba(30,30,60,0.9) 0%, rgba(15,15,40,0.85) 100%);
            border-radius: 16px; padding: 16px; margin-bottom: 10px;
            border: 1px solid rgba(99,102,241,0.2);
            border-left: 4px solid rgba(99,102,241,0.4);
            transition: all 0.3s ease;
            box-shadow: 0 2px 12px rgba(0,0,0,0.3);
        }
        .player-card:active { transform: scale(0.98); }
        
        .player-card.active-turn {
            border-left-color: #22d3ee; border-left-width: 5px;
            background: linear-gradient(135deg, rgba(8,145,178,0.15) 0%, rgba(6,95,115,0.1) 100%);
            box-shadow: 0 2px 20px rgba(34,211,238,0.2), inset 0 0 20px rgba(34,211,238,0.05);
            animation: turnPulse 2s infinite;
        }
        @keyframes turnPulse { 0%, 100% { box-shadow: 0 2px 20px rgba(34,211,238,0.2); } 50% { box-shadow: 0 2px 30px rgba(34,211,238,0.35); } }
        
        .player-card.eliminated { opacity: 0.4; border-left-color: #ef4444; filter: grayscale(0.5); }

        .player-info { display: flex; justify-content: space-between; align-items: flex-start; }
        .player-name-section { flex: 1; min-width: 0; }
        .player-name { font-weight: 800; font-size: 1.15em; color: #e2e8f0; margin-bottom: 6px; word-wrap: break-word; }
        
        .player-badges { display: flex; flex-wrap: wrap; gap: 4px; }
        .effect-badge {
            display: inline-flex; align-items: center; padding: 2px 7px;
            border-radius: 6px; font-size: 0.7em; font-weight: 700;
            background: rgba(99,102,241,0.15); color: #a5b4fc; border: 1px solid rgba(99,102,241,0.3);
            white-space: nowrap;
        }
        .effect-badge.master { background: rgba(250,204,21,0.15); color: #facc15; border-color: rgba(250,204,21,0.3); }
        .effect-badge.immortal { background: rgba(250,204,21,0.15); color: #fbbf24; border-color: rgba(250,204,21,0.3); }
        .effect-badge.damage-mult { background: rgba(239,68,68,0.15); color: #fca5a5; border-color: rgba(239,68,68,0.3); }
        .effect-badge.shield-mult { background: rgba(34,197,94,0.15); color: #86efac; border-color: rgba(34,197,94,0.3); }
        .effect-badge.skip { background: rgba(249,115,22,0.15); color: #fdba74; border-color: rgba(249,115,22,0.3); }
        .effect-badge.kraken { background: rgba(139,92,246,0.15); color: #c4b5fd; border-color: rgba(139,92,246,0.3); }
        .effect-badge.checkmate { background: rgba(239,68,68,0.2); color: #fca5a5; border-color: rgba(239,68,68,0.4); }
        .effect-badge.convert { background: rgba(236,72,153,0.15); color: #f9a8d4; border-color: rgba(236,72,153,0.3); }
        .effect-badge.sun { background: rgba(245,158,11,0.15); color: #fcd34d; border-color: rgba(245,158,11,0.3); }
        .effect-badge.moon { background: rgba(59,130,246,0.15); color: #93c5fd; border-color: rgba(59,130,246,0.3); }
        .effect-badge.reflect { background: rgba(34,211,238,0.15); color: #67e8f9; border-color: rgba(34,211,238,0.3); }
        .effect-badge.extra-turn { background: rgba(16,185,129,0.15); color: #6ee7b7; border-color: rgba(16,185,129,0.3); }
        
        .player-hp-section { text-align: right; flex-shrink: 0; margin-left: 12px; }
        .player-hp { font-size: 1.8em; font-weight: 900; color: #22d3ee; line-height: 1; }
        .player-hp.low { color: #f43f5e; animation: warning-pulse 1s infinite; }
        .hp-label { font-size: 0.7em; color: #64748b; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }
        @keyframes warning-pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
        
        .hp-bar-container { height: 4px; background: rgba(255,255,255,0.06); border-radius: 2px; margin-top: 10px; overflow: hidden; }
        .hp-bar { height: 100%; border-radius: 2px; transition: width 0.6s ease, background 0.6s ease; }
        .eliminated-tag { color: #ef4444; margin-top: 8px; font-weight: 700; font-size: 0.85em; text-align: center; padding: 4px; background: rgba(239,68,68,0.1); border-radius: 6px; }

        /* ===== ACTIVE EFFECTS PANEL ===== */
        .active-effects-panel {
            background: linear-gradient(135deg, rgba(30,30,55,0.8) 0%, rgba(20,20,40,0.7) 100%);
            border: 1px solid rgba(139,92,246,0.3); border-radius: 14px;
            padding: 14px; margin: 14px 0;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }
        .active-effects-panel h3 { color: #a78bfa; font-size: 0.95em; font-weight: 700; margin-bottom: 10px; text-align: center; }
        .effects-section { margin-bottom: 10px; }
        .effects-section-title { font-size: 0.78em; color: #64748b; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; }
        .active-effect {
            display: flex; align-items: center; gap: 8px; padding: 6px 10px;
            background: rgba(99,102,241,0.08); border-radius: 8px; margin-bottom: 4px; font-size: 0.85em;
        }
        .active-effect.global-effect { border-left: 3px solid #818cf8; }
        .effect-icon { font-size: 1.1em; }
        .effect-name { font-weight: 600; color: #e2e8f0; }
        .effect-by { color: #64748b; font-size: 0.85em; margin-left: auto; }
        .effect-remove { width: 24px !important; height: 24px; min-height: 24px !important; padding: 0 !important; margin: 0 !important; background: rgba(239,68,68,0.2) !important; color: #fca5a5; border-radius: 6px !important; font-size: 12px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .player-effects-row { display: flex; align-items: center; gap: 8px; padding: 5px 8px; margin-bottom: 3px; }
        .pe-name { font-weight: 600; font-size: 0.85em; color: #cbd5e1; min-width: 70px; }
        .pe-badges { display: flex; flex-wrap: wrap; gap: 3px; }
        .pe-badge { font-size: 0.72em; padding: 2px 6px; background: rgba(99,102,241,0.1); border: 1px solid rgba(99,102,241,0.2); border-radius: 4px; color: #a5b4fc; }
        .no-effects { text-align: center; color: #475569; font-size: 0.85em; padding: 8px; }

        /* ===== DICE CALCULATOR ===== */
        .dice-calculator {
            background: linear-gradient(135deg, rgba(30,30,55,0.8) 0%, rgba(20,20,40,0.7) 100%);
            border: 1px solid rgba(250,204,21,0.25); border-radius: 16px;
            padding: 20px; margin: 16px 0;
        }
        .dice-inputs { display: flex; gap: 10px; margin: 12px 0; flex-wrap: wrap; justify-content: center; }
        .dice-input { flex: 1; min-width: 65px; max-width: 90px; }
        .dice-input input {
            text-align: center; font-size: 1.8em; font-weight: 900;
            background: rgba(15,15,40,0.9); border: 2px solid rgba(99,102,241,0.4);
            border-radius: 14px; color: #818cf8;
            text-shadow: 0 0 10px rgba(99,102,241,0.4);
            transition: all 0.3s ease; padding: 12px 4px;
        }
        .dice-input input:focus {
            border-color: #a78bfa; color: #c4b5fd;
            box-shadow: 0 0 20px rgba(139,92,246,0.3);
            transform: scale(1.08);
        }

        .result-display {
            background: rgba(99,102,241,0.08); border: 2px solid rgba(99,102,241,0.4);
            border-radius: 14px; padding: 18px; margin: 14px 0; text-align: center;
            box-shadow: 0 0 20px rgba(99,102,241,0.15);
        }
        .result-display h3 { color: #818cf8; margin-bottom: 10px; font-size: 1.2em; }

        /* ===== LEADERBOARD ===== */
        .leaderboard {
            background: linear-gradient(135deg, rgba(30,30,55,0.8) 0%, rgba(20,20,40,0.7) 100%);
            border: 1px solid rgba(250,204,21,0.25); border-radius: 14px;
            padding: 16px; margin: 14px 0;
        }
        .leaderboard h3 { color: #facc15; text-align: center; font-size: 1em; font-weight: 700; margin-bottom: 12px; }
        .leaderboard-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 10px; margin-bottom: 4px;
            background: rgba(30,30,50,0.5); border-radius: 8px;
            transition: all 0.2s ease;
        }
        .leaderboard-item.winner {
            background: linear-gradient(135deg, rgba(250,204,21,0.12) 0%, rgba(245,158,11,0.08) 100%);
            border: 1px solid rgba(250,204,21,0.3);
        }
        .leaderboard-item.lb-eliminated { opacity: 0.4; }
        .lb-left { display: flex; align-items: center; gap: 8px; }
        .lb-medal { font-size: 1.1em; min-width: 24px; text-align: center; }
        .lb-rank { display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: rgba(99,102,241,0.15); border-radius: 6px; font-size: 0.8em; font-weight: 700; color: #94a3b8; }
        .lb-name { font-weight: 600; font-size: 0.9em; }
        .lb-right { display: flex; align-items: center; gap: 8px; }
        .lb-hp-bar { width: 50px; height: 4px; background: rgba(255,255,255,0.06); border-radius: 2px; overflow: hidden; }
        .lb-hp-fill { height: 100%; background: #22d3ee; border-radius: 2px; transition: width 0.5s ease; }
        .lb-hp-val { font-weight: 700; font-size: 0.85em; color: #22d3ee; min-width: 36px; text-align: right; }

        /* ===== HISTORY ===== */
        .history {
            max-height: 220px; overflow-y: auto;
            background: rgba(10,10,20,0.7); border: 1px solid rgba(250,204,21,0.15);
            border-radius: 12px; padding: 12px 12px 12px 22px; margin: 14px 0;
            position: relative;
        }
        .history::before { content: ''; position: absolute; left: 8px; top: 12px; bottom: 12px; width: 2px; background: linear-gradient(180deg, rgba(250,204,21,0.2) 0%, rgba(250,204,21,0.05) 100%); }
        .history-item {
            padding: 8px 10px 8px 16px; margin-bottom: 6px;
            background: rgba(30,30,50,0.4); border-left: 2px solid rgba(250,204,21,0.3);
            border-radius: 6px; font-size: 0.82em; display: flex; align-items: center; gap: 8px;
            position: relative; transition: all 0.2s ease;
        }
        .history-item::before { content: ''; position: absolute; left: -16px; top: 50%; transform: translateY(-50%); width: 6px; height: 6px; background: #facc15; border-radius: 50%; border: 2px solid rgba(10,10,20,0.7); }
        .history-item .icon { font-size: 1em; min-width: 20px; text-align: center; }
        .history-item.damage { border-left-color: #f87171; }
        .history-item.damage::before { background: #f87171; }
        .history-item.heal { border-left-color: #22d3ee; }
        .history-item.heal::before { background: #22d3ee; }
        .history-item.special { border-left-color: #facc15; background: rgba(250,204,21,0.06); }
        .history-item.history-latest { border-left-color: #a78bfa; background: rgba(167,139,250,0.10); font-weight: 600; }

        /* ===== TIMER & DIRECTION ===== */
        .timer {
            text-align: center; font-size: 1.15em; font-weight: 700;
            background: rgba(99,102,241,0.08); border: 1px solid rgba(99,102,241,0.25);
            border-radius: 12px; padding: 10px 16px; margin: 12px 0;
            color: #818cf8; letter-spacing: 1px; min-height: 44px;
            display: flex; align-items: center; justify-content: center;
        }
        .direction-indicator {
            text-align: center; padding: 10px;
            background: rgba(250,204,21,0.06); border: 1px solid rgba(250,204,21,0.2);
            border-radius: 10px; margin: 8px 0; font-weight: 600; font-size: 0.95em;
        }

        /* ===== QUICK COMMANDS ===== */
        .quick-commands {
            background: linear-gradient(135deg, rgba(250,204,21,0.06) 0%, rgba(245,158,11,0.03) 100%);
            border: 1px solid rgba(250,204,21,0.3); border-radius: 16px;
            padding: 16px; margin: 16px 0;
        }
        .quick-commands h3 {
            color: #facc15; text-align: center; font-size: 1em; font-weight: 700;
            margin-bottom: 14px; display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        .qc-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px; }
        .qc-grid button { font-size: 13px; padding: 10px 8px; margin: 0; letter-spacing: 0; }
        .qc-section { margin-bottom: 12px; padding: 12px; background: rgba(0,0,0,0.15); border-radius: 10px; }
        .qc-section-title { font-size: 0.8em; color: #94a3b8; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; }

        /* ===== MASTER CONTROLS ===== */
        .master-controls {
            background: linear-gradient(135deg, rgba(250,204,21,0.04) 0%, rgba(245,158,11,0.02) 100%);
            border: 1px solid rgba(250,204,21,0.2); border-radius: 16px;
            padding: 16px; margin: 16px 0;
        }
        .master-controls h3 { color: #facc15; margin-bottom: 14px; text-align: center; font-size: 1.05em; }
        
        .control-category {
            background: rgba(20,20,40,0.5); border: 1px solid rgba(99,102,241,0.2);
            border-radius: 12px; margin: 10px 0; overflow: hidden;
        }
        .control-category summary {
            padding: 12px 16px; font-size: 0.95em; font-weight: 700;
            cursor: pointer; background: rgba(99,102,241,0.06);
            border-bottom: 1px solid rgba(99,102,241,0.1);
            user-select: none; display: flex; align-items: center; gap: 8px;
            transition: all 0.2s ease; color: #a5b4fc; list-style: none;
        }
        .control-category summary::-webkit-details-marker { display: none; }
        .control-category summary::before { content: '‚ñ∏'; display: inline-block; width: 16px; transition: transform 0.3s ease; }
        .control-category[open] summary::before { transform: rotate(90deg); }
        .control-category summary:active { background: rgba(99,102,241,0.12); }
        .category-content { padding: 16px; }

        .control-group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px; }
        .control-group button { padding: 10px; font-size: 13px; }

        .hp-modifier { display: flex; flex-direction: column; gap: 8px; margin: 8px 0; }
        .hp-modifier input { font-size: 20px !important; padding: 16px !important; min-height: 56px !important; border: 2px solid rgba(99,102,241,0.4) !important; text-align: center; font-weight: bold; }
        .hp-modifier input:focus { border-color: #818cf8 !important; box-shadow: 0 0 16px rgba(99,102,241,0.3); }
        .hp-modifier button { min-height: 50px; font-size: 15px; }

        .hidden { display: none; }

        /* ===== FATO EFFECT PANELS ===== */
        .fato-panel {
            display: none;
            padding: 12px;
            background: rgba(99,102,241,0.05);
            border: 1px solid rgba(99,102,241,0.2);
            border-radius: 10px;
            margin-top: 8px;
        }
        .fato-panel label {
            color: #a78bfa;
            font-size: 0.95em;
            font-weight: 700;
            margin-bottom: 10px;
            display: block;
            text-transform: none;
            letter-spacing: 0;
        }

        /* ===== QR MODAL ===== */
        .qr-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; z-index: 3000; padding: 20px; }
        .qr-modal.show { display: flex; }
        .qr-modal-content { background: #fff; border-radius: 20px; padding: 28px; max-width: 90%; max-height: 90%; overflow-y: auto; text-align: center; position: relative; }
        .qr-modal-content h2 { color: #1e1b4b; margin-bottom: 16px; font-size: 1.3em; }
        .qr-modal-close { position: absolute; top: 12px; right: 12px; width: 36px; height: 36px; min-height: 36px !important; background: #ef4444 !important; color: white; border: none; border-radius: 50%; font-size: 20px; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0 !important; margin: 0 !important; }
        .qr-modal #qrcode-modal { display: inline-block; margin: 16px 0; }
        .qr-modal .share-info { margin-top: 16px; padding: 14px; background: rgba(99,102,241,0.08); border: 1px solid rgba(99,102,241,0.2); border-radius: 10px; color: #1e1b4b; }
        .qr-modal .game-code { font-size: 1.4em; color: #6366f1; font-weight: 900; margin: 8px 0; letter-spacing: 2px; }

        /* ===== FLOATING NUMBERS ===== */
        .floating-number { position: fixed; font-size: 2em; font-weight: bold; pointer-events: none; animation: float-up 1s ease-out forwards; z-index: 1000; }
        .floating-number.damage { color: #f87171; }
        .floating-number.heal { color: #22d3ee; }
        @keyframes float-up { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-100px); } }
        @keyframes damage { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-10px); } 75% { transform: translateX(10px); } }
        @keyframes heal { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        .animate-damage { animation: damage 0.5s ease; }
        .animate-heal { animation: heal 0.5s ease; }

        /* ===== NOTIFICATIONS ===== */
        .eliminated-notification {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, rgba(0,0,0,0.98) 0%, rgba(50,0,0,0.98) 100%);
            border: 3px solid #ef4444; border-radius: 20px; padding: 36px 28px; text-align: center;
            z-index: 2001; box-shadow: 0 0 50px rgba(239,68,68,0.6); min-width: 280px; max-width: 90%;
        }
        .eliminated-notification.show { animation: eliminatedAppear 0.6s cubic-bezier(0.68,-0.55,0.265,1.55) forwards; }
        .eliminated-notification h2 { font-size: 2.2em; color: #ef4444; text-shadow: 0 0 20px rgba(239,68,68,0.8); margin-bottom: 16px; }

        .winner-notification {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, rgba(250,204,21,0.98) 0%, rgba(245,158,11,0.98) 100%);
            border: 4px solid #facc15; border-radius: 24px; padding: 44px 36px; text-align: center;
            z-index: 2001; box-shadow: 0 0 60px rgba(250,204,21,0.8); min-width: 300px; max-width: 90%;
        }
        .winner-notification.show { animation: winnerAppear 0.8s cubic-bezier(0.68,-0.55,0.265,1.55) forwards; }
        .winner-notification h2 { font-size: 2.5em; color: #1e1b4b; margin-bottom: 16px; }
        .winner-notification .winner-name { font-size: 2em; color: #1e1b4b; margin: 16px 0; font-weight: 900; }
        
        .game-stats { background: rgba(15,15,30,0.9); border-radius: 14px; padding: 16px; margin-top: 20px; text-align: left; max-height: 280px; overflow-y: auto; }
        .game-stats h3 { color: #facc15; text-align: center; margin-bottom: 12px; }
        .stat-item { display: flex; justify-content: space-between; padding: 8px; margin: 6px 0; background: rgba(255,255,255,0.03); border-radius: 6px; border-left: 3px solid #818cf8; }
        .stat-item .label { color: #e2e8f0; font-weight: 600; }
        .stat-item .value { color: #22d3ee; font-weight: 700; }

        .hit-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 1999; opacity: 0; transition: opacity 0.3s ease; }
        .hit-overlay.show { opacity: 1; }
        
        @keyframes eliminatedAppear { 0% { transform: translate(-50%,-50%) scale(0) rotate(-180deg); opacity: 0; } 100% { transform: translate(-50%,-50%) scale(1) rotate(0); opacity: 1; } }
        @keyframes winnerAppear { 0% { transform: translate(-50%,-50%) scale(0) rotate(180deg); opacity: 0; } 50% { transform: translate(-50%,-50%) scale(1.15) rotate(-5deg); } 100% { transform: translate(-50%,-50%) scale(1) rotate(0); opacity: 1; } }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 480px) {
            body { padding: max(6px, env(safe-area-inset-top)) max(6px, env(safe-area-inset-right)) max(6px, env(safe-area-inset-bottom)) max(6px, env(safe-area-inset-left)); }
            .player-card, .setup-screen, .game-screen, button, input, select { -webkit-transform: translate3d(0,0,0); transform: translate3d(0,0,0); }
            .container { padding: 6px; -webkit-overflow-scrolling: touch; }
            h1 { font-size: 1.4em; margin-bottom: 12px; }
            .setup-screen, .game-screen { padding: 14px 12px; border-radius: 16px; }
            label { font-size: 0.82em; }
            input, select { padding: 12px 10px; }
            button { padding: 12px 10px; font-size: 14px; }
            .player-card { padding: 12px 10px; }
            .player-name { font-size: 1.05em !important; }
            .player-hp { font-size: 1.5em !important; }
            .dice-input { min-width: 60px; max-width: 75px; }
            .dice-input input { font-size: 1.5em; padding: 10px 4px; }
            .qc-grid { grid-template-columns: 1fr 1fr; gap: 6px; }
            .qc-grid button { font-size: 11px; padding: 8px 4px; }
            .control-group { grid-template-columns: 1fr; }
            .history { max-height: 180px; }
            button, input, select, .dice-input input { touch-action: manipulation; }
        }
        @media (max-width: 360px) {
            h1 { font-size: 1.3em; }
            .dice-input { min-width: 55px; }
            .dice-input input { font-size: 1.3em; }
            button { font-size: 13px; padding: 10px 8px; }
            .qc-grid button { font-size: 10px; }
        }
        @media (max-height: 500px) and (orientation: landscape) {
            .container { padding: 4px; }
            h1 { font-size: 1.2em; margin-bottom: 6px; }
            .setup-screen, .game-screen { padding: 10px; }
            .player-card { padding: 8px; margin-bottom: 6px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Gioco del Fato</h1>

        <!-- Setup Screen -->
        <div id="setup-screen" class="setup-screen">
            <div id="master-setup" class="hidden">
                <div class="input-group">
                    <label>Il tuo nome (Master)</label>
                    <input type="text" id="master-name" placeholder="Inserisci il tuo nome">
                </div>
                <div class="input-group">
                    <label>Numero di giocatori (incluso te)</label>
                    <input type="number" id="num-players" min="2" max="15" value="4">
                </div>
                <div class="input-group">
                    <label>HP iniziali</label>
                    <input type="number" id="initial-hp" value="70">
                </div>
                <div id="player-names-container"></div>
                <button id="create-game-btn">Crea Partita</button>
            </div>
            <div id="player-join" class="hidden">
                <div class="input-group">
                    <label>Seleziona il tuo nome</label>
                    <select id="player-name-select"><option value="">Caricamento...</option></select>
                </div>
                <button id="join-game-btn">Unisciti alla Partita</button>
                <div style="margin-top:16px;text-align:center;color:#64748b;font-size:0.9em;">Codice Partita: <strong id="display-game-code" style="color:#facc15;"></strong></div>
            </div>
            <div id="qr-display" class="hidden">
                <h3 style="color:#facc15;text-align:center;">Partita Creata!</h3>
                <div id="qrcode-container"><div id="qrcode"></div></div>
                <div class="share-link"><strong>Codice Partita:</strong><br><span id="game-code-display"></span></div>
                <div style="margin-top:12px;padding:12px;background:rgba(34,211,238,0.06);border:1px solid rgba(34,211,238,0.2);border-radius:10px;">
                    <div style="color:#22d3ee;font-weight:bold;margin-bottom:6px;">üë• Giocatori Connessi:</div>
                    <div id="connected-players-list"></div>
                </div>
                <button id="start-game-btn">Inizia Partita</button>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="game-screen hidden">
            <div class="timer" id="timer">Tempo: 00:00</div>
            <div class="direction-indicator" id="direction">Direzione: ‚≠Æ Oraria</div>
            <div id="current-turn" style="text-align:center;font-size:1.15em;color:#facc15;margin:12px 0;font-weight:700;">Turno di: <strong id="turn-player"></strong></div>

            <!-- Dice Calculator -->
            <div class="dice-calculator" id="dice-calculator">
                <h3 style="color:#facc15;text-align:center;font-size:1em;margin-bottom:10px;">üé≤ Calcolatore Dadi</h3>
                <div class="dice-inputs" id="dice-inputs"></div>
                <button id="calculate-btn">Calcola e Applica</button>
                <div class="result-display hidden" id="result-display">
                    <h3>Risultato</h3>
                    <div id="result-text"></div>
                </div>
            </div>

            <!-- History -->
            <div class="history" id="history"></div>

            <!-- Active Effects Panel -->
            <div class="active-effects-panel">
                <h3>‚ö° Effetti Attivi</h3>
                <div id="active-effects-list"></div>
            </div>

            <!-- Players List -->
            <div class="players-list" id="players-list"></div>

            <!-- Leaderboard -->
            <div class="leaderboard">
                <h3>üìä Classifica</h3>
                <div id="leaderboard-list"></div>
            </div>

            <!-- Quick Commands placeholder (kept for JS compatibility) -->
            <div id="quick-commands" style="display:none!important;"></div>

            <!-- Master Controls (unified) -->
            <div id="master-controls" class="master-controls hidden">
                <h3>üëë Pannello Master</h3>

                <!-- ===== 1. COMANDI RAPIDI ‚Äì SEMPRE VISIBILE ===== -->
                <div class="quick-commands">
                    <h3>‚ö° Danni &amp; Cure Manuali</h3>
                    <div class="qc-section">
                        <div class="qc-section-title">Attivatore</div>
                        <select id="damage-activator-select"></select>
                    </div>
                    <div class="qc-section">
                        <div class="qc-section-title">Bersagli (multi-selezione)</div>
                        <select id="target-players" multiple size="4"></select>
                    </div>
                    <div class="hp-modifier">
                        <input type="number" id="hp-amount" placeholder="Valore HP">
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;">
                            <button id="damage-btn" style="background:linear-gradient(135deg,#ef4444,#dc2626);">üí• Danno</button>
                            <button id="heal-btn" style="background:linear-gradient(135deg,#22d3ee,#06b6d4);">üíö Cura</button>
                        </div>
                    </div>
                    <button id="revive-btn" style="background:linear-gradient(135deg,#22d3ee,#06b6d4);margin-top:8px;">üîÑ Rianima</button>
                </div>

                <!-- ===== 2. GESTIONE TURNI ===== -->
                <details class="control-category" id="accordion-turni">
                    <summary>‚è±Ô∏è Gestione Turni</summary>
                    <div class="category-content">
                        <div class="input-group">
                            <label>Cambia Turno</label>
                            <select id="next-turn-player"></select>
                            <button id="change-turn-btn" style="background:linear-gradient(135deg,#8b5cf6,#7c3aed);">‚è≠Ô∏è Cambia Turno</button>
                        </div>
                        <div class="input-group">
                            <label>Salta Turno</label>
                            <button onclick="quickSkipTurn()" style="background:linear-gradient(135deg,#f59e0b,#d97706);">‚è≠Ô∏è Salta Turno al giocatore selezionato sopra</button>
                        </div>
                        <div class="input-group">
                            <label>Cambia Senso</label>
                            <button id="reverse-direction-btn" style="background:linear-gradient(135deg,#f59e0b,#d97706);">üîÑ Cambia Senso</button>
                        </div>
                        <div class="input-group">
                            <label>Turni Extra</label>
                            <select id="extra-turns-player"></select>
                            <div class="hp-modifier">
                                <input type="number" id="extra-turns-count" placeholder="N¬∞ turni extra (1-5)" min="1" max="5" value="1">
                                <button onclick="setExtraTurns()" style="background:linear-gradient(135deg,#10b981,#059669);">üîÑ Imposta Turni Extra</button>
                            </div>
                        </div>
                        <div class="input-group">
                            <label>Roll Back</label>
                            <button id="rollback-btn" style="background:linear-gradient(135deg,#6b7280,#4b5563);">‚Ü©Ô∏è Rollback</button>
                        </div>
                    </div>
                </details>

                <!-- ===== 3. EFFETTI SEMPLICI ===== -->

                <!-- ===== 4. EFFETTI FATO ===== -->
                <details class="control-category" id="effetti-fato-details">
                    <summary>üé¥ Effetti Fato</summary>
                    <div class="category-content">
                        <div class="input-group">
                            <label>Seleziona Effetto (A‚ÜíZ)</label>
                            <select id="fato-effect-select" onchange="selectFatoEffect(this.value)">
                                <option value="">-- Seleziona un effetto --</option>
                                <option value="3-molio">3 Molio üéØ</option>
                                <option value="7-bello">7 Bello üé∞</option>
                                <option value="alta-marea">Alta Marea üåä</option>
                                <option value="armatura-specchio">Armatura a Specchio ü™û</option>
                                <option value="armatura-sole">Armatura del Sole ‚òÄÔ∏è</option>
                                <option value="armatura-luna">Armatura della Luna üåô</option>
                                <option value="bambola-voodoo">Bambola Voodoo ü™Ü</option>
                                <option value="bilancia-fato">Bilancia del Fato ‚öñÔ∏è</option>
                                <option value="boia-esecutore">Boia Esecutore ü™ì</option>
                                <option value="boomerang">Boomerang ü™É</option>
                                <option value="cactus-amari">Cactus Amari üåµ</option>
                                <option value="cannone-karma">Cannone del Karma üí•</option>
                                <option value="canto-cigno">Canto del Cigno ü¶¢</option>
                                <option value="capsula-rigenerativa">Capsula Rigenerativa üíä</option>
                                <option value="catena-maledetta">Catena Maledetta ‚õìÔ∏è</option>
                                <option value="cessate-fuoco">Cessate il Fuoco üïäÔ∏è</option>
                                <option value="contagio">Contagio ü¶†</option>
                                <option value="armatura-cavaliere">Armatura del Cavaliere Abbandonato üõ°Ô∏è</option>
                                <option value="distorsione">Distorsione Spazio-Temporale ‚è≥üåÄ</option>
                                <option value="dado-avvelenato">Dado Avvelenato ‚ò†Ô∏è</option>
                                <option value="di-pari-pazzo">Di Pari Pazzo üé≤</option>
                                <option value="domino">Domino üÅ°</option>
                                <option value="geyser-fuoco">Geyser di Fuoco üî•</option>
                                <option value="elmo-maledetto">Elmo Maledetto ‚õëÔ∏è</option>
                                <option value="gioco-pulito">Gioco Pulito ‚öñÔ∏è</option>
                                <option value="interferenza">Interferenza üîÄ</option>
                                <option value="tartaruga-lepre">La Tartaruga e la Lepre üê¢üê∞</option>
                                <option value="mano-freya">Mano di Freya üåø</option>
                                <option value="marchio-kraken">Marchio del Kraken üêô</option>
                                <option value="minotauro-corrotto">Minotauro Corrotto üêÇ</option>
                                <option value="nirvana">Nirvana üßò</option>
                                <option value="patto-diavolo">Patto con il Diavolo üòà</option>
                                <option value="pioggia-acida">Pioggia Acida ‚òî</option>
                                <option value="protettore-fato">Protettore del Fato üõ°Ô∏è‚ú®</option>
                                <option value="reincarnazione">Reincarnazione ‚ôªÔ∏è</option>
                                <option value="rifletti-danni">Specchio Maledetto ü™û</option>
                                <option value="scambia-hp">Scambia HP üîÑ</option>
                                <option value="sabbie-mobili">Sabbie Mobili ‚è≥</option>
                                <option value="saldi-estivi">Saldi Estivi üèñÔ∏è</option>
                                <option value="scacco-matto">Scacco Matto ‚ôüÔ∏è</option>
                                <option value="talismano-ra">Talismano di Ra üåû</option>
                                <option value="tiro-caricato">Tiro Caricato ‚ö°</option>
                                <option value="tocca-a-me">Tocca a Me ‚úã</option>
                                <option value="tomba-tutankhamon">Tomba di Tutankhamon üè∫</option>
                                <option value="troll-face">Troll Face üòà</option>
                                <option value="trottola-impazzita">Trottola Impazzita üåÄ</option>
                                
                                <option value="uguaglianza">Uguaglianza ‚öñÔ∏è</option>
                                <option value="volo-fenice">Volo della Fenice ü¶Ö</option>
                                <option value="yin-yang">Yin e Yang ‚òØÔ∏è</option>
                                <option value="zebratura">Zebratura ü¶ì</option>
                            </select>
                        </div>

                        <!-- Effect panels ‚Äì hidden until selected -->
                        <div id="fato-3-molio" class="fato-panel">
                            <label>3 Molio üéØ</label>
                            <select id="tre-molio-activator"><option value="">Seleziona Attivatore</option></select>
                            <button id="toggle-tre-molio-btn" style="background:linear-gradient(135deg,#b45309,#d97706);">üéØ Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#fcd34d;margin-top:6px;padding:6px;background:rgba(217,119,6,0.08);border-radius:6px;">üí° 1 turno: un 3 nei dadi = danno totale a tutti (escluso attivatore)</div>
                        </div>
                        <div id="fato-7-bello" class="fato-panel">
                            <label>7 Bello üé∞</label>
                            <select id="sette-bello-player"></select>
                            <button id="set-sette-bello-btn" style="background:linear-gradient(135deg,#facc15,#f59e0b);">üé∞ Imposta</button>
                            <button id="remove-sette-bello-btn" style="background:#ef4444;">‚ùå Rimuovi</button>
                            <div style="font-size:0.8em;color:#fcd34d;margin-top:6px;padding:6px;background:rgba(250,204,21,0.08);border-radius:6px;">üí° Se fa 7 entro 2 turni, elimina il settimo giocatore</div>
                        </div>
                        <div id="fato-alta-marea" class="fato-panel">
                            <label>Alta Marea üåä</label>
                            <select id="alta-marea-player"></select>
                            <button id="set-alta-marea-btn" style="background:linear-gradient(135deg,#06b6d4,#0891b2);">üåä Imposta</button>
                            <button id="remove-alta-marea-btn" style="background:#ef4444;">‚ùå Rimuovi</button>
                        </div>
                        <div id="fato-armatura-specchio" class="fato-panel">
                            <label>Armatura a Specchio ü™û</label>
                            <select id="armatura-specchio-player"></select>
                            <button id="set-armatura-specchio-btn" style="background:linear-gradient(135deg,#06b6d4,#67e8f9);">ü™û Imposta</button>
                            <button id="remove-armatura-specchio-btn" style="background:#ef4444;">‚ùå Rimuovi</button>
                        </div>
                        <div id="fato-armatura-sole" class="fato-panel">
                            <label>Armatura del Sole ‚òÄÔ∏è</label>
                            <select id="sun-armor-players" multiple size="4"></select>
                            <button id="toggle-sun-armor-btn" style="background:linear-gradient(135deg,#ea580c,#eab308);">‚òÄÔ∏è Attiva/Disattiva</button>
                        </div>
                        <div id="fato-armatura-luna" class="fato-panel">
                            <label>Armatura della Luna üåô</label>
                            <select id="moon-armor-players" multiple size="4"></select>
                            <button id="toggle-moon-armor-btn" style="background:linear-gradient(135deg,#1e3a5f,#3b82f6);">üåô Attiva/Disattiva</button>
                        </div>
                        <div id="fato-bambola-voodoo" class="fato-panel">
                            <label>Bambola Voodoo ü™Ü</label>
                            <select id="bambola-voodoo-activator"><option value="">Seleziona Attivatore</option></select>
                            <button id="toggle-bambola-voodoo-btn" style="background:linear-gradient(135deg,#a855f7,#ec4899);">ü™Ü Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#d8b4fe;margin-top:6px;padding:6px;background:rgba(168,85,247,0.08);border-radius:6px;">üí° 1 turno: ogni giocatore colpisce s√© stesso</div>
                        </div>
                        <div id="fato-bilancia-fato" class="fato-panel">
                            <label>Bilancia del Fato ‚öñÔ∏è</label>
                            <button id="bilancia-fato-btn" style="background:linear-gradient(135deg,#78716c,#a8a29e);">‚öñÔ∏è Attiva</button>
                        </div>
                        <div id="fato-boia-esecutore" class="fato-panel">
                            <label>Boia Esecutore ü™ì</label>
                            <select id="boia-esecutore-players" multiple size="4"></select>
                            <button id="toggle-boia-esecutore-btn" style="background:linear-gradient(135deg,#1f2937,#374151);">ü™ì Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#9ca3af;margin-top:6px;padding:6px;background:rgba(31,41,55,0.3);border-radius:6px;">üí° 2 turni: eliminazione a catena</div>
                        </div>
                        <div id="fato-boomerang" class="fato-panel">
                            <label>Boomerang ü™É</label>
                            <select id="boomerang-player"></select>
                            <button id="set-boomerang-btn" style="background:linear-gradient(135deg,#f97316,#fbbf24);">ü™É Imposta</button>
                            <button id="remove-boomerang-btn" style="background:#ef4444;">‚ùå Rimuovi</button>
                        </div>
                        <div id="fato-cactus-amari" class="fato-panel">
                            <label>Cactus Amari üåµ</label>
                            <select id="cactus-amari-players" multiple size="4"></select>
                            <button id="toggle-cactus-amari-btn" style="background:linear-gradient(135deg,#84cc16,#65a30d);">üåµ Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#bef264;margin-top:6px;padding:6px;background:rgba(132,204,22,0.08);border-radius:6px;">üí° 1 turno: subisce danno e riflette x2</div>
                        </div>
                        <div id="fato-cannone-karma" class="fato-panel">
                            <label>Cannone del Karma üí•</label>
                            <select id="cannone-karma-activator"><option value="">Seleziona Attivatore</option></select>
                            <button id="toggle-cannone-karma-btn" style="background:linear-gradient(135deg,#ef4444,#b91c1c);">üí• Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#f87171;margin-top:6px;padding:6px;background:rgba(239,68,68,0.08);border-radius:6px;">üí° 1 turno: tutti infliggono danni al bersaglio E a s√©</div>
                        </div>
                        <div id="fato-canto-cigno" class="fato-panel">
                            <label>Canto del Cigno ü¶¢</label>
                            <select id="canto-cigno-players" multiple size="4"></select>
                            <button id="toggle-canto-cigno-btn" style="background:linear-gradient(135deg,#bae6fd,#7dd3fc);color:#0c4a6e;">ü¶¢ Attiva/Disattiva</button>
                        </div>
                        <div id="fato-capsula-rigenerativa" class="fato-panel">
                            <label>Capsula Rigenerativa üíä</label>
                            <select id="capsula-rigenerativa-activator"><option value="">Seleziona Attivatore</option></select>
                            <button id="toggle-capsula-rigenerativa-btn" style="background:linear-gradient(135deg,#06b6d4,#3b82f6);">üíä Attiva/Disattiva</button>
                        </div>
                        <div id="fato-catena-maledetta" class="fato-panel">
                            <label>Catena Maledetta ‚õìÔ∏è</label>
                            <select id="catena-maledetta-players" multiple size="4"></select>
                            <button id="toggle-catena-maledetta-btn" style="background:linear-gradient(135deg,#64748b,#475569);">‚õìÔ∏è Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#94a3b8;margin-top:6px;padding:6px;background:rgba(100,116,139,0.08);border-radius:6px;">üí° 1 turno: danno anche ai giocatori adiacenti</div>
                        </div>
                        <div id="fato-cessate-fuoco" class="fato-panel">
                            <label>Cessate il Fuoco üïäÔ∏è</label>
                            <select id="cessate-fuoco-activator"><option value="">Seleziona Attivatore</option></select>
                            <button id="toggle-cessate-fuoco-btn" style="background:linear-gradient(135deg,#22c55e,#84cc16);">üïäÔ∏è Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#86efac;margin-top:6px;padding:6px;background:rgba(34,197,94,0.08);border-radius:6px;">üí° 1 turno: tutti curano. Attivatore si cura della met√†</div>
                        </div>
                        <div id="fato-contagio" class="fato-panel">
                            <label>Contagio ü¶†</label>
                            <select id="contagio-activator"><option value="">Seleziona Attivatore</option></select>
                            <button id="toggle-contagio-btn" style="background:linear-gradient(135deg,#065f46,#059669);">ü¶† Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#6ee7b7;margin-top:6px;padding:6px;background:rgba(5,150,105,0.08);border-radius:6px;">üí° Uso singolo: eliminazione propaga danno a tutti (escluso attivatore)</div>
                        </div>
                        <div id="fato-dado-avvelenato" class="fato-panel">
                            <label>Dado Avvelenato ‚ò†Ô∏è</label>
                            <select id="dado-avvelenato-player" multiple size="4"></select>
                            <div style="display:flex;gap:8px;margin:8px 0;"><input type="number" id="dado-avvelenato-val1" placeholder="D1" min="1" max="6" style="flex:1;"><input type="number" id="dado-avvelenato-val2" placeholder="D2" min="1" max="6" style="flex:1;"></div>
                            <button id="set-dado-avvelenato-btn" style="background:linear-gradient(135deg,#22c55e,#16a34a);">‚ò†Ô∏è Imposta</button>
                            <button id="remove-dado-avvelenato-btn" style="background:#ef4444;">‚ùå Rimuovi</button>
                        </div>
                        <div id="fato-di-pari-pazzo" class="fato-panel">
                            <label>Di Pari Pazzo üé≤</label>
                            <select id="pari-pazzo-activator"><option value="">Seleziona Attivatore</option></select>
                            <button id="toggle-pari-pazzo-btn" style="background:linear-gradient(135deg,#f97316,#ea580c);">üé≤ Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#fdba74;margin-top:6px;padding:6px;background:rgba(249,115,22,0.08);border-radius:6px;">üí° 1 turno: somma pari = auto-danno</div>
                        </div>
                        <div id="fato-domino" class="fato-panel">
                            <label>Domino üÅ°</label>
                            <select id="domino-activator"><option value="">Seleziona Attivatore</option></select>
                            <button id="toggle-domino-btn" style="background:linear-gradient(135deg,#1e293b,#334155);border:1px solid #64748b;">üÅ° Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#94a3b8;margin-top:6px;padding:6px;background:rgba(100,116,139,0.08);border-radius:6px;">üí° 1 turno: i danni si propagano al giocatore successivo</div>
                        </div>
                        <div id="fato-geyser-fuoco" class="fato-panel">
                            <label>Geyser di Fuoco üî•</label>
                            <select id="geyser-activator"><option value="">Seleziona Attivatore</option></select>
                            <div class="hp-modifier">
                                <input type="number" id="geyser-damage" placeholder="Danno base (1-100)" min="1" max="100">
                                <button id="geyser-fuoco-btn" style="background:linear-gradient(135deg,#ef4444,#f97316);">üî• Attiva Geyser</button>
                            </div>
                            <div style="font-size:0.8em;color:#fca5a5;margin-top:6px;padding:6px;background:rgba(239,68,68,0.08);border-radius:6px;">üí° Immediato: danno a catena crescente partendo dal giocatore dopo l'attivatore</div>
                        </div>
                        <div id="fato-gioco-pulito" class="fato-panel">
                            <label>Gioco Pulito ‚öñÔ∏è</label>
                            <select id="gioco-pulito-activator"><option value="">Seleziona Attivatore</option></select>
                            <button id="toggle-gioco-pulito-btn" style="background:linear-gradient(135deg,#64748b,#94a3b8);">‚öñÔ∏è Attiva/Disattiva</button>
                        </div>
                        <div id="fato-interferenza" class="fato-panel">
                            <label>Interferenza üîÄ</label>
                            <select id="interferenza-player1"></select>
                            <select id="interferenza-player2" style="margin-top:6px;"></select>
                            <button id="set-interferenza-btn" style="background:linear-gradient(135deg,#a855f7,#d946ef);">üîÄ Imposta</button>
                            <button id="remove-interferenza-btn" style="background:#ef4444;">‚ùå Rimuovi</button>
                            <div style="font-size:0.8em;color:#e9d5ff;margin-top:6px;padding:6px;background:rgba(168,85,247,0.08);border-radius:6px;">üí° 1 turno: trasferisce i danni ricevuti al partner</div>
                        </div>
                        <div id="fato-tartaruga-lepre" class="fato-panel">
                            <label>La Tartaruga e la Lepre üê¢üê∞</label>
                            <button id="tartaruga-lepre-btn" style="background:linear-gradient(135deg,#84cc16,#eab308);">üê¢üê∞ Attiva</button>
                        </div>
                        <div id="fato-marchio-kraken" class="fato-panel">
                            <label>Marchio del Kraken üêô</label>
                            <select id="kraken-mark-players" multiple size="4"></select>
                            <button id="toggle-kraken-mark-btn" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #7c3aed;">üêô Attiva/Disattiva Marchio</button>
                            <div style="font-size:0.8em;color:#c4b5fd;margin-top:6px;padding:6px;background:rgba(139,92,246,0.1);border-radius:6px;">‚ö†Ô∏è Permanente: eliminazione a ‚â§10 HP</div>
                        </div>
                        <div id="fato-minotauro-corrotto" class="fato-panel">
                            <label>Minotauro Corrotto üêÇ</label>
                            <select id="minotauro-corrotto-activator"><option value="">Seleziona Attivatore</option></select>
                            <button id="toggle-minotauro-corrotto-btn" style="background:linear-gradient(135deg,#7f1d1d,#991b1b);">üêÇ Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#fca5a5;margin-top:6px;padding:6px;background:rgba(153,27,27,0.08);border-radius:6px;">üí° 1 turno: solo danni dispari sono validi (danni pari = 0)</div>
                        </div>
                        <div id="fato-nirvana" class="fato-panel">
                            <label>Nirvana üßò</label>
                            <select id="nirvana-activator"><option value="">Seleziona Attivatore</option></select>
                            <button id="toggle-nirvana-btn" style="background:linear-gradient(135deg,#7c3aed,#a78bfa);">üßò Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#c4b5fd;margin-top:6px;padding:6px;background:rgba(139,92,246,0.08);border-radius:6px;">üí° 1 turno: l'attivatore guadagna HP pari al totale dei dadi altrui</div>
                        </div>
                        <div id="fato-patto-diavolo" class="fato-panel">
                            <label>Patto con il Diavolo üòà</label>
                            <select id="patto-diavolo-players" multiple size="4"></select>
                            <button id="toggle-patto-diavolo-btn" style="background:linear-gradient(135deg,#b91c1c,#ef4444);">üòà Attiva/Disattiva</button>
                        </div>
                        <div id="fato-pioggia-acida" class="fato-panel">
                            <label>Pioggia Acida ‚òî</label>
                            <select id="pioggia-acida-activator"><option value="">Seleziona Attivatore</option></select>
                            <button id="toggle-pioggia-acida-btn" style="background:linear-gradient(135deg,#22c55e,#eab308);">‚òî Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#86efac;margin-top:6px;padding:6px;background:rgba(34,197,94,0.08);border-radius:6px;">üí° 1 turno: danno extra = dado pi√π alto</div>
                        </div>
                        <div id="fato-protettore-fato" class="fato-panel">
                            <label>Protettore del Fato üõ°Ô∏è‚ú®</label>
                            <select id="protettore-fato-players" multiple size="4"></select>
                            <button id="toggle-protettore-fato-btn" style="background:linear-gradient(135deg,#facc15,#fbbf24);">üõ°Ô∏è‚ú® Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#fde047;margin-top:6px;padding:6px;background:rgba(250,204,21,0.08);border-radius:6px;">üí° 1 turno: protegge da TUTTI gli effetti dannosi/eliminazione</div>
                        </div>
                        <div id="fato-reincarnazione" class="fato-panel">
                            <label>Reincarnazione ‚ôªÔ∏è</label>
                            <select id="reincarnazione-players" multiple size="4"></select>
                            <button id="toggle-reincarnazione-btn" style="background:linear-gradient(135deg,#22c55e,#84cc16);">‚ôªÔ∏è Attiva/Disattiva</button>
                        </div>
                        <div id="fato-rifletti-danni" class="fato-panel">
                            <label>Specchio Maledetto ü™û</label>
                            <select id="rifletti-danni-players" multiple size="4"></select>
                            <button id="toggle-rifletti-danni-btn" style="background:linear-gradient(135deg,#3b82f6,#2563eb);">ü™û Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#93c5fd;margin-top:6px;padding:6px;background:rgba(59,130,246,0.08);border-radius:6px;">üí° Uso singolo: riflette il prossimo colpo ricevuto all'attaccante e si disattiva</div>
                        </div>
                        <div id="fato-elmo-maledetto" class="fato-panel">
                            <label>Elmo Maledetto ‚õëÔ∏è</label>
                            <select id="elmo-maledetto-players" multiple size="4"></select>
                            <button id="toggle-elmo-maledetto-btn" style="background:linear-gradient(135deg,#dc2626,#b91c1c);">‚õëÔ∏è Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#fca5a5;margin-top:6px;padding:6px;background:rgba(220,38,38,0.08);border-radius:6px;">üí° 1 turno: tutti i danni subiti vengono riflessi anche all'attaccante (target subisce comunque)</div>
                        </div>
                        <div id="fato-mano-freya" class="fato-panel">
                            <label>Mano di Freya üåø</label>
                            <select id="mano-freya-players" multiple size="4"></select>
                            <button id="toggle-mano-freya-btn" style="background:linear-gradient(135deg,#16a34a,#15803d);">üåø Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#86efac;margin-top:6px;padding:6px;background:rgba(22,163,74,0.08);border-radius:6px;">üí° 1 turno: tutti i danni subiti vengono convertiti in cure</div>
                        </div>
                        <div id="fato-armatura-cavaliere" class="fato-panel">
                            <label>Armatura del Cavaliere Abbandonato üõ°Ô∏è</label>
                            <select id="armatura-cavaliere-players" multiple size="4"></select>
                            <button id="toggle-armatura-cavaliere-btn" style="background:linear-gradient(135deg,#64748b,#475569);">üõ°Ô∏è Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#cbd5e1;margin-top:6px;padding:6px;background:rgba(100,116,139,0.08);border-radius:6px;">üí° 1 turno: tutti i danni subiti vengono dimezzati (arrotondati per difetto)</div>
                        </div>
                        <div id="fato-scambia-hp" class="fato-panel">
                            <label>Scambia HP üîÑ</label>
                            <select id="swap-player-1-fato"></select>
                            <select id="swap-player-2-fato" style="margin-top:6px;"></select>
                            <button id="swap-hp-fato-btn" style="background:linear-gradient(135deg,#a78bfa,#8b5cf6);margin-top:6px;">üîÑ Scambia HP</button>
                        </div>
                        <div id="fato-sabbie-mobili" class="fato-panel">
                            <label>Sabbie Mobili ‚è≥</label>
                            <select id="sabbie-mobili-player"></select>
                            <button id="set-sabbie-mobili-btn" style="background:linear-gradient(135deg,#eab308,#fbbf24);">‚è≥ Imposta</button>
                            <button id="remove-sabbie-mobili-btn" style="background:#ef4444;">‚ùå Rimuovi</button>
                        </div>
                        <div id="fato-saldi-estivi" class="fato-panel">
                            <label>Saldi Estivi üèñÔ∏è</label>
                            <select id="saldi-estivi-activator"><option value="">Seleziona Attivatore</option></select>
                            <button id="toggle-saldi-estivi-btn" style="background:linear-gradient(135deg,#eab308,#f59e0b);">üèñÔ∏è Attiva/Disattiva</button>
                        </div>
                        <div id="fato-scacco-matto" class="fato-panel">
                            <label>Scacco Matto ‚ôüÔ∏è</label>
                            <select id="checkmate-players" multiple size="4"></select>
                            <div class="hp-modifier">
                                <input type="number" id="checkmate-value" placeholder="HP eliminazione" min="1" max="100" value="30">
                                <button id="set-checkmate-btn" style="background:linear-gradient(135deg,#7f1d1d,#991b1b);">‚ôüÔ∏è Imposta Scacco</button>
                                <button id="remove-checkmate-btn" style="background:#ef4444;">‚ùå Rimuovi</button>
                            </div>
                        </div>
                        <div id="fato-talismano-ra" class="fato-panel">
                            <label>Talismano di Ra üåû</label>
                            <select id="talismano-ra-player"></select>
                            <div style="display:flex;gap:8px;margin:8px 0;"><input type="number" id="talismano-ra-val1" placeholder="D1" min="1" max="6" style="flex:1;"><input type="number" id="talismano-ra-val2" placeholder="D2" min="1" max="6" style="flex:1;"></div>
                            <button id="set-talismano-ra-btn" style="background:linear-gradient(135deg,#eab308,#fbbf24);">üåû Imposta</button>
                            <button id="remove-talismano-ra-btn" style="background:#ef4444;">‚ùå Rimuovi</button>
                            <div style="font-size:0.8em;color:#fde047;margin-top:6px;padding:6px;background:rgba(234,179,8,0.08);border-radius:6px;">üí° 1 turno: se i dadi matchano i valori, cura il giocatore</div>
                        </div>
                        <div id="fato-tiro-caricato" class="fato-panel">
                            <label>Tiro Caricato ‚ö°</label>
                            <select id="tiro-caricato-player"></select>
                            <input type="number" id="tiro-caricato-multiplier" placeholder="Moltiplicatore (2-15)" min="2" max="15" value="2" style="margin:8px 0;">
                            <button id="set-tiro-caricato-btn" style="background:linear-gradient(135deg,#f59e0b,#eab308);">‚ö° Imposta</button>
                            <button id="remove-tiro-caricato-btn" style="background:#ef4444;">‚ùå Rimuovi</button>
                            <div style="font-size:0.8em;color:#fde047;margin-top:6px;padding:6px;background:rgba(245,158,11,0.08);border-radius:6px;">üí° Uso singolo: moltiplica il prossimo danno inflitto (NON le cure)</div>
                        </div>
                        <div id="fato-tocca-a-me" class="fato-panel">
                            <label>Tocca a Me ‚úã</label>
                            <select id="tocca-a-me-activator"><option value="">Seleziona Attivatore</option></select>
                            <select id="tocca-a-me-target" style="margin-top:6px;"><option value="">Seleziona Bersaglio</option></select>
                            <button id="set-tocca-a-me-btn" style="background:linear-gradient(135deg,#be185d,#ec4899);">‚úã Imposta</button>
                            <button id="remove-tocca-a-me-btn" style="background:#ef4444;">‚ùå Rimuovi</button>
                            <div style="font-size:0.8em;color:#f9a8d4;margin-top:6px;padding:6px;background:rgba(236,72,153,0.08);border-radius:6px;">üí° Uso singolo: l'attivatore gioca al posto del bersaglio</div>
                        </div>
                        <div id="fato-tomba-tutankhamon" class="fato-panel">
                            <label>Tomba di Tutankhamon üè∫</label>
                            <select id="tomba-tutankhamon-players" multiple size="4"></select>
                            <button id="toggle-tomba-tutankhamon-btn" style="background:linear-gradient(135deg,#c2410c,#f97316);">üè∫ Attiva/Disattiva</button>
                        </div>
                        <div id="fato-troll-face" class="fato-panel">
                            <label>Troll Face üòà</label>
                            <select id="troll-face-activator"><option value="">Seleziona Attivatore</option></select>
                            <input type="number" id="troll-face-value" placeholder="Valore da annullare (1-6)" min="1" max="6" value="3" style="margin:8px 0;">
                            <button id="set-troll-face-btn" style="background:linear-gradient(135deg,#7c3aed,#a855f7);">üòà Imposta</button>
                            <button id="remove-troll-face-btn" style="background:#ef4444;">‚ùå Rimuovi</button>
                            <div style="font-size:0.8em;color:#c4b5fd;margin-top:6px;padding:6px;background:rgba(124,58,237,0.08);border-radius:6px;">üí° 1 turno: il valore scelto diventa 0 per tutti (escluso attivatore)</div>
                        </div>
                        <div id="fato-trottola-impazzita" class="fato-panel">
                            <label>Trottola Impazzita üåÄ</label>
                            <button id="trottola-impazzita-btn" style="background:linear-gradient(135deg,#a855f7,#7c3aed);">üåÄ Attiva</button>
                        </div>
                        <div id="fato-un-mare-guai" class="fato-panel" style="display:none">
                            <label>Un Mare di Guai üåä</label>
                            <select id="mare-guai-players" multiple size="4"></select>
                            <button id="toggle-mare-guai-btn" style="background:linear-gradient(135deg,#06b6d4,#0891b2);">üåä Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#67e8f9;margin-top:6px;padding:6px;background:rgba(6,182,212,0.08);border-radius:6px;">üí° 1 turno: chi attacca il bersaglio subisce effetti casuali negativi</div>
                        </div>
                        <div id="fato-uguaglianza" class="fato-panel">
                            <label>Uguaglianza ‚öñÔ∏è</label>
                            <div class="hp-modifier">
                                <input type="number" id="uguaglianza-divisor" placeholder="Divisore (1-15)" min="1" max="15" value="1">
                                <button id="uguaglianza-btn" style="background:linear-gradient(135deg,#6366f1,#818cf8);">‚öñÔ∏è Attiva</button>
                            </div>
                        </div>
                        <div id="fato-volo-fenice" class="fato-panel">
                            <label>Volo della Fenice ü¶Ö</label>
                            <select id="volo-fenice-players" multiple size="4"></select>
                            <button id="toggle-volo-fenice-btn" style="background:linear-gradient(135deg,#f97316,#ef4444);">ü¶Ö Attiva/Disattiva</button>
                        </div>
                        <div id="fato-yin-yang" class="fato-panel">
                            <label>Yin e Yang ‚òØÔ∏è</label>
                            <button id="yin-yang-btn" style="background:linear-gradient(135deg,#1f2937,#e5e7eb);color:#eab308;">‚òØÔ∏è Attiva</button>
                        </div>
                        <div id="fato-zebratura" class="fato-panel">
                            <label>Zebratura ü¶ì</label>
                            <select id="zebratura-player"></select>
                            <button id="set-zebratura-btn" style="background:linear-gradient(135deg,#1f2937,#e5e7eb);color:#eab308;">ü¶ì Imposta</button>
                            <button id="remove-zebratura-btn" style="background:#ef4444;">‚ùå Rimuovi</button>
                        </div>
                        <div id="fato-distorsione" class="fato-panel">
                            <label>Distorsione Spazio-Temporale ‚è≥üåÄ</label>
                            <select id="distorsione-activator"><option value="">Seleziona Attivatore</option></select>
                            <button id="toggle-distorsione-btn" style="background:linear-gradient(135deg,#7c3aed,#4c1d95);">‚è≥üåÄ Attiva/Disattiva</button>
                            <div style="font-size:0.8em;color:#a78bfa;margin-top:6px;padding:6px;background:rgba(124,58,237,0.1);border-radius:6px;">üí° Dura 3 turni dell'attivatore. All'inizio del 3¬∞ turno o se l'attivatore viene eliminato, la partita termina mostrando il vincitore.</div>
                        </div>
                    </div>
                </details>

                <!-- ===== 5. STRUMENTI DI CALCOLO ===== -->
                <details class="control-category" id="accordion-calcolo">
                    <summary>üßÆ Strumenti di Calcolo</summary>
                    <div class="category-content">
                        <div class="input-group">
                            <label>Calcolatrice</label>
                            <input type="text" id="calc-input" placeholder="Es: 5 + 3 - 2 + 10">
                            <div style="display:flex;gap:8px;margin-top:8px;">
                                <button onclick="calculateExpression()" style="flex:1;">= Calcola</button>
                                <button onclick="clearCalculator()" style="flex:1;background:#ef4444;">üóëÔ∏è</button>
                            </div>
                            <div id="calc-result" style="background:rgba(34,211,238,0.08);padding:10px;border-radius:8px;display:none;font-size:1.1em;font-weight:700;color:#22d3ee;text-align:center;margin-top:8px;"></div>
                        </div>
                        <div class="input-group">
                            <label>Calcolo Bersaglio (senza danno)</label>
                            <div style="margin-bottom:8px;">
                                <label style="font-size:0.8em;color:#64748b;">Attivatore (chi tira i dadi):</label>
                                <select id="target-calc-attivatore" style="margin-top:4px;"></select>
                            </div>
                            <div class="dice-inputs" id="target-calc-dice">
                                <div class="dice-input"><input type="number" id="tcalc-dice-0" min="1" max="6" placeholder="D1"></div>
                                <div class="dice-input"><input type="number" id="tcalc-dice-1" min="1" max="6" placeholder="D2"></div>
                                <div class="dice-input"><input type="number" id="tcalc-dice-2" min="1" max="6" placeholder="D3"></div>
                            </div>
                            <div style="margin:8px 0;">
                                <label style="font-size:0.8em;color:#64748b;">Direzione:</label>
                                <select id="target-calc-direction" style="margin-left:6px;padding:4px 8px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.15);color:#e2e8f0;border-radius:6px;">
                                    <option value="clockwise">üîÑ Orario</option>
                                    <option value="counterclockwise">üîÉ Antiorario</option>
                                </select>
                            </div>
                            <button onclick="calculateTargetOnly()">üéØ Calcola Bersaglio</button>
                            <div id="target-calc-result" style="background:rgba(139,92,246,0.08);padding:10px;border-radius:8px;display:none;margin-top:8px;color:#c4b5fd;font-weight:600;"></div>
                        </div>
                    </div>
                </details>

                <!-- ===== 6. OPZIONI ===== -->
                <details class="control-category" id="accordion-opzioni">
                    <summary>‚öôÔ∏è Opzioni</summary>
                    <div class="category-content">
                        <div class="input-group">
                            <label>Note Giocatore üìù</label>
                            <select id="master-note-player"></select>
                            <div class="hp-modifier">
                                <input type="text" id="master-note-text" placeholder="Nota visibile a tutti" maxlength="100" style="font-size:14px!important;padding:12px!important;min-height:44px!important;">
                                <button onclick="setMasterNote()" style="background:linear-gradient(135deg,#facc15,#f59e0b);">üìù Imposta Nota</button>
                            </div>
                        </div>
                        <div class="input-group">
                            <label>QR Code Rientro üì±</label>
                            <select id="qr-player-select"></select>
                            <button id="show-qr-btn" style="background:linear-gradient(135deg,#6366f1,#4f46e5);">üì± Mostra QR Code</button>
                        </div>
                        <div class="input-group">
                            <label>Dadi Personalizzati üé≤</label>
                            <select id="custom-dice-players" multiple size="4"></select>
                            <div class="hp-modifier">
                                <input type="number" id="custom-dice-value" placeholder="N¬∞ dadi (1-6)" min="1" max="6" value="3">
                                <button id="set-custom-dice-btn" style="background:linear-gradient(135deg,#06b6d4,#22d3ee);">üé≤ Imposta</button>
                                <button id="remove-custom-dice-btn" style="background:#ef4444;">‚ùå Rimuovi</button>
                            </div>
                        </div>
                        <button id="end-game-btn" style="background:#ef4444;margin-top:12px;">üèÅ Termina Partita</button>
                        <button id="new-game-btn" style="background:linear-gradient(135deg,#22d3ee,#06b6d4);margin-top:8px;">üéÆ Nuova Partita (Reset)</button>
                    </div>
                </details>
            </div>

            <!-- Player Tools (visible only for non-master players) -->
            <div id="player-tools" class="master-controls hidden">
                <!-- Pulsante QR per scansionare codice di un altro giocatore -->
                <div class="input-group" style="margin-bottom:12px;background:rgba(124,58,237,0.08);border-radius:10px;padding:10px;">
                    <label style="color:#a78bfa;font-weight:700;">üì± Aiuta un Giocatore a Rientrare</label>
                    <p style="font-size:0.8em;color:#94a3b8;margin:4px 0 8px;">Seleziona un giocatore per generare un QR code che pu√≤ scansionare per rientrare in partita.</p>
                    <select id="player-share-qr-select" style="margin-bottom:8px;"></select>
                    <button id="player-show-qr-btn" style="background:linear-gradient(135deg,#7c3aed,#4c1d95);">üì± Mostra QR per rientrare</button>
                </div>
                <h3>üßÆ Strumenti di Calcolo</h3>
                <div class="category-content" style="padding:0;">
                    <div class="input-group">
                        <label>Calcolatrice</label>
                        <input type="text" id="player-calc-input" placeholder="Es: 5 + 3 - 2 + 10">
                        <div style="display:flex;gap:8px;margin-top:8px;">
                            <button onclick="let r=document.getElementById('player-calc-input').value;try{let v=Function('return '+r.replace(/[^0-9+\-*/().]/g,''))();document.getElementById('player-calc-result').textContent='= '+v;document.getElementById('player-calc-result').style.display='block';}catch(e){alert('Errore!');}" style="flex:1;">= Calcola</button>
                            <button onclick="document.getElementById('player-calc-input').value='';document.getElementById('player-calc-result').style.display='none';" style="flex:1;background:#ef4444;">üóëÔ∏è</button>
                        </div>
                        <div id="player-calc-result" style="background:rgba(34,211,238,0.08);padding:10px;border-radius:8px;display:none;font-size:1.1em;font-weight:700;color:#22d3ee;text-align:center;margin-top:8px;"></div>
                    </div>
                    <div class="input-group">
                        <label>Calcolo Bersaglio (senza danno)</label>
                        <div style="margin-bottom:8px;">
                            <label style="font-size:0.8em;color:#64748b;">Attivatore (chi tira i dadi):</label>
                            <select id="player-tcalc-attivatore" style="margin-top:4px;"></select>
                        </div>
                        <div class="dice-inputs">
                            <div class="dice-input"><input type="number" id="player-tcalc-0" min="1" max="6" placeholder="D1"></div>
                            <div class="dice-input"><input type="number" id="player-tcalc-1" min="1" max="6" placeholder="D2"></div>
                            <div class="dice-input"><input type="number" id="player-tcalc-2" min="1" max="6" placeholder="D3"></div>
                        </div>
                        <button onclick="playerCalcTarget()">üéØ Calcola Bersaglio</button>
                        <div id="player-target-result" style="background:rgba(139,92,246,0.08);padding:10px;border-radius:8px;display:none;margin-top:8px;color:#c4b5fd;font-weight:600;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- QR Code Modal -->
    <div id="qr-modal" class="qr-modal">
        <div class="qr-modal-content">
            <button class="qr-modal-close" id="qr-modal-close">√ó</button>
            <h2>üì± QR Code Partita</h2>
            <div id="qrcode-modal"></div>
            <div class="share-info">
                <p><strong>Codice Partita:</strong></p>
                <div class="game-code" id="modal-game-code"></div>
                <p style="margin-top:8px;font-size:0.85em;">Scansiona il QR code o inserisci il codice</p>
            </div>
        </div>
    </div>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
  apiKey: "AIzaSyAv1tYe2jwc3abq128Ci5PvJK1HTTuF3tY",
  authDomain: "gioco-del-fato.firebaseapp.com",
  databaseURL: "https://gioco-del-fato-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "gioco-del-fato",
  storageBucket: "gioco-del-fato.firebasestorage.app",
  messagingSenderId: "358068623557",
  appId: "1:358068623557:web:dad9bbba9da419e186f8ac"
};

        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        let gameState = {
            gameCode: null,
            isMaster: false,
            playerName: null,
            currentTurn: 0,
            direction: 'clockwise',
            diceCount: 3,
            players: [],
            history: [],
            startTime: null,
            initialHP: 70,
            stats: {}, // Track game statistics
            previousState: null, // For rollback
            globalEffects: {
                cessateFuoco: false,
                cessateFuocoActivator: null,
                pariPazzo: false,
                pariPazzoActivator: null,
                bambolaVoodoo: false,
                bambolaVoodooActivator: null,
                cannoneKarma: false,
                cannoneKarmaActivator: null,
                pioggiaAcida: false,
                pioggiaAcidaActivator: null,
                capsulaRigenerativa: false,
                capsulaRigenerativaActivator: null,
                saldiEstivi: false,
                saldiEstiviActivator: null,
                giocoPulito: false,
                giocoPulitoActivator: null,
                altaMarea: false,
                altaMareaActivator: null,
                zebratura: false,
                zebraturaActivator: null,
                boomerang: false,
                boomerangActivator: null,
                boomerangDamage: 0,
                armaturaSpecchio: false,
                armaturaSpecchioActivator: null,
                sabbieMobili: false,
                sabbieMobiliActivator: null,
                contagio: false,
                contagioActivator: null,
                domino: false,
                dominoActivator: null,
                treMolio: false,
                treMolioActivator: null,
                nirvana: false,
                nirvanaActivator: null,
                toccaAMe: false,
                toccaAMeActivator: null,
                toccaAMeTarget: null,
                toccaAMeRedirectFrom: null,
                setteBello: false,
                setteBelloActivator: null,
                setteBelloTurnsLeft: 0,
                minotauroCorreto: false,
                minotauroCorretoActivator: null,
                trollFace: false,
                trollFaceActivator: null,
                trollFaceValue: null,
                distorsione: false,
                distorsioneActivator: null,
                distorsioneTurnsLeft: 0
            }
        };

        let timerInterval = null;

        // ===== OTTIMIZZAZIONI: Gestione Listener Firebase =====
        let currentGameListener = null; // Traccia il listener principale
        let playerListListener = null; // Traccia il listener lista giocatori

        // ===== OTTIMIZZAZIONE: Aggiornamento UI Ottimistico =====
        // Questa funzione aggiorna IMMEDIATAMENTE l'UI locale senza aspettare Firebase
        // D√† un feedback istantaneo all'utente mentre Firebase sincronizza in background
        function forceUIUpdate() {
            renderPlayers();
            renderLeaderboard();
            renderHistory();
            updateTurnDisplay();
            updateDirectionDisplay();
            renderDiceInputs();
            updateMasterControls();
            renderActiveEffects();
        }

        // Setup Event Listeners
        document.getElementById('num-players').addEventListener('change', generatePlayerNameInputs);

        document.getElementById('create-game-btn').addEventListener('click', createGame);
        document.getElementById('join-game-btn').addEventListener('click', joinGame);
        document.getElementById('start-game-btn').addEventListener('click', startGame);
        document.getElementById('calculate-btn').addEventListener('click', calculateDice);
        
        // Master Controls
        document.getElementById('reverse-direction-btn')?.addEventListener('click', reverseDirection);
        document.getElementById('rollback-btn')?.addEventListener('click', rollbackLastTurn);
        document.getElementById('change-turn-btn')?.addEventListener('click', changeTurn);
        document.getElementById('damage-btn')?.addEventListener('click', () => modifyHP('damage'));
        document.getElementById('heal-btn')?.addEventListener('click', () => modifyHP('heal'));
        document.getElementById('revive-btn')?.addEventListener('click', revivePlayer);
        document.getElementById('swap-hp-btn')?.addEventListener('click', swapHP);
        document.getElementById('end-game-btn')?.addEventListener('click', endGame);
        document.getElementById('new-game-btn')?.addEventListener('click', newGame);
        document.getElementById('show-qr-btn')?.addEventListener('click', showQRModal);
        document.getElementById('qr-modal-close')?.addEventListener('click', closeQRModal);
        document.getElementById('toggle-immortality-btn')?.addEventListener('click', toggleImmortality);
        document.getElementById('set-multiplier-half-btn')?.addEventListener('click', () => setMultiplier(0.5));
        document.getElementById('set-multiplier-double-btn')?.addEventListener('click', () => setMultiplier(2));
        document.getElementById('remove-multiplier-btn')?.addEventListener('click', removeMultiplier);
        document.getElementById('toggle-skip-turn-btn')?.addEventListener('click', toggleSkipTurn);
        document.getElementById('set-custom-dice-btn')?.addEventListener('click', setCustomDice);
        document.getElementById('remove-custom-dice-btn')?.addEventListener('click', removeCustomDice);
        document.getElementById('toggle-kraken-mark-btn')?.addEventListener('click', toggleKrakenMark);
        document.getElementById('set-checkmate-btn')?.addEventListener('click', setCheckmate);
        document.getElementById('remove-checkmate-btn')?.addEventListener('click', removeCheckmate);
        document.getElementById('toggle-damage-to-heal-btn')?.addEventListener('click', toggleDamageToHeal);
        document.getElementById('toggle-sun-armor-btn')?.addEventListener('click', toggleSunArmor);
        document.getElementById('toggle-moon-armor-btn')?.addEventListener('click', toggleMoonArmor);
        
        // Event Listeners Nuove Meccaniche
        document.getElementById('toggle-cessate-fuoco-btn')?.addEventListener('click', toggleCessateFuoco);
        document.getElementById('toggle-pari-pazzo-btn')?.addEventListener('click', togglePariPazzo);
        document.getElementById('toggle-bambola-voodoo-btn')?.addEventListener('click', toggleBambolaVoodoo);
        document.getElementById('toggle-cannone-karma-btn')?.addEventListener('click', toggleCannoneKarma);
        document.getElementById('toggle-pioggia-acida-btn')?.addEventListener('click', togglePioggiaAcida);
        document.getElementById('toggle-capsula-rigenerativa-btn')?.addEventListener('click', toggleCapsulaRigenerativa);
        document.getElementById('toggle-saldi-estivi-btn')?.addEventListener('click', toggleSaldiEstivi);
        document.getElementById('toggle-gioco-pulito-btn')?.addEventListener('click', toggleGiocoPulito);
        document.getElementById('trottola-impazzita-btn')?.addEventListener('click', activateTrottolaImpazzita);
        document.getElementById('tartaruga-lepre-btn')?.addEventListener('click', activateTartarugaLepre);
        document.getElementById('yin-yang-btn')?.addEventListener('click', activateYinYang);
        document.getElementById('bilancia-fato-btn')?.addEventListener('click', activateBilanciaFato);
        document.getElementById('uguaglianza-btn')?.addEventListener('click', activateUguaglianza);
        document.getElementById('geyser-fuoco-btn')?.addEventListener('click', activateGeyserFuoco);
        document.getElementById('toggle-mare-guai-btn')?.addEventListener('click', toggleMareGuai);
        document.getElementById('set-talismano-ra-btn')?.addEventListener('click', setTalismanRa);
        document.getElementById('remove-talismano-ra-btn')?.addEventListener('click', removeTalismanRa);
        document.getElementById('set-dado-avvelenato-btn')?.addEventListener('click', setDadoAvvelenato);
        document.getElementById('remove-dado-avvelenato-btn')?.addEventListener('click', removeDadoAvvelenato);
        document.getElementById('set-interferenza-btn')?.addEventListener('click', setInterferenza);
        document.getElementById('remove-interferenza-btn')?.addEventListener('click', removeInterferenza);
        document.getElementById('toggle-volo-fenice-btn')?.addEventListener('click', toggleVoloFenice);
        document.getElementById('toggle-cactus-amari-btn')?.addEventListener('click', toggleCactusAmari);
        document.getElementById('toggle-catena-maledetta-btn')?.addEventListener('click', toggleCatenaMaledetta);
        document.getElementById('set-alta-marea-btn')?.addEventListener('click', setAltaMarea);
        document.getElementById('remove-alta-marea-btn')?.addEventListener('click', removeAltaMarea);
        document.getElementById('set-zebratura-btn')?.addEventListener('click', setZebratura);
        document.getElementById('remove-zebratura-btn')?.addEventListener('click', removeZebratura);
        document.getElementById('toggle-rifletti-danni-btn')?.addEventListener('click', toggleRiflettiDanni);
        document.getElementById('toggle-elmo-maledetto-btn')?.addEventListener('click', toggleElmoMaledetto);
        document.getElementById('toggle-mano-freya-btn')?.addEventListener('click', toggleManoFreya);
        document.getElementById('toggle-armatura-cavaliere-btn')?.addEventListener('click', toggleArmaturaCavaliere);
        document.getElementById('swap-hp-fato-btn')?.addEventListener('click', () => swapHP('fato'));
        document.getElementById('set-boomerang-btn')?.addEventListener('click', setBoomerang);
        document.getElementById('remove-boomerang-btn')?.addEventListener('click', removeBoomerang);
        document.getElementById('set-armatura-specchio-btn')?.addEventListener('click', setArmaturaSpecchio);
        document.getElementById('remove-armatura-specchio-btn')?.addEventListener('click', removeArmaturaSpecchio);
        document.getElementById('set-sabbie-mobili-btn')?.addEventListener('click', setSabbieMobili);
        document.getElementById('remove-sabbie-mobili-btn')?.addEventListener('click', removeSabbieMobili);
        document.getElementById('set-sette-bello-btn')?.addEventListener('click', set7Bello);
        document.getElementById('remove-sette-bello-btn')?.addEventListener('click', remove7Bello);
        document.getElementById('toggle-canto-cigno-btn')?.addEventListener('click', toggleCantoCigno);
        document.getElementById('toggle-patto-diavolo-btn')?.addEventListener('click', togglePattoDiavolo);
        document.getElementById('toggle-tomba-tutankhamon-btn')?.addEventListener('click', toggleTombaTutankhamon);
        document.getElementById('toggle-reincarnazione-btn')?.addEventListener('click', toggleReincarnazione);
        document.getElementById('toggle-boia-esecutore-btn')?.addEventListener('click', toggleBoiaEsecutore);
        document.getElementById('toggle-domino-btn')?.addEventListener('click', toggleDomino);
        document.getElementById('toggle-contagio-btn')?.addEventListener('click', toggleContagio);
        document.getElementById('toggle-tre-molio-btn')?.addEventListener('click', toggleTreMolio);
        document.getElementById('toggle-nirvana-btn')?.addEventListener('click', toggleNirvana);
        document.getElementById('set-tocca-a-me-btn')?.addEventListener('click', setToccaAMe);
        document.getElementById('remove-tocca-a-me-btn')?.addEventListener('click', removeToccaAMe);
        document.getElementById('toggle-protettore-fato-btn')?.addEventListener('click', toggleProtettoreFato);
        document.getElementById('toggle-distorsione-btn')?.addEventListener('click', toggleDistorsione);
        document.getElementById('set-tiro-caricato-btn')?.addEventListener('click', setTiroCaricato);
        document.getElementById('remove-tiro-caricato-btn')?.addEventListener('click', removeTiroCaricato);
        document.getElementById('toggle-minotauro-corrotto-btn')?.addEventListener('click', toggleMinotauroCorreto);
        document.getElementById('set-troll-face-btn')?.addEventListener('click', setTrollFace);
        document.getElementById('remove-troll-face-btn')?.addEventListener('click', removeTrollFace);
        
        // Close modal clicking outside
        document.getElementById('qr-modal')?.addEventListener('click', function(e) {
            if (e.target === this) {
                closeQRModal();
            }
        });

        // ===== FIX: Cleanup listener quando si chiude/ricarica la pagina =====
        window.addEventListener('beforeunload', function() {
            if (currentGameListener && gameState.gameCode) {
                database.ref('games/' + gameState.gameCode).off('value', currentGameListener);
            }
            if (playerListListener && gameState.gameCode) {
                database.ref('games/' + gameState.gameCode).off('value', playerListListener);
            }
            if (timerInterval) {
                clearInterval(timerInterval);
            }
        });

        // Auto-detect role from URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const gameCode = urlParams.get('game');
        const playerNameFromURL = urlParams.get('player');
        
        // ===== AUTO-RECONNECT: Ripristina sessione dopo refresh =====
        const savedGameCode = sessionStorage.getItem('gioco_gameCode');
        const savedIsMaster = sessionStorage.getItem('gioco_isMaster') === 'true';
        const savedPlayerName = sessionStorage.getItem('gioco_playerName');
        
        if (gameCode) {
            // Player joining via QR code
            document.getElementById('player-join').classList.remove('hidden');
            document.getElementById('display-game-code').textContent = gameCode;
            loadAvailablePlayers(gameCode);
            
            // Auto-join if player name is in URL
            if (playerNameFromURL) {
                setTimeout(() => {
                    joinGame();
                }, 500);
            }
        } else if (savedGameCode) {
            // ===== RECONNECT: Ripristina sessione esistente =====
            database.ref('games/' + savedGameCode).once('value').then(snapshot => {
                if (!snapshot.exists()) {
                    // Partita non trovata, pulisci e mostra setup
                    sessionStorage.removeItem('gioco_gameCode');
                    sessionStorage.removeItem('gioco_isMaster');
                    sessionStorage.removeItem('gioco_playerName');
                    document.getElementById('master-setup').classList.remove('hidden');
                    generatePlayerNameInputs();
                    return;
                }
                const data = snapshot.val();
                
                if (savedIsMaster) {
                    // Riconnetti come Master
                    gameState.gameCode = savedGameCode;
                    gameState.isMaster = true;
                    gameState.playerName = data.players ? (data.players.find(p => true)?.name || 'Master') : 'Master';
                    listenToGameChanges(savedGameCode);
                    if (data.started) {
                        showGameScreen();
                    } else {
                        showQRCode(savedGameCode);
                    }
                } else if (savedPlayerName) {
                    // Riconnetti come Giocatore
                    const playerIndex = data.players ? data.players.findIndex(p => p.name === savedPlayerName) : -1;
                    if (playerIndex >= 0) {
                        database.ref('games/' + savedGameCode + '/players/' + playerIndex).update({ connected: true });
                        gameState.gameCode = savedGameCode;
                        gameState.isMaster = false;
                        gameState.playerName = savedPlayerName;
                        listenToGameChanges(savedGameCode);
                        if (data.started) {
                            showGameScreen();
                        } else {
                            document.getElementById('setup-screen').innerHTML = `
                                <div style="text-align:center;padding:40px;">
                                    <h2 style="color:#ffd700;margin-bottom:20px;">‚úÖ Riconnesso come ${savedPlayerName}!</h2>
                                    <p style="font-size:1.2em;margin-bottom:30px;">In attesa che il Master avvii la partita...</p>
                                    <div style="font-size:3em;animation:pulse 2s infinite;">‚è≥</div>
                                </div>`;
                        }
                    } else {
                        // Giocatore non trovato
                        sessionStorage.clear();
                        document.getElementById('master-setup').classList.remove('hidden');
                        generatePlayerNameInputs();
                    }
                } else {
                    sessionStorage.clear();
                    document.getElementById('master-setup').classList.remove('hidden');
                    generatePlayerNameInputs();
                }
            });
        } else {
            // Master creating new game
            document.getElementById('master-setup').classList.remove('hidden');
            generatePlayerNameInputs();
        }

        function loadAvailablePlayers(code) {
            // ===== FIX: Rimuovi listener precedente =====
            if (playerListListener) {
                database.ref('games/' + code).off('value', playerListListener);
                playerListListener = null;
            }
            
            playerListListener = function(snapshot) {
                if (!snapshot.exists()) {
                    return;
                }

                const gameData = snapshot.val();
                const select = document.getElementById('player-name-select');
                
                if (!select) return;
                
                select.innerHTML = '<option value="">Seleziona il tuo nome...</option>';
                
                gameData.players.forEach((player) => {
                    const option = document.createElement('option');
                    option.value = player.name;
                    option.textContent = player.name + (player.connected ? ' ‚úì' : '');
                    option.disabled = player.connected;
                    select.appendChild(option);
                });
                
                // Update connected players list for master
                const connectedList = document.getElementById('connected-players-list');
                if (connectedList) {
                    connectedList.innerHTML = gameData.players
                        .map(p => `<div style="color: ${p.connected ? '#4ecca3' : '#888'}; padding: 5px;">
                            ${p.connected ? '‚úì' : '‚óã'} ${p.name}
                        </div>`)
                        .join('');
                }
            };
            
            // Attiva il listener
            database.ref('games/' + code).on('value', playerListListener);
        }

        function generatePlayerNameInputs() {
            const numPlayers = parseInt(document.getElementById('num-players').value);
            const container = document.getElementById('player-names-container');
            container.innerHTML = '<div class="input-group"><label>Nomi degli altri giocatori:</label></div>';
            
            for (let i = 1; i < numPlayers; i++) {
                const div = document.createElement('div');
                div.className = 'player-input';
                div.innerHTML = `
                    <input type="text" placeholder="Giocatore ${i + 1}" id="player-${i}">
                `;
                container.appendChild(div);
            }

            // Auto-suggest HP based on number of players
            const hpInput = document.getElementById('initial-hp');
            if (numPlayers === 4) {
                hpInput.value = 60;
            } else if (numPlayers >= 5 && numPlayers <= 6) {
                hpInput.value = 70;
            } else if (numPlayers >= 7 && numPlayers <= 8) {
                hpInput.value = 80;
            } else if (numPlayers >= 9) {
                hpInput.value = 85;
            }
        }

        function createGame() {
            const masterName = document.getElementById('master-name').value.trim();
            const numPlayers = parseInt(document.getElementById('num-players').value);
            const initialHP = parseInt(document.getElementById('initial-hp').value);

            if (!masterName) {
                alert('Inserisci il tuo nome!');
                return;
            }

            const players = [{ 
                name: masterName, 
                hp: initialHP, 
                isEliminated: false, 
                isMaster: true, 
                connected: true, 
                isImmortal: false, 
                multiplier: 1,
                multiplierAppliedBy: null,
                skipTurn: false,
                customDiceCount: null,
                krakenMark: false,
                checkmateHP: null,
                damageToHeal: false,
                sunArmor: false,
                moonArmor: false,
                mareGuai: false,
                voloFenice: false,
                cactusAmari: false,
                catenaMaledetta: false,
                rifletteDanni: false,
                elmoMaledetto: false,
                manoFreya: false,
                armaturaCavaliere: false,
                talismanRa: false,
                talismanRaValues: [],
                dadoAvvelenato: false,
                dadoAvvelenatotValues: [],
                interferenza: false,
                interferenzaPartner: null,
                cantoDelCigno: false,
                pattoDiavolo: false,
                pattoDiavoloUsed: false,
                tombaTutankhamon: false,
                reincarnazione: false,
                reincarnazioneUsed: false,
                boiaEsecutore: false,
                boiaEsecutoreTurns: 0,
                extraTurns: 0,
                protettoreFato: false,
                tiroCaricato: false,
                tiroCaricatoMultiplier: null,
                temporaryEffects: {
                    immortal: false,
                    multiplier: false,
                    skipTurn: false,
                    customDice: false,
                    damageToHeal: false,
                    sunArmor: false,
                    moonArmor: false,
                    mareGuai: false,
                    voloFenice: false,
                    cactusAmari: false,
                    catenaMaledetta: false,
                    rifletteDanni: false,
                elmoMaledetto: false,
                manoFreya: false,
                armaturaCavaliere: false,
                    talismanRa: false,
                    dadoAvvelenato: false,
                    protettoreFato: false
                }
            }];
            
            for (let i = 1; i < numPlayers; i++) {
                const playerName = document.getElementById(`player-${i}`).value.trim();
                if (playerName) {
                    players.push({ 
                        name: playerName, 
                        hp: initialHP, 
                        isEliminated: false, 
                        isMaster: false, 
                        connected: false, 
                        isImmortal: false, 
                        multiplier: 1,
                        multiplierAppliedBy: null,
                        skipTurn: false,
                        customDiceCount: null,
                        krakenMark: false,
                        checkmateHP: null,
                        damageToHeal: false,
                        sunArmor: false,
                        moonArmor: false,
                        mareGuai: false,
                        voloFenice: false,
                        cactusAmari: false,
                        catenaMaledetta: false,
                        rifletteDanni: false,
                elmoMaledetto: false,
                manoFreya: false,
                armaturaCavaliere: false,
                        talismanRa: false,
                        talismanRaValues: [],
                        dadoAvvelenato: false,
                        dadoAvvelenatotValues: [],
                        interferenza: false,
                        interferenzaPartner: null,
                        cantoDelCigno: false,
                        pattoDiavolo: false,
                        pattoDiavoloUsed: false,
                        tombaTutankhamon: false,
                        reincarnazione: false,
                        reincarnazioneUsed: false,
                        boiaEsecutore: false,
                        boiaEsecutoreTurns: 0,
                        extraTurns: 0,
                        masterNote: '', // Note del master visibili a tutti
                        protettoreFato: false,
                        tiroCaricato: false,
                        tiroCaricatoMultiplier: null,
                        temporaryEffects: {
                            immortal: false,
                            multiplier: false,
                            skipTurn: false,
                            customDice: false,
                            damageToHeal: false,
                            sunArmor: false,
                            moonArmor: false,
                            mareGuai: false,
                            voloFenice: false,
                            cactusAmari: false,
                            catenaMaledetta: false,
                            rifletteDanni: false,
                elmoMaledetto: false,
                manoFreya: false,
                armaturaCavaliere: false,
                            talismanRa: false,
                            dadoAvvelenato: false,
                            protettoreFato: false
                        }
                    });
                }
            }

            if (players.length < 2) {
                alert('Servono almeno 2 giocatori!');
                return;
            }

            const code = generateGameCode();
            gameState.gameCode = code;
            gameState.isMaster = true;
            gameState.playerName = masterName;

            // ===== RECONNECT: Salva sessione master per il refresh =====
            sessionStorage.setItem('gioco_gameCode', code);
            sessionStorage.setItem('gioco_isMaster', 'true');
            sessionStorage.removeItem('gioco_playerName');

            const gameData = {
                players: players,
                currentTurn: 0,
                direction: 'clockwise',
                diceCount: 3,
                history: [],
                startTime: null,
                started: false,
                initialHP: initialHP
            };

            database.ref('games/' + code).set(gameData).then(() => {
                showQRCode(code);
            });
        }

        function generateGameCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function showQRCode(code) {
            document.getElementById('master-setup').classList.add('hidden');
            document.getElementById('qr-display').classList.remove('hidden');
            document.getElementById('game-code-display').textContent = code;

            const url = window.location.origin + window.location.pathname + '?game=' + code;
            
            new QRCode(document.getElementById('qrcode'), {
                text: url,
                width: 200,
                height: 200,
                colorDark: "#000000",
                colorLight: "#ffffff"
            });

            listenToGameChanges(code);
        }

        function joinGame() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('game');
            const playerNameFromURL = urlParams.get('player');
            
            // If player name is in URL, use it directly
            let playerName = playerNameFromURL;
            
            // Otherwise get from select
            if (!playerName) {
                playerName = document.getElementById('player-name-select').value;
            }

            if (!playerName || !code) {
                alert('Seleziona il tuo nome!');
                return;
            }

            database.ref('games/' + code).once('value').then((snapshot) => {
                if (!snapshot.exists()) {
                    alert('Partita non trovata!');
                    return;
                }

                const gameData = snapshot.val();
                
                // Find player by name (regardless of connection status)
                const playerIndex = gameData.players.findIndex(p => p.name === playerName);
                
                if (playerIndex < 0) {
                    alert('Giocatore non trovato in questa partita!');
                    return;
                }

                // Mark player as connected (reconnection allowed)
                gameData.players[playerIndex].connected = true;
                database.ref('games/' + code + '/players/' + playerIndex).update({ connected: true });

                gameState.gameCode = code;
                gameState.isMaster = false;
                gameState.playerName = playerName;

                // ===== RECONNECT: Salva sessione per il refresh =====
                sessionStorage.setItem('gioco_gameCode', code);
                sessionStorage.setItem('gioco_playerName', playerName);

                listenToGameChanges(code);
                
                if (gameData.started) {
                    showGameScreen();
                } else {
                    // Show waiting screen
                    document.getElementById('setup-screen').innerHTML = `
                        <div style="text-align: center; padding: 40px;">
                            <h2 style="color: #ffd700; margin-bottom: 20px;">‚úÖ Connesso come ${playerName}!</h2>
                            <p style="font-size: 1.2em; margin-bottom: 30px;">In attesa che il Master avvii la partita...</p>
                            <div style="font-size: 3em; animation: pulse 2s infinite;">‚è≥</div>
                        </div>
                    `;
                }
            });
        }

        function startGame() {
            if (!gameState.gameCode) return;

            const startTime = Date.now();
            database.ref('games/' + gameState.gameCode).update({
                started: true,
                startTime: startTime
            });

            showGameScreen();
        }

        function showGameScreen() {
            document.getElementById('setup-screen').classList.add('hidden');
            document.getElementById('game-screen').classList.remove('hidden');

            if (gameState.isMaster) {
                document.getElementById('master-controls').classList.remove('hidden');
                document.getElementById('quick-commands').classList.remove('hidden');
                // Populate geyser activator select
                const geyserAct = document.getElementById('geyser-activator');
                if (geyserAct) {
                    geyserAct.innerHTML = '<option value="">Seleziona Attivatore</option>';
                    gameState.players.forEach((p, i) => {
                        if (!p.isEliminated) geyserAct.innerHTML += '<option value="' + i + '">' + p.name + '</option>';
                    });
                }
                // Hide player-only tools section
                const playerTools = document.getElementById('player-tools');
                if (playerTools) playerTools.classList.add('hidden');
            } else {
                // Show player-only tools
                const playerTools = document.getElementById('player-tools');
                if (playerTools) playerTools.classList.remove('hidden');
                
                // Populate player-share-qr-select
                const shareSelect = document.getElementById('player-share-qr-select');
                if (shareSelect) {
                    shareSelect.innerHTML = '';
                    gameState.players.forEach((p, i) => {
                        if (!p.isEliminated) {
                            const opt = document.createElement('option');
                            opt.value = i;
                            opt.textContent = p.name;
                            shareSelect.appendChild(opt);
                        }
                    });
                }
                
                // Wire up QR button for player
                document.getElementById('player-show-qr-btn')?.addEventListener('click', () => {
                    const idx = parseInt(document.getElementById('player-share-qr-select').value);
                    if (isNaN(idx)) return;
                    const targetPlayer = gameState.players[idx];
                    const modal = document.getElementById('qr-modal');
                    const qrContainer = document.getElementById('qrcode-modal');
                    const codeDisplay = document.getElementById('modal-game-code');
                    qrContainer.innerHTML = '';
                    const url = window.location.origin + window.location.pathname + '?game=' + gameState.gameCode + '&player=' + encodeURIComponent(targetPlayer.name);
                    new QRCode(qrContainer, { text: url, width: 256, height: 256, colorDark: '#000', colorLight: '#fff', correctLevel: QRCode.CorrectLevel.H });
                    codeDisplay.textContent = gameState.gameCode + ' ‚Äì ' + targetPlayer.name;
                    modal.classList.add('show');
                });
            }

            renderDiceInputs();
            renderActiveEffects();
        }

        function listenToGameChanges(code) {
            // ===== FIX: Rimuovi listener precedente per evitare duplicati =====
            if (currentGameListener) {
                database.ref('games/' + gameState.gameCode).off('value', currentGameListener);
                currentGameListener = null;
            }
            
            // Definisci il listener come funzione nominata per poterlo rimuovere
            currentGameListener = function(snapshot) {
                if (!snapshot.exists()) return;

                const data = snapshot.val();
                
                // ===== PERFORMANCE: Skip full re-render if data hasn't changed =====
                const snapshotKey = data.currentTurn + '|' + (data.players||[]).map(p=>p.hp+':'+(p.isEliminated?1:0)).join(',') + '|' + (data.history||[]).length;
                if (currentGameListener._lastKey === snapshotKey && document.getElementById('game-screen') && !document.getElementById('game-screen').classList.contains('hidden')) {
                    // Only update turn display quickly without full rebuild
                    gameState.players = data.players || [];
                    gameState.currentTurn = data.currentTurn || 0;
                    gameState.history = data.history || [];
                    gameState.globalEffects = data.globalEffects || gameState.globalEffects;
                    updateTurnDisplay();
                    renderHistory(); // Has its own dirty check
                    return;
                }
                currentGameListener._lastKey = snapshotKey;
                gameState.players = data.players || [];
                gameState.currentTurn = data.currentTurn || 0;
                gameState.direction = data.direction || 'clockwise';
                gameState.diceCount = data.diceCount || 3;
                gameState.history = data.history || [];
                gameState.startTime = data.startTime;
                gameState.initialHP = data.initialHP || 70;
                gameState.stats = data.stats || {};

                if (data.started && document.getElementById('setup-screen').classList.contains('hidden') === false) {
                    showGameScreen();
                }
                
                // Show winner notification when game ends (only once)
                if (data.gameEnded && data.winner && !document.querySelector('.winner-notification')) {
                    const isYou = data.winner === gameState.playerName;
                    showWinnerNotification(data.winner, isYou);
                }
                // If game was reset, remove any leftover winner overlay
                if (!data.gameEnded) {
                    document.querySelectorAll('.winner-notification, .hit-overlay').forEach(el => el.remove());
                }

                renderPlayers();
                renderLeaderboard();
                renderHistory();
                updateTurnDisplay();
                updateDirectionDisplay();
                renderDiceInputs();
                updateMasterControls();
                renderActiveEffects();

                if (gameState.startTime && !timerInterval) {
                    startTimer();
                }
            };
            
            // Attiva il listener
            database.ref('games/' + code).on('value', currentGameListener);
        }

        function renderPlayers() {
            const container = document.getElementById('players-list');
            
            gameState.players.forEach((player, index) => {
                let card = document.getElementById(`player-card-${index}`);
                
                // Create card only if it doesn't exist yet
                if (!card) {
                    card = document.createElement('div');
                    card.className = 'player-card';
                    card.id = `player-card-${index}`;
                    container.appendChild(card);
                }
                
                // Update classes
                card.className = 'player-card' +
                    (index === gameState.currentTurn && !player.isEliminated ? ' active-turn' : '') +
                    (player.isEliminated ? ' eliminated' : '');

                const hpPercent = Math.max(0, Math.min(100, (player.hp / gameState.initialHP) * 100));
                const hpClass = player.hp < 30 ? 'low' : '';
                const hpBarColor = hpPercent > 60 ? '#00ff88' : hpPercent > 30 ? '#ffa500' : '#ff0066';
                
                let badges = '';
                if (player.isMaster) badges += '<span class="effect-badge master">üëë Master</span>';
                if (player.isImmortal) badges += '<span class="effect-badge immortal">‚≠ê Immortale</span>';
                if (player.multiplier > 1) badges += '<span class="effect-badge damage-mult">‚öîÔ∏è x' + player.multiplier + '</span>';
                if (player.multiplier < 1) badges += '<span class="effect-badge shield-mult">üõ°Ô∏è x' + player.multiplier + '</span>';
                if (player.skipTurn) badges += '<span class="effect-badge skip">‚è≠Ô∏è Salta</span>';
                if (player.customDiceCount) badges += '<span class="effect-badge dice">üé≤ √ó' + player.customDiceCount + '</span>';
                if (player.krakenMark) badges += '<span class="effect-badge kraken">üêô Kraken</span>';
                if (player.checkmateHP) badges += '<span class="effect-badge checkmate">‚ôüÔ∏è ‚â§' + player.checkmateHP + '</span>';
                if (player.damageToHeal) badges += '<span class="effect-badge convert">üí´ D‚ÜíC</span>';
                if (player.sunArmor) badges += '<span class="effect-badge sun">‚òÄÔ∏è Sole</span>';
                if (player.moonArmor) badges += '<span class="effect-badge moon">üåô Luna</span>';
                if (player.voloFenice) badges += '<span class="effect-badge fenice">ü¶Ö Fenice</span>';
                if (player.cactusAmari) badges += '<span class="effect-badge cactus">üåµ Cactus</span>';
                if (player.catenaMaledetta) badges += '<span class="effect-badge chain">‚õìÔ∏è Catena</span>';
                if (player.rifletteDanni) badges += '<span class="effect-badge reflect">ü™û Specchio</span>';
                if (player.elmoMaledetto) badges += '<span class="effect-badge elmo">‚õëÔ∏è Elmo</span>';
                if (player.manoFreya) badges += '<span class="effect-badge freya">üåø Freya</span>';
                if (player.armaturaCavaliere) badges += '<span class="effect-badge cavaliere">üõ°Ô∏è Cavaliere</span>';
                if (player.cantoDelCigno) badges += '<span class="effect-badge cigno">ü¶¢</span>';
                if (player.pattoDiavolo) badges += '<span class="effect-badge diavolo">üòà</span>';
                if (player.tombaTutankhamon) badges += '<span class="effect-badge tomba">üè∫</span>';
                if (player.reincarnazione) badges += '<span class="effect-badge reincarna">‚ôªÔ∏è</span>';
                if (player.boiaEsecutore) badges += '<span class="effect-badge boia">ü™ì ' + player.boiaEsecutoreTurns + 't</span>';
                if (player.extraTurns > 0) badges += '<span class="effect-badge extra-turn">üîÑ +' + player.extraTurns + '</span>';
                if (player.protettoreFato) badges += '<span class="effect-badge protettore">üõ°Ô∏è‚ú® Protetto</span>';
                if (player.tiroCaricato) badges += '<span class="effect-badge tiro-caricato">‚ö° x' + (player.tiroCaricatoMultiplier || 2) + '</span>';
                
                const newHTML = `
                    <div class="player-info">
                        <div class="player-name-section">
                            <div class="player-name">${player.name}</div>
                            <div class="player-badges">${badges}</div>
                        </div>
                        <div class="player-hp-section">
                            <div class="player-hp ${hpClass}">${player.hp}</div>
                            <div class="hp-label">HP</div>
                        </div>
                    </div>
                    <div class="hp-bar-container">
                        <div class="hp-bar" style="width: ${hpPercent}%; background: ${hpBarColor};"></div>
                    </div>
                    ${player.masterNote ? '<div style="background:rgba(250,204,21,0.08);padding:6px 8px;border-radius:6px;margin-top:6px;font-size:0.85em;color:#facc15;border-left:2px solid #facc15;">üìù ' + player.masterNote + '</div>' : ''}
                    ${player.isEliminated ? '<div class="eliminated-tag">‚ò†Ô∏è ELIMINATO</div>' : ''}
                `;
                
                // Only update innerHTML if content actually changed
                if (card.innerHTML !== newHTML) {
                    card.innerHTML = newHTML;
                }
            });
        }

        function renderLeaderboard() {
            const container = document.getElementById('leaderboard-list');
            const sorted = [...gameState.players].sort((a, b) => b.hp - a.hp);
            const medals = ['ü•á', 'ü•à', 'ü•â'];
            
            sorted.forEach((player, index) => {
                let item = document.getElementById(`lb-item-${player.name.replace(/\s/g,'_')}`);
                if (!item) {
                    item = document.createElement('div');
                    item.id = `lb-item-${player.name.replace(/\s/g,'_')}`;
                    item.className = 'leaderboard-item';
                    container.appendChild(item);
                }
                item.className = 'leaderboard-item' + (index === 0 ? ' winner' : '') + (player.isEliminated ? ' lb-eliminated' : '');
                
                const medal = index < 3 ? medals[index] : `<span class="lb-rank">${index + 1}</span>`;
                const hpPercent = Math.max(0, (player.hp / gameState.initialHP) * 100);
                const newHTML = `
                    <div class="lb-left">
                        <span class="lb-medal">${medal}</span>
                        <span class="lb-name">${player.name}${player.isEliminated ? ' ‚ò†Ô∏è' : ''}</span>
                    </div>
                    <div class="lb-right">
                        <div class="lb-hp-bar"><div class="lb-hp-fill" style="width:${hpPercent.toFixed(1)}%"></div></div>
                        <span class="lb-hp-val">${player.hp}</span>
                    </div>
                `;
                if (item.innerHTML !== newHTML) item.innerHTML = newHTML;
                // Ensure correct position
                if (container.children[index] !== item) container.insertBefore(item, container.children[index] || null);
            });
        }

        function renderHistory() {
            const container = document.getElementById('history');
            const recent = gameState.history.slice(-20).reverse();
            const key = recent.join('|');
            if (container._lastKey === key) return; // Nothing changed
            container._lastKey = key;
            
            container.innerHTML = '';
            recent.forEach((item, i) => {
                const div = document.createElement('div');
                let icon = 'üé≤';
                let itemClass = '';
                if (item.includes('riceve') && item.includes('danni')) { icon = 'üí•'; itemClass = 'damage'; }
                else if (item.includes('si cura') || item.includes('recupera')) { icon = 'üíö'; itemClass = 'heal'; }
                else if (item.includes('Coppia') || item.includes('Tris') || item.includes('POKER')) { icon = '‚ú®'; itemClass = 'special'; }
                else if (item.includes('rianimato')) { icon = 'üîÑ'; itemClass = 'heal'; }
                else if (item.includes('scambiato')) { icon = 'üîÑ'; itemClass = 'special'; }
                else if (item.includes('Nuova partita') || item.includes('terminata')) { icon = 'üèÅ'; itemClass = 'special'; }
                else if (item.includes('Direzione')) { icon = '‚≠Æ'; itemClass = 'special'; }
                if (i === 0) itemClass += ' history-latest';
                div.className = 'history-item ' + itemClass;
                div.innerHTML = `<span class="icon">${icon}</span><span>${item}</span>`;
                container.appendChild(div);
            });
            container.scrollTop = 0;
        }

        function updateTurnDisplay() {
            const currentPlayer = gameState.players[gameState.currentTurn];
            if (currentPlayer) {
                document.getElementById('turn-player').textContent = currentPlayer.name;
                
                // Visual turn indicator - green pulsing border
                if (currentPlayer.name === gameState.playerName) {
                    document.body.classList.add('my-turn');
                } else {
                    document.body.classList.remove('my-turn');
                }
            }
        }

        function updateDirectionDisplay() {
            const arrow = gameState.direction === 'clockwise' ? '‚≠Æ' : '‚≠Ø';
            const text = gameState.direction === 'clockwise' ? 'Oraria' : 'Antioraria';
            document.getElementById('direction').innerHTML = `Direzione: ${arrow} ${text}`;
        }

        function renderDiceInputs() {
            const container = document.getElementById('dice-inputs');
            container.innerHTML = '';
            
            // Check if current player has custom dice count
            const currentPlayer = gameState.players[gameState.currentTurn];
            const diceCount = currentPlayer?.customDiceCount || gameState.diceCount;
            
            for (let i = 0; i < diceCount; i++) {
                const div = document.createElement('div');
                div.className = 'dice-input';
                div.innerHTML = `<input type="number" min="1" max="6" id="dice-${i}" placeholder="D${i + 1}">`;
                container.appendChild(div);
            }
            
            // Show indicator if using custom dice
            if (currentPlayer?.customDiceCount) {
                const indicator = document.createElement('div');
                indicator.style.cssText = 'color: #00ffff; font-size: 0.9em; margin-top: 10px; text-align: center;';
                indicator.textContent = `üé≤ Dadi personalizzati: ${currentPlayer.customDiceCount} (questo turno)`;
                container.appendChild(indicator);
            }
        }

        function updateMasterControls() {
            if (!gameState.isMaster) return;

            // ===== PERFORMANCE: Skip if players state hasn't changed =====
            const playerStateKey = gameState.players.map(p => 
                p.name + ':' + p.hp + ':' + (p.isEliminated?1:0) + ':' + JSON.stringify(p.temporaryEffects||{})
            ).join('|');
            if (updateMasterControls._lastKey === playerStateKey) return;
            updateMasterControls._lastKey = playerStateKey;

            // Update turn change selector
            const turnSelect = document.getElementById('next-turn-player');
            turnSelect.innerHTML = '';
            
            gameState.players.forEach((player, index) => {
                if (!player.isEliminated) {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name;
                    turnSelect.appendChild(option);
                }
            });

            // Update multi-select for HP modification
            const multiSelect = document.getElementById('target-players');
            multiSelect.innerHTML = '';
            
            gameState.players.forEach((player, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = player.name + (player.isEliminated ? ' (Eliminato)' : '');
                multiSelect.appendChild(option);
            });

            // Update damage activator select
            const damageActivatorSelect = document.getElementById('damage-activator-select');
            if (damageActivatorSelect) {
                damageActivatorSelect.innerHTML = '';
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.isEliminated ? ' (Eliminato)' : '');
                    damageActivatorSelect.appendChild(option);
                });
                // Seleziona il giocatore di turno per default
                damageActivatorSelect.value = gameState.currentTurn;
            }

            // Update swap HP selects
            const swapSelect1 = document.getElementById('swap-player-1');
            const swapSelect2 = document.getElementById('swap-player-2');
            
            if (swapSelect1 && swapSelect2) {
                swapSelect1.innerHTML = '';
                swapSelect2.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option1 = document.createElement('option');
                    option1.value = index;
                    option1.textContent = player.name;
                    swapSelect1.appendChild(option1);
                    
                    const option2 = document.createElement('option');
                    option2.value = index;
                    option2.textContent = player.name;
                    swapSelect2.appendChild(option2);
                });
            }
            
            // Update QR player select
            const qrSelect = document.getElementById('qr-player-select');
            if (qrSelect) {
                qrSelect.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name;
                    qrSelect.appendChild(option);
                });
            }
            
            // Update immortality select
            const immortalSelect = document.getElementById('immortal-players');
            if (immortalSelect) {
                immortalSelect.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.isImmortal ? ' ‚≠ê' : '');
                    if (player.isImmortal) {
                        option.selected = true;
                    }
                    immortalSelect.appendChild(option);
                });
            }
            
            // Update multiplier select
            const multiplierSelect = document.getElementById('multiplier-players');
            if (multiplierSelect) {
                multiplierSelect.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + ((player.multiplier > 1 || player.multiplier < 1) ? ' ‚ú®x' + player.multiplier : '');
                    multiplierSelect.appendChild(option);
                });
            }
            
            // Update skip turn select
            const skipTurnSelect = document.getElementById('skip-turn-players');
            if (skipTurnSelect) {
                skipTurnSelect.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.skipTurn ? ' ‚è≠Ô∏è' : '');
                    if (player.skipTurn) {
                        option.selected = true;
                    }
                    skipTurnSelect.appendChild(option);
                });
            }
            
            // Update custom dice select
            const customDiceSelect = document.getElementById('custom-dice-players');
            if (customDiceSelect) {
                customDiceSelect.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.customDiceCount ? ' üé≤√ó' + player.customDiceCount : '');
                    customDiceSelect.appendChild(option);
                });
            }
            
            // Update kraken mark select
            const krakenMarkSelect = document.getElementById('kraken-mark-players');
            if (krakenMarkSelect) {
                krakenMarkSelect.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.krakenMark ? ' üêô' : '');
                    if (player.krakenMark) {
                        option.selected = true;
                    }
                    krakenMarkSelect.appendChild(option);
                });
            }
            
            // Update checkmate select
            const checkmateSelect = document.getElementById('checkmate-players');
            if (checkmateSelect) {
                checkmateSelect.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.checkmateHP ? ' ‚ôüÔ∏è' + player.checkmateHP : '');
                    checkmateSelect.appendChild(option);
                });
            }
            
            // Update damage-to-heal select
            const damageToHealSelect = document.getElementById('damage-to-heal-players');
            if (damageToHealSelect) {
                damageToHealSelect.innerHTML = '';
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.damageToHeal ? ' üí´' : '');
                    if (player.damageToHeal) option.selected = true;
                    damageToHealSelect.appendChild(option);
                });
            }
            
            // Update sun armor select
            const sunArmorSelect = document.getElementById('sun-armor-players');
            if (sunArmorSelect) {
                sunArmorSelect.innerHTML = '';
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.sunArmor ? ' ‚òÄÔ∏è' : '');
                    if (player.sunArmor) option.selected = true;
                    sunArmorSelect.appendChild(option);
                });
            }
            
            // Update moon armor select
            const moonArmorSelect = document.getElementById('moon-armor-players');
            if (moonArmorSelect) {
                moonArmorSelect.innerHTML = '';
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.moonArmor ? ' üåô' : '');
                    if (player.moonArmor) option.selected = true;
                    moonArmorSelect.appendChild(option);
                });
            }
            
            // Update nuove meccaniche selects
            const nuoviSelectMultipli = [
                { id: 'mare-guai-players', prop: 'mareGuai', emoji: 'üåä' },
                { id: 'volo-fenice-players', prop: 'voloFenice', emoji: 'ü¶Ö' },
                { id: 'cactus-amari-players', prop: 'cactusAmari', emoji: 'üåµ' },
                { id: 'catena-maledetta-players', prop: 'catenaMaledetta', emoji: '‚õìÔ∏è' },
                { id: 'rifletti-danni-players', prop: 'rifletteDanni', emoji: 'ü™û' },
                { id: 'elmo-maledetto-players', prop: 'elmoMaledetto', emoji: '‚õëÔ∏è' },
                { id: 'mano-freya-players', prop: 'manoFreya', emoji: 'üåø' },
                { id: 'armatura-cavaliere-players', prop: 'armaturaCavaliere', emoji: 'üõ°Ô∏è' },
                { id: 'dado-avvelenato-player', prop: 'dadoAvvelenato', emoji: '‚ò†Ô∏è' },
                { id: 'protettore-fato-players', prop: 'protettoreFato', emoji: 'üõ°Ô∏è‚ú®' }
            ];
            
            nuoviSelectMultipli.forEach(({ id, prop, emoji }) => {
                const select = document.getElementById(id);
                if (select) {
                    select.innerHTML = '';
                    gameState.players.forEach((player, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = player.name + (player[prop] ? ` ${emoji}` : '');
                        if (player[prop]) option.selected = true;
                        select.appendChild(option);
                    });
                }
            });
            
            // Swap HP (fato version) selects
            ['swap-player-1-fato', 'swap-player-2-fato'].forEach(id => {
                const sel = document.getElementById(id);
                if (sel) {
                    const prev = sel.value;
                    sel.innerHTML = '';
                    gameState.players.forEach((p, i) => {
                        const opt = document.createElement('option');
                        opt.value = i; opt.textContent = p.name + (p.isEliminated ? ' ‚ò†Ô∏è' : '');
                        sel.appendChild(opt);
                    });
                    sel.value = prev;
                }
            });
            
            nuoviSelectMultipli.forEach(({ id, prop, emoji }) => {
                const select = document.getElementById(id);
                if (select) {
                    select.innerHTML = '';
                    gameState.players.forEach((player, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = player.name + (player[prop] ? ` ${emoji}` : '');
                        if (player[prop]) option.selected = true;
                        select.appendChild(option);
                    });
                }
            });
            

        // Update geyser-activator select
        const geyserActivator = document.getElementById('geyser-activator');
        if (geyserActivator) {
            const geyserVal = geyserActivator.value;
            geyserActivator.innerHTML = '<option value="">Seleziona Attivatore</option>';
            gameState.players.forEach((p, i) => {
                if (!p.isEliminated) geyserActivator.innerHTML += '<option value="' + i + '">' + p.name + '</option>';
            });
            geyserActivator.value = geyserVal;
        }
        
        // Update extra-turns-player select
        const extraTurnsSelect = document.getElementById('extra-turns-player');
        if (extraTurnsSelect) {
            extraTurnsSelect.innerHTML = '';
            gameState.players.forEach((player, index) => {
                if (!player.isEliminated) {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.extraTurns > 0 ? ' üîÑ+' + player.extraTurns : '');
                    extraTurnsSelect.appendChild(option);
                }
            });
        }
        
        // Update master-note-player select
        const masterNoteSelect = document.getElementById('master-note-player');
        if (masterNoteSelect) {
            masterNoteSelect.innerHTML = '';
            gameState.players.forEach((player, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = player.name + (player.masterNote ? ' üìù' : '');
                masterNoteSelect.appendChild(option);
            });
        }

            // Update select singoli
            const selectSingoli = ['talismano-ra-player', 'interferenza-player1', 
                                   'interferenza-player2', 'alta-marea-player', 'zebratura-player', 
                                   'boomerang-player', 'armatura-specchio-player', 'sabbie-mobili-player', 'sette-bello-player',
                                   'tiro-caricato-player'];
            
            selectSingoli.forEach(selectId => {
                const select = document.getElementById(selectId);
                if (select) {
                    select.innerHTML = '';
                    gameState.players.forEach((player, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = player.name;
                        select.appendChild(option);
                    });
                }
            });
            
            // Update carte resurrezione
            const selectResurrezione = [
                { id: 'canto-cigno-players', prop: 'cantoDelCigno', emoji: 'ü¶¢' },
                { id: 'patto-diavolo-players', prop: 'pattoDiavolo', emoji: 'üòà' },
                { id: 'tomba-tutankhamon-players', prop: 'tombaTutankhamon', emoji: 'üè∫' },
                { id: 'reincarnazione-players', prop: 'reincarnazione', emoji: '‚ôªÔ∏è' },
                { id: 'boia-esecutore-players', prop: 'boiaEsecutore', emoji: 'ü™ì' }
            ];
            
            selectResurrezione.forEach(({ id, prop, emoji }) => {
                const select = document.getElementById(id);
                if (select) {
                    select.innerHTML = '';
                    gameState.players.forEach((player, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = player.name + (player[prop] ? ` ${emoji}` : '');
                        select.appendChild(option);
                    });
                }
            });
            
            // Update select attivatori effetti globali
            const activatorSelects = [
                'cessate-fuoco-activator',
                'pari-pazzo-activator',
                'bambola-voodoo-activator',
                'cannone-karma-activator',
                'pioggia-acida-activator',
                'capsula-rigenerativa-activator',
                'saldi-estivi-activator',
                'gioco-pulito-activator',
                'domino-activator',
                'contagio-activator',
                'tre-molio-activator',
                'nirvana-activator',
                'tocca-a-me-activator',
                'tocca-a-me-target',
                'minotauro-corrotto-activator',
                'troll-face-activator',
                'distorsione-activator'
            ];
            
            activatorSelects.forEach(selectId => {
                const select = document.getElementById(selectId);
                if (select) {
                    select.innerHTML = '<option value="">Seleziona Attivatore</option>';
                    gameState.players.forEach((player, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = player.name;
                        select.appendChild(option);
                    });
                }
            });

            // Update target-calc-attivatore (master strumenti calcolo)
            const calcAttivatoreSelect = document.getElementById('target-calc-attivatore');
            if (calcAttivatoreSelect) {
                const prev = calcAttivatoreSelect.value;
                calcAttivatoreSelect.innerHTML = '';
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.isEliminated ? ' (Eliminato)' : '');
                    calcAttivatoreSelect.appendChild(option);
                });
                // Default to current turn player
                calcAttivatoreSelect.value = prev || String(gameState.currentTurn);
            }

            // Update player-tcalc-attivatore (player strumenti calcolo)
            const playerCalcAttivatore = document.getElementById('player-tcalc-attivatore');
            if (playerCalcAttivatore) {
                const prev2 = playerCalcAttivatore.value;
                playerCalcAttivatore.innerHTML = '';
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.isEliminated ? ' (Eliminato)' : '');
                    playerCalcAttivatore.appendChild(option);
                });
                if (!prev2) {
                    // Default to self
                    const selfIdx = gameState.players.findIndex(p => p.name === gameState.playerName);
                    if (selfIdx >= 0) playerCalcAttivatore.value = String(selfIdx);
                    else playerCalcAttivatore.value = String(gameState.currentTurn);
                } else {
                    playerCalcAttivatore.value = prev2;
                }
            }
        }

        // === HELPER: Try to eliminate player with resurrection check ===
        function tryEliminatePlayer(player, eliminationReason, playEliminationSound = true, contagioSourceDamage = 0) {
            if (player.isEliminated) return false; // Already eliminated
            
            // PROTETTORE DEL FATO - protegge da TUTTE le eliminazioni (anche dirette)
            if (player.protettoreFato) {
                gameState.history.push(`üõ°Ô∏è‚ú® [Protettore del Fato] ${player.name} √® protetto dall'eliminazione! ${eliminationReason}`);
                playSound('heal');
                if (player.name === gameState.playerName) {
                    screenFlash('heal');
                }
                return false; // Not eliminated - protected
            }
            
            const wasAlive = player.hp > 0;
            player.hp = 0;
            
            // Reset ALL effects before checking resurrection
            player.isImmortal = false;
            player.multiplier = 1;
            player.multiplierAppliedBy = null;
            player.skipTurn = false;
            player.customDiceCount = null;
            player.krakenMark = false;
            player.checkmateHP = null;
            player.damageToHeal = false;
            player.sunArmor = false;
            player.moonArmor = false;
            player.mareGuai = false;
            player.voloFenice = false;
            player.cactusAmari = false;
            player.catenaMaledetta = false;
            player.rifletteDanni = false;
            player.elmoMaledetto = false;
            player.manoFreya = false;
            player.armaturaCavaliere = false;
            player.talismanRa = false;
            player.talismanRaValues = [];
            player.dadoAvvelenato = false;
            player.dadoAvvelenatotValues = [];
            player.interferenza = false;
            player.interferenzaPartner = null;
            player.protettoreFato = false;
            player.tiroCaricato = false;
            player.tiroCaricatoMultiplier = null;
            player.temporaryEffects = {
                immortal: false, multiplier: false, skipTurn: false, customDice: false,
                damageToHeal: false, sunArmor: false, moonArmor: false,
                mareGuai: false, voloFenice: false, cactusAmari: false,
                catenaMaledetta: false, rifletteDanni: false,
                elmoMaledetto: false,
                manoFreya: false,
                armaturaCavaliere: false,
                talismanRa: false, dadoAvvelenato: false, protettoreFato: false
            };
            
            // === Check RESURRECTION (in priority order) ===
            let resurrected = false;
            
            // 1. CANTO DEL CIGNO
            if (player.cantoDelCigno) {
                player.hp = 1;
                player.isEliminated = false;
                player.cantoDelCigno = false;
                gameState.history.push(`ü¶¢ [Canto del Cigno] ${player.name} torna in vita con 1 HP! üÉè Pesca 2 carte del Fato. ${eliminationReason}`);
                playSound('revive');
                if (player.name === gameState.playerName) {
                    screenFlash('revive');
                }
                resurrected = true;
            }
            // 2. PATTO CON IL DIAVOLO
            else if (player.pattoDiavolo && !player.pattoDiavoloUsed) {
                player.hp = 20;
                player.isEliminated = false;
                player.customDiceCount = 2; // Only 2 dice forever
                player.pattoDiavolo = false;
                player.pattoDiavoloUsed = true;
                gameState.history.push(`üòà [Patto col Diavolo] ${player.name} torna con 20 HP, ma user√† solo 2 dadi per sempre. ${eliminationReason}`);
                playSound('revive');
                if (player.name === gameState.playerName) {
                    screenFlash('revive');
                }
                resurrected = true;
            }
            // 3. TOMBA DI TUTANKHAMON
            else if (player.tombaTutankhamon) {
                player.hp = Math.ceil(gameState.initialHP / 2);
                player.isEliminated = false;
                player.skipTurn = true;
                player.tombaTutankhamon = false;
                gameState.history.push(`üè∫ [Tomba Tutankhamon] ${player.name} torna con ${player.hp} HP, ma salter√† il prossimo turno. ${eliminationReason}`);
                playSound('revive');
                if (player.name === gameState.playerName) {
                    screenFlash('revive');
                }
                resurrected = true;
            }
            // 4. REINCARNAZIONE
            else if (player.reincarnazione && !player.reincarnazioneUsed) {
                player.hp = gameState.initialHP;
                player.isEliminated = false;
                player.multiplier = 2; // Permanent x2 damage taken
                player.reincarnazioneMultiplier = true; // Permanent - not cleared by resetTemporaryEffects
                player.reincarnazione = false;
                player.reincarnazioneUsed = true;
                gameState.history.push(`‚ôªÔ∏è [Reincarnazione] ${player.name} torna con ${player.hp} HP, ma subir√† danni √ó2 per sempre! ${eliminationReason}`);
                playSound('revive');
                if (player.name === gameState.playerName) {
                    screenFlash('revive');
                }
                resurrected = true;
            }
            
            // No resurrection - permanently eliminated
            if (!resurrected) {
                player.isEliminated = true;
                gameState.history.push(`üíÄ ${player.name} √® stato eliminato! ${eliminationReason}`);
                
                // ===== CONTAGIO: scatta su QUALSIASI eliminazione definitiva (escluso attivatore) =====
                const gfxC = gameState.globalEffects;
                const elimIdx = gameState.players.indexOf(player);
                if (gfxC.contagio && elimIdx !== gfxC.contagioActivator) {
                    const contagioDamage = contagioSourceDamage;
                    let contagioAffected = [];
                    gameState.players.forEach((p, idx) => {
                        if (!p.isEliminated && idx !== gfxC.contagioActivator && idx !== elimIdx) {
                            if (p.protettoreFato) { contagioAffected.push(p.name + '(immune)'); return; }
                            if (p.isImmortal) { contagioAffected.push(p.name + '(immortale)'); return; }
                            if (p.manoFreya) { p.hp += contagioDamage; contagioAffected.push(p.name + '(curaüåø)'); return; }
                            if (p.voloFenice) { p.hp += contagioDamage * 2; contagioAffected.push(p.name + '(curaü¶Ö)'); return; }
                            if (p.damageToHeal) { p.hp += contagioDamage; contagioAffected.push(p.name + '(curaüí´)'); return; }
                            let dmg = contagioDamage;
                            if (p.armaturaCavaliere) dmg = Math.floor(dmg / 2);
                            if (p.elmoMaledetto && dmg > 0) {
                                player.hp = Math.max(0, player.hp - dmg);
                                gameState.history.push(`‚õëÔ∏è [Elmo] ${dmg} riflessi a ${player.name} dal contagio su ${p.name}`);
                            }
                            if (p.cactusAmari && dmg > 0) {
                                player.hp = Math.max(0, player.hp - dmg * 2);
                                gameState.history.push(`üåµ [Cactus] ${dmg * 2} riflessi a ${player.name} dal contagio su ${p.name}`);
                            }
                            if (dmg > 0) {
                                p.hp = Math.max(0, p.hp - dmg);
                                contagioAffected.push(p.name);
                                if (p.hp === 0 && !p.isEliminated) {
                                    tryEliminatePlayer(p, `(Contagio da ${player.name})`, false);
                                }
                            } else {
                                contagioAffected.push(p.name + '(0dmg)');
                            }
                        }
                    });
                    gameState.history.push(`ü¶† [Contagio] ${player.name} eliminato! ${contagioDamage > 0 ? contagioDamage + ' danni propagati a: ' + contagioAffected.join(', ') : 'Nessun danno da propagare'}`);
                    gfxC.contagio = false;
                    gfxC.contagioActivator = null;
                    gameState.history.push('ü¶† [Contagio] Effetto esaurito.');
                }
                
                if (playEliminationSound) {
                    playSound('elimination');
                }
                
                if (player.name === gameState.playerName && !gameState.isMaster) {
                    setTimeout(() => showEliminatedNotification(), 500);
                }
                
                // DISTORSIONE SPAZIO-TEMPORALE: se l'attivatore viene eliminato, la partita finisce subito
                const gfxD = gameState.globalEffects;
                if (gfxD.distorsione && gfxD.distorsioneActivator === elimIdx && gameState.isMaster) {
                    gameState.history.push(`‚è≥üåÄ [Distorsione] ${player.name} eliminato! La partita termina immediatamente!`);
                    gfxD.distorsione = false; gfxD.distorsioneActivator = null; gfxD.distorsioneTurnsLeft = 0;
                    const winner = determineWinner();
                    if (winner) {
                        setTimeout(() => {
                            database.ref('games/' + gameState.gameCode).update({
                                players: gameState.players, globalEffects: gfxD,
                                history: gameState.history, gameEnded: true, winner: winner.name
                            });
                            showWinnerNotification(winner.name, winner.name === gameState.playerName);
                        }, 800);
                    }
                }
            }
            
            return !resurrected; // Return true if actually eliminated (no resurrection)
        }

        function calculateDice() {
            const currentPlayerIndex = gameState.currentTurn;
            const currentPlayer = gameState.players[currentPlayerIndex];
            const gfx = gameState.globalEffects;

            if (!gameState.isMaster && currentPlayer.name !== gameState.playerName) {
                alert('Non √® il tuo turno!');
                return;
            }

            if (currentPlayer.isEliminated) {
                alert('Il giocatore corrente √® eliminato!');
                return;
            }
            
            if (currentPlayer.skipTurn) {
                alert('Questo giocatore deve saltare il turno!');
                return;
            }

            // ===== BOOMERANG PAYOUT: prima che l'attivatore inserisca i dadi =====
            if (gfx.boomerang && gfx.boomerangActivator === currentPlayerIndex && gfx.boomerangDamage > 0) {
                const boomerangTotal = gfx.boomerangDamage;
                let affectedNames = [];
                gameState.players.forEach((p, idx) => {
                    if (idx !== currentPlayerIndex && !p.isEliminated) {
                        let dmg = boomerangTotal;
                        // Rispetta immunit√†
                        if (p.protettoreFato) { affectedNames.push(p.name + '(immune)'); return; }
                        if (p.isImmortal) { affectedNames.push(p.name + '(immune)'); return; }
                        if (p.manoFreya) { p.hp += dmg; affectedNames.push(p.name + '(cura Freya)'); return; }
                        if (p.voloFenice) { p.hp += dmg * 2; affectedNames.push(p.name + '(cura Fenice)'); return; }
                        if (p.damageToHeal) { p.hp += dmg; affectedNames.push(p.name + '(cura D‚ÜíC)'); return; }
                        // Armatura Cavaliere - dimezza
                        if (p.armaturaCavaliere) dmg = Math.floor(dmg / 2);
                        // Elmo Maledetto - riflette anche all'attivatore
                        if (p.elmoMaledetto) {
                            currentPlayer.hp = Math.max(0, currentPlayer.hp - dmg);
                            gameState.history.push(`‚õëÔ∏è [Elmo] ${currentPlayer.name} riceve ${dmg} riflessi da ${p.name}`);
                        }
                        // Specchio Maledetto - riflette il boomerang all'attivatore (uso singolo)
                        if (p.rifletteDanni) {
                            currentPlayer.hp = Math.max(0, currentPlayer.hp - dmg);
                            p.rifletteDanni = false;
                            if (p.temporaryEffects) p.temporaryEffects.rifletteDanni = false;
                            affectedNames.push(p.name + '(riflette‚Üíattivatore)');
                            return;
                        }
                        p.hp = Math.max(0, p.hp - dmg);
                        affectedNames.push(p.name);
                        if (p.hp === 0 && !p.isEliminated) {
                            tryEliminatePlayer(p, `(Boomerang)`, false, boomerangTotal);
                        }
                    }
                });
                gameState.history.push(`ü™É [Boomerang] ${currentPlayer.name} scatena ${boomerangTotal} danni accumulati su: ${affectedNames.join(', ')}`);
                gfx.boomerang = false;
                gfx.boomerangActivator = null;
                gfx.boomerangDamage = 0;
                // Sincronizza subito a Firebase e continua col turno normale
                database.ref('games/' + gameState.gameCode).update({
                    players: gameState.players,
                    globalEffects: gfx,
                    history: gameState.history
                });
                forceUIUpdate();
            }

            const diceValues = [];
            const diceCount = currentPlayer.customDiceCount || gameState.diceCount;
            
            for (let i = 0; i < diceCount; i++) {
                const value = parseInt(document.getElementById(`dice-${i}`).value);
                if (!value || value < 1 || value > 6) {
                    alert('Inserisci valori validi per tutti i dadi (1-6)!');
                    return;
                }
                diceValues.push(value);
            }

            const result = processDiceRoll(diceValues, currentPlayerIndex);
            displayResult(result);
            applyResult(result);
        }

        function processDiceRoll(dice, shooterIndex) {
            const gfx = gameState.globalEffects;
            
            // TROLL FACE: il valore scelto diventa 0 per tutti tranne l'attivatore
            if (gfx.trollFace && shooterIndex !== gfx.trollFaceActivator) {
                const targetValue = gfx.trollFaceValue;
                dice = dice.map(d => d === targetValue ? 0 : d);
            }
            
            const sum = dice.reduce((a, b) => a + b, 0);
            const counts = {};
            dice.forEach(d => counts[d] = (counts[d] || 0) + 1);
            
            const maxCount = Math.max(...Object.values(counts));
            const pairValue = maxCount >= 2 ? parseInt(Object.keys(counts).find(k => counts[k] === maxCount)) : null;

            let damage = sum;
            let specialEffect = null;
            let selfHeal = 0;
            let cardsDrawn = 0;
            let isPoker = false;

            // POKER - 4 dadi uguali = VITTORIA ISTANTANEA
            if (maxCount === 4) {
                isPoker = true;
                specialEffect = 'POKER - VITTORIA!';
                damage = 0; // No damage, instant win
            } else if (maxCount === 3) {
                // Tris: (valore √ó valore) + valore del terzo dado
                const trisDice = dice.filter(d => d === pairValue);
                damage = (pairValue * pairValue) + trisDice[2];
                selfHeal = damage;
                cardsDrawn = 2;
                specialEffect = 'Tris';
            } else if (maxCount === 2) {
                // Coppia: (valore √ó valore) + altro dado
                const otherDice = dice.find(d => d !== pairValue);
                damage = (pairValue * pairValue) + (otherDice || 0);
                cardsDrawn = 1;
                specialEffect = 'Coppia';
            }

            const targetIndex = !isPoker ? findTarget(sum, shooterIndex) : -1;

            return {
                dice,
                sum,
                damage,
                specialEffect,
                selfHeal,
                cardsDrawn,
                shooterIndex,
                targetIndex,
                isPoker
            };
        }

        function findTarget(sum, shooterIndex) {
            const activePlayers = gameState.players
                .map((p, i) => ({ player: p, index: i }))
                .filter(({ player, index }) => !player.isEliminated && index !== shooterIndex);

            if (activePlayers.length === 0) return -1;

            let count = sum % activePlayers.length;
            if (count === 0) count = activePlayers.length;

            if (gameState.direction === 'clockwise') {
                // Senso orario: ordina per index crescente, partendo da dopo lo shooter
                const sorted = [...activePlayers].sort((a, b) => {
                    // Metti prima quelli dopo lo shooter, poi quelli prima
                    const aAfter = a.index > shooterIndex ? a.index : a.index + 1000;
                    const bAfter = b.index > shooterIndex ? b.index : b.index + 1000;
                    return aAfter - bAfter;
                });
                
                const targetPos = (count - 1) % sorted.length;
                return sorted[targetPos].index;
            } else {
                // Senso antiorario: ordina per index decrescente, partendo da prima dello shooter
                const sorted = [...activePlayers].sort((a, b) => {
                    // Metti prima quelli prima dello shooter, poi quelli dopo (ma in ordine inverso)
                    const aValue = a.index < shooterIndex ? (shooterIndex - a.index) : (shooterIndex + gameState.players.length - a.index);
                    const bValue = b.index < shooterIndex ? (shooterIndex - b.index) : (shooterIndex + gameState.players.length - b.index);
                    return aValue - bValue;
                });
                
                const targetPos = (count - 1) % sorted.length;
                return sorted[targetPos].index;
            }
        }

        function displayResult(result) {
            const display = document.getElementById('result-display');
            const text = document.getElementById('result-text');
            
            const shooter = gameState.players[result.shooterIndex];
            const target = result.targetIndex >= 0 ? gameState.players[result.targetIndex] : null;

            let message = `üé≤ Dadi: ${result.dice.join(', ')}<br>`;
            
            if (result.isPoker) {
                message += `<br>üèÜüèÜüèÜ POKER! üèÜüèÜüèÜ<br>`;
                message += `<strong style="font-size: 1.5em; color: #ffd700;">VITTORIA ISTANTANEA!</strong><br>`;
                message += `${shooter.name} vince la partita!<br>`;
            } else {
                message += `üìä Somma: ${result.sum}<br>`;
                
                if (result.specialEffect) {
                    message += `‚ú® ${result.specialEffect}!<br>`;
                }
                
                if (target) {
                    message += `üéØ Bersaglio: ${target.name}<br>`;
                    message += `üí• Danno: ${result.damage}<br>`;
                }
                
                if (result.selfHeal > 0) {
                    message += `üíö Cura: ${result.selfHeal} HP<br>`;
                }
                
                if (result.cardsDrawn > 0) {
                    message += `üÉè Pesca ${result.cardsDrawn} carta/e del fato<br>`;
                }
            }

            text.innerHTML = message;
            display.classList.remove('hidden');
        }

        function applyResult(result) {
            // Save current state for rollback (Master only)
            if (gameState.isMaster) {
                gameState.previousState = {
                    players: JSON.parse(JSON.stringify(gameState.players)),
                    currentTurn: gameState.currentTurn,
                    history: [...gameState.history],
                    stats: JSON.parse(JSON.stringify(gameState.stats)),
                    globalEffects: JSON.parse(JSON.stringify(gameState.globalEffects)),
                    direction: gameState.direction
                };
            }
            
            const shooter = gameState.players[result.shooterIndex];
            
            // Initialize stats for shooter if not exists
            if (!gameState.stats[shooter.name]) {
                gameState.stats[shooter.name] = {
                    damageDealt: 0,
                    damageTaken: 0,
                    healingDone: 0,
                    specialMoves: 0,
                    turns: 0
                };
            }
            
            gameState.stats[shooter.name].turns++;
            
            // POKER = INSTANT WIN
            if (result.isPoker) {
                gameState.stats[shooter.name].specialMoves++;
                gameState.history.push(`üèÜ ${shooter.name} ha ottenuto POKER (${result.dice.join(',')}) e VINCE LA PARTITA!`);
                
                database.ref('games/' + gameState.gameCode).update({
                    history: gameState.history,
                    gameEnded: true,
                    winner: shooter.name,
                    stats: gameState.stats
                });
                
                playSound('poker');
                
                setTimeout(() => {
                    const isYou = shooter.name === gameState.playerName;
                    showWinnerNotification(shooter.name, isYou);
                }, 1000);
                
                return;
            }
            
            const target = result.targetIndex >= 0 ? gameState.players[result.targetIndex] : null;
            
            // ===== APPLICAZIONE EFFETTI GLOBALI =====
            const gfx = gameState.globalEffects;
            
            // CESSATE IL FUOCO - tutti curano invece di danneggiare
            if (gfx.cessateFuoco && result.shooterIndex !== gfx.cessateFuocoActivator && result.damage > 0) {
                result.damage = -Math.abs(result.damage); // Converti in cura
                // Attivatore si cura della met√† del danno generato
                const activator = gameState.players[gfx.cessateFuocoActivator];
                if (activator && !activator.isEliminated) {
                    const heal = Math.floor(Math.abs(result.damage) / 2);
                    activator.hp += heal;
                    gameState.history.push(`üïäÔ∏è [Cessate Fuoco] ${activator.name} si auto-cura +${heal} HP`);
                }
            }
            
            // BAMBOLA VOODOO - il tiratore fa danni a s√© stesso (ignorando il bersaglio normale)
            // L'attivatore √® immune. Rispetta immortalit√†, damageToHeal, protettoreFato, voloFenice.
            if (gfx.bambolaVoodoo && result.shooterIndex !== gfx.bambolaVoodooActivator && result.damage > 0) {
                const voodooShooter = gameState.players[result.shooterIndex];
                const voodooShooterName = voodooShooter.name;
                const rawDmg = result.damage;

                let voodooMsg = `ü™Ü [Bambola Voodoo] ${voodooShooterName} colpisce s√© stesso con ${rawDmg} danni`;

                if (voodooShooter.protettoreFato) {
                    voodooMsg += ' ‚Üí Bloccato (Protettore del Fato)';
                } else if (voodooShooter.isImmortal) {
                    voodooMsg += ' ‚Üí Bloccato (Immortale)';
                } else if (voodooShooter.damageToHeal) {
                    voodooShooter.hp = Math.min(gameState.initialHP, voodooShooter.hp + rawDmg);
                    voodooMsg += ` ‚Üí Convertito in cura +${rawDmg} HP (Conversione D‚ÜíC)`;
                } else if (voodooShooter.voloFenice) {
                    voodooShooter.hp = Math.min(gameState.initialHP, voodooShooter.hp + rawDmg * 2);
                    voodooMsg += ` ‚Üí Convertito in cura +${rawDmg * 2} HP (Volo della Fenice)`;
                } else {
                    const actualVoodooDmg = Math.ceil(rawDmg * (voodooShooter.multiplier || 1));
                    voodooShooter.hp = Math.max(0, voodooShooter.hp - actualVoodooDmg);
                    voodooMsg += actualVoodooDmg !== rawDmg ? ` (√ó${voodooShooter.multiplier} = ${actualVoodooDmg})` : '';
                    if (voodooShooter.hp === 0 && !voodooShooter.isEliminated) {
                        tryEliminatePlayer(voodooShooter, `(Bambola Voodoo)`);
                    }
                }

                gameState.history.push(voodooMsg);
                // Redirect result so normal damage-apply section is skipped for this turn
                result.damage = 0;
                result.targetIndex = -1;
            }
            
            // CAPSULA RIGENERATIVA - tutti curano se stessi invece di danneggiare
            if (gfx.capsulaRigenerativa && target && result.damage > 0) {
                const originalTarget = target.name;
                result.targetIndex = result.shooterIndex; // Cambia target a s√© stesso
                // Converti danno in cura
                result.damage = -Math.abs(result.damage);
                const newTarget = gameState.players[result.targetIndex];
                gameState.history.push(`üíä [Capsula Rigenerativa] ${shooter.name} si cura invece di colpire ${originalTarget}!`);
                // La variabile target verr√† riassegnata nella sezione "Apply damage"
            }
            
            // SALDI ESTIVI - solo i danni vengono dimezzati (le cure rimangono invariate)
            let alreadyHalvedDamage = false; // Flag per tracciare dimezzamento
            if (gfx.saldiEstivi && result.damage > 0) {
                const originalDamage = result.damage;
                result.damage = Math.floor(result.damage / 2);
                alreadyHalvedDamage = true;
                gameState.history.push(`üèñÔ∏è [Saldi Estivi] Danni dimezzati: ${originalDamage} ‚Üí ${result.damage}`);
            }
            
            // GIOCO PULITO - annulla coppie e tris + resetta TUTTI gli effetti dei giocatori (tranne Protettore del Fato)
            if (gfx.giocoPulito) {
                if (result.specialEffect === 'Coppia' || result.specialEffect === 'Tris') {
                    result.specialEffect = null;
                    result.selfHeal = 0;
                    result.cardsDrawn = 0;
                    const newDamage = result.sum;
                    gameState.history.push(`‚öñÔ∏è [Gioco Pulito] Effetto speciale annullato, danno base: ${newDamage}`);
                    result.damage = newDamage;
                }
                // Rimuovi TUTTI gli effetti individuali da tutti i giocatori (escluso protettoreFato)
                gameState.players.forEach(p => {
                    if (p.isEliminated) return;
                    p.isImmortal = false;
                    p.multiplier = 1; p.multiplierAppliedBy = null;
                    p.skipTurn = false;
                    p.customDiceCount = null;
                    p.krakenMark = false;
                    p.checkmateHP = null;
                    p.damageToHeal = false;
                    p.sunArmor = false;
                    p.moonArmor = false;
                    p.voloFenice = false;
                    p.cactusAmari = false;
                    p.catenaMaledetta = false;
                    p.rifletteDanni = false;
                    p.elmoMaledetto = false; p.manoFreya = false; p.armaturaCavaliere = false;
                    p.talismanRa = false; p.talismanRaValues = [];
                    p.dadoAvvelenato = false; p.dadoAvvelenatotValues = [];
                    p.interferenza = false; p.interferenzaPartner = null;
                    p.tiroCaricato = false; p.tiroCaricatoMultiplier = null;
                    // Resurrection effects CAN be removed by gioco pulito
                    p.cantoDelCigno = false;
                    p.pattoDiavolo = false; p.pattoDiavoloUsed = false;
                    p.tombaTutankhamon = false;
                    p.reincarnazione = false; p.reincarnazioneUsed = false;
                    p.boiaEsecutore = false; p.boiaEsecutoreTurns = 0;
                    if (p.temporaryEffects) {
                        Object.keys(p.temporaryEffects).forEach(k => { p.temporaryEffects[k] = false; });
                    }
                    // protettoreFato: NEVER cleared by gioco pulito
                });
                gameState.history.push(`‚öñÔ∏è [Gioco Pulito] Tutti gli effetti individuali dei giocatori rimossi!`);
            }
            
            // ZEBRATURA - somme pari curano, dispari danneggiano
            if (gfx.zebratura && result.damage > 0) {
                if (result.sum % 2 === 0) {
                    result.damage = -Math.abs(result.damage); // Pari = cura
                    gameState.history.push(`ü¶ì [Zebratura] Somma pari (${result.sum}) ‚Üí conversione in cura`);
                } else {
                    gameState.history.push(`ü¶ì [Zebratura] Somma dispari (${result.sum}) ‚Üí mantiene danno`);
                }
            }
            
            // ALTA MAREA - modifica danni in base agli HP
            if (gfx.altaMarea && target && result.damage > 0) {
                const halfInitialHP = Math.ceil(gameState.initialHP / 2); // Arrotonda per ECCESSO
                const originalDamage = result.damage;
                if (target.hp > halfInitialHP) {
                    // HP alti: raddoppia (se Saldi attivo: √ó2 poi √∑2 = normale)
                    result.damage = Math.floor(result.damage * 2);
                    gameState.history.push(`üåä [Alta Marea] ${target.name} (${target.hp}>${halfInitialHP}) ‚Üí danni x2: ${originalDamage} ‚Üí ${result.damage}`);
                } else if (target.hp <= halfInitialHP && !alreadyHalvedDamage) {
                    // HP bassi: dimezza SOLO se non gi√† dimezzato da Saldi
                    result.damage = Math.floor(result.damage / 2);
                    gameState.history.push(`üåä [Alta Marea] ${target.name} (${target.hp}‚â§${halfInitialHP}) ‚Üí danni /2: ${originalDamage} ‚Üí ${result.damage}`);
                } else if (target.hp <= halfInitialHP && alreadyHalvedDamage) {
                    // Gi√† dimezzato: non dimezzare di nuovo
                    gameState.history.push(`üåä [Alta Marea] ${target.name} (${target.hp}‚â§${halfInitialHP}) ‚Üí gi√† dimezzato (Saldi Estivi)`);
                }
            }
            
            // PARI PAZZO - somme pari subiscono danno pari alla giocata
            if (gfx.pariPazzo && result.sum % 2 === 0 && result.damage > 0) {
                if (shooter.protettoreFato) {
                    gameState.history.push(`üé≤ [Pari Pazzo] ${shooter.name} ha somma pari (${result.sum}) ‚Üí Bloccato (Protettore del Fato)`);
                } else if (shooter.isImmortal) {
                    gameState.history.push(`üé≤ [Pari Pazzo] ${shooter.name} ha somma pari (${result.sum}) ‚Üí Bloccato (Immortale)`);
                } else {
                    shooter.hp = Math.max(0, shooter.hp - result.damage);
                    if (!gameState.stats[shooter.name]) {
                        gameState.stats[shooter.name] = { damageDealt: 0, damageTaken: 0, healingDone: 0, specialMoves: 0, turns: 0 };
                    }
                    gameState.stats[shooter.name].damageTaken += result.damage;
                    gameState.history.push(`üé≤ [Pari Pazzo] ${shooter.name} ha ottenuto somma pari (${result.sum}) ‚Üí subisce ${result.damage} danni auto-inflitti`);
                    if (shooter.hp === 0 && !shooter.isEliminated) {
                        tryEliminatePlayer(shooter, `(Pari Pazzo auto-danno)`);
                    }
                }
            }
            
            // PIOGGIA ACIDA - tutti subiscono danno = dado pi√π alto (escluso attivatore)
            // Rispetta immortalit√†, damageToHeal, protettoreFato, voloFenice
            if (gfx.pioggiaAcida && result.shooterIndex !== gfx.pioggiaAcidaActivator) {
                const maxDice = Math.max(...result.dice);
                let affectedNames = [], immuneNames = [];
                gameState.players.forEach((p, idx) => {
                    if (p.isEliminated || idx === gfx.pioggiaAcidaActivator) return;
                    if (p.protettoreFato) { immuneNames.push(p.name + '(Protetto)'); return; }
                    if (p.isImmortal) { immuneNames.push(p.name + '(Immortale)'); return; }
                    if (p.damageToHeal) {
                        p.hp = Math.min(gameState.initialHP, p.hp + maxDice);
                        affectedNames.push(p.name + '(+' + maxDice + ' cura)');
                    } else if (p.voloFenice) {
                        p.hp = Math.min(gameState.initialHP, p.hp + maxDice * 2);
                        affectedNames.push(p.name + '(+' + (maxDice * 2) + ' Fenice)');
                    } else {
                        const actualDmg = Math.ceil(maxDice * (p.multiplier || 1));
                        p.hp = Math.max(0, p.hp - actualDmg);
                        affectedNames.push(p.name + '(-' + actualDmg + ')');
                        if (p.hp === 0 && !p.isEliminated) {
                            tryEliminatePlayer(p, `(Pioggia Acida)`, false, highDie);
                        }
                    }
                });
                let msg = `‚òî [Pioggia Acida] Dado max: ${maxDice}. Colpiti: ${affectedNames.join(', ')}`;
                if (immuneNames.length) msg += `. Immuni: ${immuneNames.join(', ')}`;
                gameState.history.push(msg);
            }
            
            // 3 MOLIO - se c'√® almeno un 3 nei dadi, tutti (escluso attivatore) subiscono il totale
            if (gfx.treMolio && result.dice.includes(3)) {
                const totalDmg = result.sum;
                let affectedPlayers = [], immunePlayers = [];
                gameState.players.forEach((p, idx) => {
                    if (!p.isEliminated && idx !== gfx.treMolioActivator) {
                        if (p.protettoreFato) { immunePlayers.push(p.name + '(Protetto)'); return; }
                        if (p.isImmortal) { immunePlayers.push(p.name + '(Immortale)'); return; }
                        p.hp = Math.max(0, p.hp - totalDmg);
                        affectedPlayers.push(p.name);
                        if (p.hp === 0 && !p.isEliminated) {
                            tryEliminatePlayer(p, `(3 Molio)`, false, result.sum);
                        }
                    }
                });
                let msg = `üéØ [3 Molio] Un 3 nei dadi! Tutti (escluso attivatore) subiscono ${totalDmg} danni: ${affectedPlayers.join(', ')}`;
                if (immunePlayers.length) msg += `. Immuni: ${immunePlayers.join(', ')}`;
                gameState.history.push(msg);
            }
            
            // NIRVANA - attivatore guadagna HP pari al totale dei dadi
            if (gfx.nirvana && result.shooterIndex !== gfx.nirvanaActivator) {
                const nirvanaBeneficiary = gameState.players[gfx.nirvanaActivator];
                if (nirvanaBeneficiary && !nirvanaBeneficiary.isEliminated) {
                    const healAmount = result.sum;
                    nirvanaBeneficiary.hp += healAmount;
                    gameState.history.push(`üßò [Nirvana] ${nirvanaBeneficiary.name} guadagna +${healAmount} HP dal lancio di ${shooter.name}`);
                }
            }
            
            // CANNONE KARMA - danni a bersaglio E a s√© stesso
            if (gfx.cannoneKarma && result.shooterIndex !== gfx.cannoneKarmaActivator && result.damage > 0) {
                shooter.hp = Math.max(0, shooter.hp - result.damage);
                // Traccia statistiche auto-danni
                if (!gameState.stats[shooter.name]) {
                    gameState.stats[shooter.name] = { damageDealt: 0, damageTaken: 0, healingDone: 0, specialMoves: 0, turns: 0 };
                }
                gameState.stats[shooter.name].damageTaken += result.damage;
                gameState.history.push(`üí• [Cannone Karma] ${shooter.name} subisce ${result.damage} danni auto-inflitti (stesso danno del bersaglio)`);
                if (shooter.hp === 0 && !shooter.isEliminated) {
                    tryEliminatePlayer(shooter, `(Cannone Karma auto-danno)`);
                }
            }
            
            // TALISMANO DI RA E DADO AVVELENATO
            // L'ATTIVATORE imposta 2 valori. Altri giocatori che li tirano: Talismano‚Üícura attivatore, Dado Avvelenato‚Üídanni al tiratore
            gameState.players.forEach((p, idx) => {
                // TALISMANO DI RA: p √® l'attivatore, il tiratore (result.shooterIndex) fa match dei suoi valori
                if (p.talismanRa && p.talismanRaValues.length === 2 && idx !== result.shooterIndex) {
                    const [val1, val2] = p.talismanRaValues;
                    let matchCount = 0;
                    result.dice.forEach(d => {
                        if (d === val1 || d === val2) matchCount++;
                    });
                    if (matchCount > 0) {
                        const heal = val1 * val2 * matchCount;
                        p.hp = Math.min(p.hp + heal, gameState.initialHP * 2); // Cura l'ATTIVATORE
                        gameState.history.push(`üåû [Talismano Ra] ${p.name} si cura +${heal} HP (${gameState.players[result.shooterIndex].name} ha tirato valori ${val1}/${val2} √ó${matchCount})`);
                    }
                }
                
                // DADO AVVELENATO: p √® l'attivatore, il tiratore (result.shooterIndex) ha i valori dell'attivatore
                // ‚Üí il TIRATORE subisce i danni
                if (p.dadoAvvelenato && p.dadoAvvelenatotValues.length === 2 && idx !== result.shooterIndex) {
                    const [val1, val2] = p.dadoAvvelenatotValues;
                    let matchCount = 0;
                    result.dice.forEach(d => {
                        if (d === val1 || d === val2) matchCount++;
                    });
                    if (matchCount > 0) {
                        const damage = val1 * val2 * matchCount;
                        shooter.hp = Math.max(0, shooter.hp - damage); // Danni al TIRATORE
                        gameState.history.push(`‚ò†Ô∏è [Dado Avvelenato] ${shooter.name} subisce -${damage} danni (valori ${val1}/${val2} di ${p.name} √ó${matchCount} match)`);
                        if (shooter.hp === 0 && !shooter.isEliminated) {
                            tryEliminatePlayer(shooter, `(Dado Avvelenato di ${p.name})`);
                        }
                    }
                }
            });

            // IMPORTANTE: Riassegna target dopo effetti globali (Bambola Voodoo pu√≤ cambiare targetIndex)
            const finalTarget = result.targetIndex >= 0 ? gameState.players[result.targetIndex] : null;

            // Apply damage
            if (finalTarget) {
                // Initialize stats for target if not exists
                if (!gameState.stats[finalTarget.name]) {
                    gameState.stats[finalTarget.name] = {
                        damageDealt: 0,
                        damageTaken: 0,
                        healingDone: 0,
                        specialMoves: 0,
                        turns: 0
                    };
                }
                
                // Apply multiplier to damage (calcolo anticipato per Volo Fenice)
                const multiplier = finalTarget.multiplier || 1;
                let actualDamage = Math.ceil(result.damage * multiplier);
                
                // TIRO CARICATO - moltiplica il prossimo danno (solo per danni, NON cure)
                if (shooter.tiroCaricato && actualDamage > 0) {
                    const tiroMult = shooter.tiroCaricatoMultiplier || 2;
                    actualDamage = actualDamage * tiroMult;
                    gameState.history.push(`‚ö° [Tiro Caricato] ${shooter.name} moltiplica il danno x${tiroMult}! Danno finale: ${actualDamage}`);
                    // Disattiva Tiro Caricato dopo l'uso
                    shooter.tiroCaricato = false;
                    shooter.tiroCaricatoMultiplier = null;
                }
                
                // MINOTAURO CORROTTO - annulla danni pari (NON le cure)
                if (gfx.minotauroCorreto && actualDamage > 0 && actualDamage % 2 === 0) {
                    gameState.history.push(`üêÇ [Minotauro Corrotto] Danno pari ${actualDamage} annullato!`);
                    actualDamage = 0;
                    // Il turno procede automaticamente poich√© il danno √® nullo
                }
                
                // BOOMERANG - accumula invece di applicare (PRIORIT√Ä MASSIMA - sempre prima di tutto)
                if (gfx.boomerang && result.targetIndex === gfx.boomerangActivator && actualDamage > 0) {
                    gfx.boomerangDamage += actualDamage;
                    gameState.history.push(`ü™É [Boomerang] ${finalTarget.name} accumula ${actualDamage} danni (totale: ${gfx.boomerangDamage})`);
                    // Full write + advance turn before returning
                    resetTemporaryEffects(result.shooterIndex);
                    const nextTurnBoomerang = getNextActiveTurn();
                    if (gameState.history.length > 50) gameState.history = gameState.history.slice(-50);
                    gameState.currentTurn = nextTurnBoomerang;
                    forceUIUpdate();
                    database.ref('games/' + gameState.gameCode).update({
                        players: gameState.players, currentTurn: nextTurnBoomerang,
                        history: gameState.history, stats: gameState.stats, globalEffects: gfx
                    });
                    return;
                }
                
                // VOLO DELLA FENICE - cure raddoppiate al posto dei danni (PRIORIT√Ä ALTA)
                if (finalTarget.voloFenice && actualDamage > 0) {
                    const heal = actualDamage * 2;
                    finalTarget.hp += heal;
                    gameState.history.push(`ü¶Ö [Volo Fenice] ${finalTarget.name} converte ${actualDamage} danni in +${heal} HP di cura`);
                    animateHP(result.targetIndex, heal);
                    playSound('heal');
                    if (finalTarget.name === gameState.playerName) {
                        screenFlash('heal');
                        createParticles(window.innerWidth / 2, window.innerWidth / 2, 'heal');
                    }
                    // Non fare altro, il danno √® stato convertito - la write finale di applyResult gestisce Firebase
                } 
                // MANO DI FREYA - converte tutti i danni ricevuti in cure
                else if (finalTarget.manoFreya && actualDamage > 0) {
                    finalTarget.hp += actualDamage;
                    gameState.history.push(`üåø [Mano di Freya] ${finalTarget.name} converte ${actualDamage} danni in +${actualDamage} HP`);
                    animateHP(result.targetIndex, actualDamage);
                    playSound('heal');
                    if (finalTarget.name === gameState.playerName) { screenFlash('heal'); }
                    // La write finale di applyResult gestisce Firebase
                } 
                // PROTETTORE DEL FATO - protegge da TUTTI gli effetti dannosi (incluso eliminazione diretta)
                else if (finalTarget.protettoreFato && actualDamage > 0) {
                    gameState.history.push(`üõ°Ô∏è‚ú® [Protettore del Fato] ${finalTarget.name} √® protetto da tutti i danni e effetti dannosi!`);
                    playSound('heal');
                    if (finalTarget.name === gameState.playerName) {
                        screenFlash('heal');
                        createParticles(window.innerWidth / 2, window.innerHeight / 2, 'heal');
                    }
                    // Il danno viene completamente bloccato - non fare altro
                }
                // Check if target is immortal
                else if (finalTarget.isImmortal) {
                    // Immortal player takes no damage
                    gameState.history.push(`‚≠ê ${finalTarget.name} √® immortale e non subisce danni!`);
                    playSound('heal'); // Suono positivo per indicare l'immortalit√†
                    
                    // Visual effect for immortal player
                    if (finalTarget.name === gameState.playerName) {
                        screenFlash('heal');
                        createParticles(window.innerWidth / 2, window.innerHeight / 2, 'heal');
                    }
                } else {

                    const wasAlive = !finalTarget.isEliminated;
                    
                    // === MECCANICHE INDIVIDUALI DEL TARGET ===
                    
                    // INTERFERENZA - trasferisci danno al partner
                    if (finalTarget.interferenza && finalTarget.interferenzaPartner !== null && actualDamage > 0) {
                        const partner = gameState.players[finalTarget.interferenzaPartner];
                        if (partner && !partner.isEliminated) {
                            const originalTargetName = finalTarget.name;
                            result.targetIndex = finalTarget.interferenzaPartner;
                            // Aggiorna il target
                            const newTarget = partner;
                            gameState.history.push(`üîÄ [Interferenza] Danno trasferito da ${originalTargetName} a ${partner.name}`);
                            // Applica il danno al partner invece che continuare con il target originale
                            newTarget.hp = Math.max(0, newTarget.hp - actualDamage);
                            if (newTarget.hp === 0 && !newTarget.isEliminated) {
                                tryEliminatePlayer(newTarget, `(Interferenza da ${originalTargetName})`, true, actualDamage);
                            }
                            animateHP(finalTarget.interferenzaPartner, -actualDamage);
                            playSound('damage');
                            if (newTarget.name === gameState.playerName) {
                                screenFlash('damage');
                            }
                            // Full write + advance turn
                            resetTemporaryEffects(result.shooterIndex);
                            const nextTurnInt = getNextActiveTurn();
                            if (gameState.history.length > 50) gameState.history = gameState.history.slice(-50);
                            gameState.currentTurn = nextTurnInt;
                            forceUIUpdate();
                            database.ref('games/' + gameState.gameCode).update({
                                players: gameState.players, currentTurn: nextTurnInt,
                                history: gameState.history, stats: gameState.stats, globalEffects: gameState.globalEffects
                            });
                            return;
                        } else {
                            // Partner eliminato: disattiva Interferenza
                            finalTarget.interferenza = false;
                            finalTarget.interferenzaPartner = null;
                            gameState.history.push(`‚ùå [Interferenza] Effetto disattivato (partner ${partner ? partner.name : 'sconosciuto'} eliminato)`);
                            // Continua con danno normale a finalTarget
                        }
                    }
                    
                    
                    // ARMATURA SPECCHIO - distribuisci danno a tutti (il turno prosegue normalmente)
                    if (gfx.armaturaSpecchio && result.targetIndex === gfx.armaturaSpecchioActivator && actualDamage > 0) {
                        const activePlayers = gameState.players.filter(p => !p.isEliminated);
                        const damagePerPlayer = Math.ceil(actualDamage / activePlayers.length);
                        let affectedNames = [];
                        activePlayers.forEach(p => {
                            if (p.protettoreFato || p.isImmortal) { affectedNames.push(p.name + '(immune)'); return; }
                            p.hp = Math.max(0, p.hp - damagePerPlayer);
                            affectedNames.push(p.name);
                            if (p.hp === 0 && !p.isEliminated) {
                                tryEliminatePlayer(p, `(Armatura Specchio)`, false, damagePerPlayer);
                            }
                        });
                        gameState.history.push(`ü™û [Armatura Specchio] ${damagePerPlayer} danni distribuiti a tutti: ${affectedNames.join(', ')}`);
                        playSound('damage');
                        // NON si salta il turno: il gioco continua normalmente
                        // La funzione NON fa return, lascia che il turno avanzi normalmente a fine applyResult
                    }
                    
                    // SPECCHIO MALEDETTO - rifletti sull'attaccante e si deattiva subito (uso singolo)
                    if (finalTarget.rifletteDanni && actualDamage > 0) {
                        shooter.hp = Math.max(0, shooter.hp - actualDamage);
                        finalTarget.rifletteDanni = false;
                        if (finalTarget.temporaryEffects) finalTarget.temporaryEffects.rifletteDanni = false;
                        gameState.history.push(`ü™û [Specchio Maledetto] ${finalTarget.name} riflette ${actualDamage} danni su ${shooter.name} (effetto consumato)`);
                        if (shooter.hp === 0 && !shooter.isEliminated) {
                            tryEliminatePlayer(shooter, `(Specchio Maledetto da ${finalTarget.name})`, true, actualDamage);
                        }
                        animateHP(result.shooterIndex, -actualDamage);
                        playSound('damage');
                        // Write completa con tutti i campi, poi esci
                        resetTemporaryEffects(result.shooterIndex);
                        const nextTurnSpecchio = getNextActiveTurn();
                        if (gameState.history.length > 50) gameState.history = gameState.history.slice(-50);
                        gameState.currentTurn = nextTurnSpecchio;
                        forceUIUpdate();
                        database.ref('games/' + gameState.gameCode).update({
                            players: gameState.players, currentTurn: nextTurnSpecchio,
                            history: gameState.history, stats: gameState.stats, globalEffects: gameState.globalEffects
                        });
                        return; // Target non subisce danno
                    }
                    
                    // MARE DI GUAI - chi ha il malus subisce il doppio dei danni ricevuti e salta turno
                    if (finalTarget.mareGuai && actualDamage > 0) {
                        // Raddoppia i danni ricevuti
                        actualDamage = actualDamage * 2;
                        gameState.history.push(`üåä [Mare di Guai] ${finalTarget.name} subisce danni raddoppiati (${actualDamage})`);
                    }
                    
                    // Se l'attaccante ha Mare di Guai e fa tris, salta il turno
                    if (shooter.mareGuai && result.specialEffect === 'Tris') {
                        // Far saltare il turno (solo se non sta gi√† saltando)
                        if (!shooter.skipTurn) {
                            shooter.skipTurn = true;
                            gameState.history.push(`üåä [Mare di Guai] ${shooter.name} ha fatto tris - salter√† il prossimo turno`);
                        } else {
                            gameState.history.push(`üåä [Mare di Guai] ${shooter.name} sta gi√† saltando il prossimo turno`);
                        }
                    }
                    
                    // CACTUS AMARI - subisce e riflette il doppio
                    if (finalTarget.cactusAmari && actualDamage > 0) {
                        const reflectedDamage = actualDamage * 2;
                        shooter.hp = Math.max(0, shooter.hp - reflectedDamage);
                        if (!gameState.stats[shooter.name]) {
                            gameState.stats[shooter.name] = { damageDealt: 0, damageTaken: 0, healingDone: 0, specialMoves: 0, turns: 0 };
                        }
                        if (!gameState.stats[finalTarget.name]) {
                            gameState.stats[finalTarget.name] = { damageDealt: 0, damageTaken: 0, healingDone: 0, specialMoves: 0, turns: 0 };
                        }
                        gameState.stats[shooter.name].damageTaken += reflectedDamage;
                        gameState.stats[finalTarget.name].damageDealt += reflectedDamage;
                        gameState.history.push(`üåµ [Cactus Amari] ${shooter.name} subisce ${reflectedDamage} danni riflessi (x2) da ${finalTarget.name}`);
                        if (shooter.hp === 0 && !shooter.isEliminated) {
                            tryEliminatePlayer(shooter, `(Spine Cactus Amari da ${finalTarget.name})`, true, actualDamage);
                        }
                        animateHP(result.shooterIndex, -reflectedDamage);
                        // Il target subisce comunque il danno normale
                    }
                    
                    // ELMO MALEDETTO - danno riflesso anche all'attaccante (target subisce comunque)
                    if (finalTarget.elmoMaledetto && actualDamage > 0) {
                        shooter.hp = Math.max(0, shooter.hp - actualDamage);
                        gameState.history.push(`‚õëÔ∏è [Elmo Maledetto] ${shooter.name} subisce ${actualDamage} danni riflessi da ${finalTarget.name}`);
                        if (shooter.hp === 0 && !shooter.isEliminated) {
                            tryEliminatePlayer(shooter, `(Elmo Maledetto da ${finalTarget.name})`, true, actualDamage);
                        }
                        animateHP(result.shooterIndex, -actualDamage);
                        // Il target subisce comunque il danno normale
                    }
                    
                    // ARMATURA DEL CAVALIERE - dimezza i danni ricevuti
                    if (finalTarget.armaturaCavaliere && actualDamage > 0) {
                        const originalDmg = actualDamage;
                        actualDamage = Math.floor(actualDamage / 2);
                        gameState.history.push(`üõ°Ô∏è [Armatura Cavaliere] ${finalTarget.name}: ${originalDmg} ‚Üí ${actualDamage} danni (dimezzati)`);
                    }
                    
                    // CATENA MALEDETTA - infligge danno ai giocatori adiacenti
                    if (finalTarget.catenaMaledetta && actualDamage > 0) {
                        const targetIdx = result.targetIndex;
                        const prevIdx = (targetIdx - 1 + gameState.players.length) % gameState.players.length;
                        const nextIdx = (targetIdx + 1) % gameState.players.length;
                        
                        let chainedPlayers = [];
                        [prevIdx, nextIdx].forEach(idx => {
                            const adjacent = gameState.players[idx];
                            if (adjacent && !adjacent.isEliminated && idx !== result.targetIndex) {
                                adjacent.hp = Math.max(0, adjacent.hp - actualDamage);
                                chainedPlayers.push(adjacent.name);
                                if (adjacent.hp === 0 && !adjacent.isEliminated) {
                                    tryEliminatePlayer(adjacent, `(Catena Maledetta da ${finalTarget.name})`, false, actualDamage);
                                }
                            }
                        });
                        if (chainedPlayers.length > 0) {
                            gameState.history.push(`‚õìÔ∏è [Catena Maledetta] Giocatori adiacenti colpiti (${actualDamage} danni): ${chainedPlayers.join(', ')}`);
                        }
                    }
                    
                    // SABBIE MOBILI - il bersaglio colpito salta il prossimo turno (no cumulo, attivatore immune)
                    if (gfx.sabbieMobili && result.shooterIndex !== gfx.sabbieMobiliActivator && actualDamage > 0) {
                        const targetPlayer = gameState.players[result.targetIndex];
                        if (targetPlayer && !targetPlayer.isEliminated && result.targetIndex !== gfx.sabbieMobiliActivator) {
                            if (!targetPlayer.skipTurn) {
                                targetPlayer.skipTurn = true;
                                gameState.history.push(`‚è≥ [Sabbie Mobili] ${targetPlayer.name} salter√† il prossimo turno`);
                            } else {
                                gameState.history.push(`‚è≥ [Sabbie Mobili] ${targetPlayer.name} sta gi√† saltando (no cumulo)`);
                            }
                        }
                    }
                    
                    // DOMINO - danni propagati al giocatore successivo
                    if (gfx.domino && actualDamage > 0 && result.shooterIndex !== gfx.dominoActivator) {
                        // Trova il prossimo giocatore attivo dopo il target (saltando eliminati e attivatore)
                        let dominoTarget = result.targetIndex;
                        let attempts = 0;
                        do {
                            if (gameState.direction === 'clockwise') {
                                dominoTarget = (dominoTarget + 1) % gameState.players.length;
                            } else {
                                dominoTarget = (dominoTarget - 1 + gameState.players.length) % gameState.players.length;
                            }
                            attempts++;
                        } while ((gameState.players[dominoTarget].isEliminated || dominoTarget === gfx.dominoActivator || dominoTarget === result.targetIndex) && attempts < gameState.players.length);
                        
                        if (attempts < gameState.players.length && !gameState.players[dominoTarget].isEliminated && dominoTarget !== gfx.dominoActivator) {
                            const dominoPlayer = gameState.players[dominoTarget];
                            dominoPlayer.hp = Math.max(0, dominoPlayer.hp - actualDamage);
                            gameState.history.push(`üÅ° [Domino] ${dominoPlayer.name} subisce ${actualDamage} danni a catena!`);
                            if (dominoPlayer.hp === 0 && !dominoPlayer.isEliminated) {
                                tryEliminatePlayer(dominoPlayer, `(Domino da ${finalTarget.name})`, false, actualDamage);
                            }
                            animateHP(dominoTarget, -actualDamage);
                        }
                    }
                    
                    // Check for damage conversion effects
                    let shouldConvertToHeal = false;
                    let conversionReason = '';
                    
                    // 1. Conversione Danni‚ÜíCure (üí´) - Converte TUTTI i danni
                    if (finalTarget.damageToHeal) {
                        shouldConvertToHeal = true;
                        conversionReason = 'üí´ Conversione Danni‚ÜíCure';
                    }
                    // 2. Armatura del Sole (‚òÄÔ∏è) - Converte solo danni DISPARI
                    else if (finalTarget.sunArmor && actualDamage % 2 !== 0) {
                        shouldConvertToHeal = true;
                        conversionReason = `‚òÄÔ∏è Armatura del Sole (${actualDamage} dispari)`;
                    }
                    // 3. Armatura della Luna (üåô) - Converte solo danni PARI
                    else if (finalTarget.moonArmor && actualDamage % 2 === 0) {
                        shouldConvertToHeal = true;
                        conversionReason = `üåô Armatura della Luna (${actualDamage} pari)`;
                    }
                    
                    if (shouldConvertToHeal) {
                        // Converti danno in cura (NON aggiornare damageDealt/Taken!)
                        finalTarget.hp += actualDamage;
                        gameState.history.push(`${conversionReason}: ${finalTarget.name} si cura di ${actualDamage} HP invece di subirli!`);
                        animateHP(result.targetIndex, actualDamage);
                        playSound('heal');
                        
                        // Visual effects for heal
                        if (finalTarget.name === gameState.playerName) {
                            screenFlash('heal');
                            createParticles(window.innerWidth / 2, window.innerHeight / 2, 'heal');
                        }
                    } else {
                        // Applica danno normalmente - SOLO QUI aggiorniamo le stats
                        gameState.stats[shooter.name].damageDealt += actualDamage;
                        gameState.stats[finalTarget.name].damageTaken += actualDamage;
                        
                        finalTarget.hp = Math.max(0, finalTarget.hp - actualDamage);
                        
                        // Check Checkmate - force HP to 0 at exact HP value (resurrection can still activate)
                        // PROTETTORE DEL FATO bypassa questo effetto
                        if (finalTarget.checkmateHP && finalTarget.hp === finalTarget.checkmateHP && !finalTarget.isEliminated && !finalTarget.protettoreFato) {
                            finalTarget.hp = 0;
                            gameState.history.push(`‚ôüÔ∏è ${finalTarget.name} attivato Scacco Matto! (${finalTarget.checkmateHP} HP)`);
                        }
                        // Check Kraken Mark - force HP to 0 at 10 HP or less (resurrection can still activate)
                        // PROTETTORE DEL FATO bypassa questo effetto
                        else if (finalTarget.krakenMark && finalTarget.hp <= 10 && finalTarget.hp > 0 && !finalTarget.isEliminated && !finalTarget.protettoreFato) {
                            finalTarget.hp = 0;
                            gameState.history.push(`üêô ${finalTarget.name} attivato Marchio del Kraken! (HP ‚â§ 10)`);
                        }
                        
                        if (finalTarget.hp === 0 && wasAlive) {
                            // === RESET TUTTI GLI EFFETTI QUANDO ELIMINATO ===
                            finalTarget.isImmortal = false;
                            finalTarget.multiplier = 1;
                            finalTarget.multiplierAppliedBy = null;
                            finalTarget.skipTurn = false;
                            finalTarget.customDiceCount = null;
                            finalTarget.krakenMark = false;
                            finalTarget.checkmateHP = null;
                            finalTarget.damageToHeal = false;
                            finalTarget.sunArmor = false;
                            finalTarget.moonArmor = false;
                            finalTarget.mareGuai = false;
                            finalTarget.voloFenice = false;
                            finalTarget.cactusAmari = false;
                            finalTarget.catenaMaledetta = false;
                            finalTarget.rifletteDanni = false;
                            target.talismanRa = false;
                            target.talismanRaValues = [];
                            target.dadoAvvelenato = false;
                            target.dadoAvvelenatotValues = [];
                            finalTarget.interferenza = false;
                            finalTarget.interferenzaPartner = null;
                            finalTarget.protettoreFato = false;
                            finalTarget.tiroCaricato = false;
                            finalTarget.tiroCaricatoMultiplier = null;
                            finalTarget.temporaryEffects = {
                                immortal: false, multiplier: false, skipTurn: false, customDice: false,
                                damageToHeal: false, sunArmor: false, moonArmor: false,
                                mareGuai: false, voloFenice: false, cactusAmari: false,
                                catenaMaledetta: false, rifletteDanni: false,
                elmoMaledetto: false,
                manoFreya: false,
                armaturaCavaliere: false,
                                talismanRa: false, dadoAvvelenato: false, protettoreFato: false
                            };
                            
                            // === CARTE RESURREZIONE (in ordine di priorit√†) ===
                            let resurrected = false;
                            
                            // 1. CANTO DEL CIGNO
                            if (finalTarget.cantoDelCigno) {
                                finalTarget.hp = 1;
                                finalTarget.isEliminated = false;
                                finalTarget.cantoDelCigno = false;
                                gameState.history.push(`ü¶¢ [Canto del Cigno] ${finalTarget.name} torna in vita con 1 HP! üÉè Pesca 2 carte del Fato`);
                                playSound('revive');
                                if (finalTarget.name === gameState.playerName) {
                                    screenFlash('revive');
                                }
                                resurrected = true;
                            }
                            // 2. PATTO CON IL DIAVOLO
                            else if (finalTarget.pattoDiavolo && !finalTarget.pattoDiavoloUsed) {
                                finalTarget.hp = 20;
                                finalTarget.isEliminated = false;
                                finalTarget.customDiceCount = 2; // Solo 2 dadi per sempre
                                finalTarget.pattoDiavolo = false;
                                finalTarget.pattoDiavoloUsed = true;
                                gameState.history.push(`üòà [Patto col Diavolo] ${finalTarget.name} torna con 20 HP, ma user√† solo 2 dadi per sempre`);
                                playSound('revive');
                                if (finalTarget.name === gameState.playerName) {
                                    screenFlash('revive');
                                }
                                resurrected = true;
                            }
                            // 3. TOMBA DI TUTANKHAMON
                            else if (finalTarget.tombaTutankhamon) {
                                finalTarget.hp = Math.ceil(gameState.initialHP / 2);
                                finalTarget.isEliminated = false;
                                finalTarget.skipTurn = true;
                                finalTarget.tombaTutankhamon = false;
                                gameState.history.push(`üè∫ [Tomba Tutankhamon] ${finalTarget.name} torna con ${finalTarget.hp} HP, ma salter√† il prossimo turno`);
                                playSound('revive');
                                if (finalTarget.name === gameState.playerName) {
                                    screenFlash('revive');
                                }
                                resurrected = true;
                            }
                            // 4. REINCARNAZIONE
                            else if (finalTarget.reincarnazione && !finalTarget.reincarnazioneUsed) {
                                finalTarget.hp = gameState.initialHP;
                                finalTarget.isEliminated = false;
                                finalTarget.multiplier = 2; // Danni x2 permanenti
                                finalTarget.reincarnazioneMultiplier = true; // Flag permanente - non rimosso da resetTemporaryEffects
                                finalTarget.reincarnazione = false;
                                finalTarget.reincarnazioneUsed = true;
                                gameState.history.push(`‚ôªÔ∏è [Reincarnazione] ${finalTarget.name} torna con ${finalTarget.hp} HP, ma subir√† danni √ó2 per sempre!`);
                                playSound('revive');
                                if (finalTarget.name === gameState.playerName) {
                                    screenFlash('revive');
                                }
                                resurrected = true;
                            }
                            
                            // Nessuna resurrezione - eliminato definitivamente
                            if (!resurrected) {
                                finalTarget.isEliminated = true;
                                gameState.history.push(`üíÄ ${finalTarget.name} √® stato eliminato!`);
                                
                                // CONTAGIO: propaga il danno letale a tutti (escluso attivatore), scatta una volta sola
                                const gfxCT = gameState.globalEffects;
                                const elimIdxCT = result.targetIndex;
                                if (gfxCT.contagio && elimIdxCT !== gfxCT.contagioActivator) {
                                    let contagioAffected = [];
                                    gameState.players.forEach((p, idx) => {
                                        if (!p.isEliminated && idx !== gfxCT.contagioActivator && idx !== elimIdxCT) {
                                            if (p.protettoreFato) { contagioAffected.push(p.name + '(immune)'); return; }
                                            if (p.isImmortal) { contagioAffected.push(p.name + '(immortale)'); return; }
                                            if (p.manoFreya) { p.hp += actualDamage; contagioAffected.push(p.name + '(curaüåø)'); return; }
                                            if (p.voloFenice) { p.hp += actualDamage * 2; contagioAffected.push(p.name + '(curaü¶Ö)'); return; }
                                            if (p.damageToHeal) { p.hp += actualDamage; contagioAffected.push(p.name + '(curaüí´)'); return; }
                                            let cdmg = actualDamage;
                                            if (p.armaturaCavaliere) cdmg = Math.floor(cdmg / 2);
                                            if (p.elmoMaledetto && cdmg > 0) {
                                                finalTarget.hp = Math.max(0, finalTarget.hp - cdmg);
                                                gameState.history.push(`‚õëÔ∏è [Elmo] ${cdmg} danni riflessi a ${finalTarget.name} (Contagio su ${p.name})`);
                                            }
                                            if (p.cactusAmari && cdmg > 0) {
                                                finalTarget.hp = Math.max(0, finalTarget.hp - cdmg * 2);
                                                gameState.history.push(`üåµ [Cactus] ${cdmg * 2} danni riflessi a ${finalTarget.name} (Contagio su ${p.name})`);
                                            }
                                            p.hp = Math.max(0, p.hp - cdmg);
                                            contagioAffected.push(p.name);
                                            if (p.hp === 0 && !p.isEliminated) {
                                                tryEliminatePlayer(p, `(Contagio da ${finalTarget.name})`, false, cdmg);
                                            }
                                        }
                                    });
                                    gameState.history.push(`ü¶† [Contagio] ${finalTarget.name} eliminato! ${actualDamage} danni propagati a: ${contagioAffected.join(', ')}`);
                                    gfxCT.contagio = false;
                                    gfxCT.contagioActivator = null;
                                    gameState.history.push('ü¶† [Contagio] Effetto esaurito.');
                                }
                                
                                // Show elimination notification
                                if (finalTarget.name === gameState.playerName && !gameState.isMaster) {
                                    setTimeout(() => showEliminatedNotification(), 500);
                                }
                                
                                playSound('elimination');
                            }
                            
                            // === BOIA ESECUTORE ===
                            if (shooter.boiaEsecutore && shooter.boiaEsecutoreTurns > 0 && finalTarget.isEliminated) {
                                let nextPlayerIndex = (result.targetIndex + 1) % gameState.players.length;
                                let attempts = 0;
                                // Salta giocatori eliminati E l'attivatore del Boia Esecutore
                                while ((gameState.players[nextPlayerIndex].isEliminated || nextPlayerIndex === result.shooterIndex) && attempts < gameState.players.length) {
                                    nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;
                                    attempts++;
                                }
                                
                                const nextPlayer = gameState.players[nextPlayerIndex];
                                // Verifica che non sia l'attivatore e che sia vivo
                                if (nextPlayer && !nextPlayer.isEliminated && nextPlayerIndex !== result.shooterIndex) {
                                    tryEliminatePlayer(nextPlayer, `(Eliminazione a catena da Boia Esecutore)`);
                                }
                            }
                        } else {
                            playSound('hit');
                            
                            // Visual effects for the player who got hit
                            if (finalTarget.name === gameState.playerName) {
                                screenFlash('damage');
                                createParticles(window.innerWidth / 2, window.innerHeight / 2, 'damage');
                            }
                        }
                        
                        animateHP(result.targetIndex, -actualDamage);
                        
                        // Add multiplier info to history
                        if (multiplier !== 1) {
                            gameState.history.push(`‚ú® ${finalTarget.name} ha un moltiplicatore x${multiplier}! Danno effettivo: ${actualDamage}`);
                        }
                    }
                }
            }

            // Apply heal ‚Äî ONLY if shooter is still alive (pu√≤ essere stato eliminato da Cactus/Elmo/Specchio)
            if (result.selfHeal > 0 && !shooter.isEliminated) {
                // Apply multiplier to heal
                const multiplier = shooter.multiplier || 1;
                const actualHeal = Math.ceil(result.selfHeal * multiplier); // Arrotonda per eccesso
                
                shooter.hp += actualHeal;
                gameState.stats[shooter.name].healingDone += actualHeal;
                animateHP(result.shooterIndex, actualHeal);
                playSound('heal');
                
                // Visual effects for healer
                if (shooter.name === gameState.playerName) {
                    screenFlash('heal');
                    createParticles(window.innerWidth / 2, window.innerHeight / 2, 'heal');
                }
                
                // Add multiplier info to history
                if (multiplier !== 1) {
                    gameState.history.push(`‚ú® ${shooter.name} ha un moltiplicatore x${multiplier}! Cura effettiva: ${actualHeal}`);
                }
            }
            
            // Track special moves
            if (result.specialEffect === 'Coppia' || result.specialEffect === 'Tris') {
                gameState.stats[shooter.name].specialMoves++;
            }

            // History - Messaggio principale del turno
            let historyText = `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
            historyText += `üéÆ TURNO ${gameState.stats[shooter.name]?.turns || 1} - ${shooter.name.toUpperCase()}\n`;
            historyText += `üé≤ Dadi lanciati: ${result.dice.join(' ¬∑ ')} = ${result.sum}`;
            
            if (result.specialEffect) {
                if (result.specialEffect === 'Tris') {
                    historyText += `\n‚ú® TRIS! ${result.specialEffect}`;
                } else if (result.specialEffect === 'Coppia') {
                    historyText += `\n‚ú® COPPIA! ${result.specialEffect}`;
                }
            }
            
            if (target) {
                if (result.damage > 0) {
                    historyText += `\nüí• DANNO: ${result.damage} ‚Üí ${target.name}`;
                } else if (result.damage < 0) {
                    historyText += `\nüíö CURA: ${Math.abs(result.damage)} ‚Üí ${target.name}`;
                }
            }
            
            if (result.selfHeal > 0) {
                historyText += `\n‚ù§Ô∏è AUTO-CURA: +${result.selfHeal} HP`;
            }
            
            if (result.cardsDrawn > 0) {
                historyText += `\nüÉè Pesca ${result.cardsDrawn} carta${result.cardsDrawn > 1 ? 'e' : ''} del Fato`;
            }
            
            gameState.history.push(historyText);

            // 7 BELLO - Controlla se l'attivatore ha fatto 7 nei prossimi 2 turni
            if (gfx.setteBello && result.shooterIndex === gfx.setteBelloActivator && result.sum === 7) {
                // Trova il settimo giocatore attivo in ordine di turno partendo dall'attivatore
                // (escludendo l'attivatore stesso e gli eliminati)
                const activatorIdx = gfx.setteBelloActivator;
                const allActive = [];
                // Costruisce la lista circolare di giocatori attivi partendo dal successivo all'attivatore
                for (let offset = 1; offset <= gameState.players.length; offset++) {
                    const idx = (activatorIdx + offset) % gameState.players.length;
                    if (!gameState.players[idx].isEliminated) {
                        allActive.push({ player: gameState.players[idx], index: idx });
                    }
                }
                
                if (allActive.length === 0) {
                    gameState.history.push(`üé∞ [7 Bello] ${shooter.name} ha fatto 7, ma non ci sono altri giocatori attivi!`);
                } else {
                    // Il "settimo" in senso circolare: wrap con modulo
                    const targetEntry = allActive[(7 - 1) % allActive.length]; // 7¬∞, wrappa se meno di 7
                    gameState.history.push(`üé∞ [7 Bello] ${shooter.name} ha fatto 7! Il settimo giocatore (${targetEntry.player.name}) viene eliminato!`);
                    tryEliminatePlayer(targetEntry.player, `(Eliminazione da 7 BELLO)`);
                }
                
                // Disattiva effetto dopo l'uso
                gfx.setteBello = false;
                gfx.setteBelloActivator = null;
                gfx.setteBelloTurnsLeft = 0;
            }

            // Reset temporary effects for the player who just played
            resetTemporaryEffects(result.shooterIndex);

            // Next turn
            const nextTurn = getNextActiveTurn();

            // ===== FIX: Limita history agli ultimi 50 eventi prima dell'update =====
            if (gameState.history.length > 50) {
                gameState.history = gameState.history.slice(-50);
            }

            // ===== FASE 1: OPTIMISTIC UPDATE per Tiro Dadi =====
            // Aggiorna stato locale PRIMA di Firebase per feedback immediato
            gameState.currentTurn = nextTurn;
            forceUIUpdate(); // Il giocatore vede SUBITO il risultato! ‚ö°

            // Update Firebase in background
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                currentTurn: nextTurn,
                history: gameState.history,
                stats: gameState.stats,
                globalEffects: gameState.globalEffects
            });
        }

        function showEliminatedNotification() {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'hit-overlay';
            document.body.appendChild(overlay);
            
            setTimeout(() => overlay.classList.add('show'), 10);

            // Create notification
            const notification = document.createElement('div');
            notification.className = 'eliminated-notification';
            notification.innerHTML = `
                <h2>‚ò†Ô∏è SEI STATO ELIMINATO! ‚ò†Ô∏è</h2>
                <div style="font-size: 1.3em; color: #ff6b6b; margin-top: 20px;">
                    La partita continua...
                </div>
            `;
            document.body.appendChild(notification);

            // Show animation
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);

            // Vibrate if supported
            if (navigator.vibrate) {
                navigator.vibrate([300, 100, 300, 100, 500]);
            }

            // Remove after 4 seconds
            setTimeout(() => {
                overlay.style.opacity = '0';
                notification.style.transform = 'translate(-50%, -50%) scale(0)';
                setTimeout(() => {
                    notification.remove();
                    overlay.remove();
                }, 400);
            }, 4000);
        }

        function determineWinner() {
            // Returns the player with highest HP among non-eliminated players (or last standing)
            const alive = gameState.players.filter(p => !p.isEliminated);
            if (alive.length === 0) return gameState.players[0]; // fallback
            return alive.reduce((best, p) => (p.hp > best.hp ? p : best), alive[0]);
        }

        function showWinnerNotification(winnerName, isYou = false) {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'hit-overlay';
            document.body.appendChild(overlay);
            
            setTimeout(() => overlay.classList.add('show'), 10);

            // Build statistics HTML
            let statsHTML = '';
            if (Object.keys(gameState.stats).length > 0) {
                // Find MVP (most damage dealt)
                let mvpName = '';
                let maxDamage = 0;
                let mostHealing = 0;
                let healerName = '';
                let mostSpecials = 0;
                let specialistName = '';
                
                Object.keys(gameState.stats).forEach(name => {
                    const stats = gameState.stats[name];
                    if (stats.damageDealt > maxDamage) {
                        maxDamage = stats.damageDealt;
                        mvpName = name;
                    }
                    if (stats.healingDone > mostHealing) {
                        mostHealing = stats.healingDone;
                        healerName = name;
                    }
                    if (stats.specialMoves > mostSpecials) {
                        mostSpecials = stats.specialMoves;
                        specialistName = name;
                    }
                });
                
                statsHTML = `
                    <div class="game-stats">
                        <h3>üìä Statistiche Partita</h3>
                        ${mvpName ? `<div class="stat-item">
                            <span class="label">üèÖ MVP (Pi√π Danni)</span>
                            <span class="value">${mvpName} - ${maxDamage} danni</span>
                        </div>` : ''}
                        ${healerName && mostHealing > 0 ? `<div class="stat-item">
                            <span class="label">üíö Miglior Guaritore</span>
                            <span class="value">${healerName} - ${mostHealing} HP</span>
                        </div>` : ''}
                        ${specialistName && mostSpecials > 0 ? `<div class="stat-item">
                            <span class="label">‚ú® Re delle Combo</span>
                            <span class="value">${specialistName} - ${mostSpecials} speciali</span>
                        </div>` : ''}
                        <div class="stat-item">
                            <span class="label">‚è±Ô∏è Durata Partita</span>
                            <span class="value">${getGameDuration()}</span>
                        </div>
                    </div>
                `;
            }

            // Create notification
            const notification = document.createElement('div');
            notification.className = 'winner-notification';
            notification.innerHTML = `
                <h2>üèÜ ${isYou ? 'HAI VINTO!' : 'PARTITA TERMINATA!'} üèÜ</h2>
                <div class="winner-name">${winnerName}</div>
                <div style="font-size: 1.2em; color: #1a1a2e; margin-top: 20px; font-weight: 600;">
                    ${isYou ? 'Complimenti campione!' : '√® il vincitore!'}
                </div>
                ${statsHTML}
            `;
            document.body.appendChild(notification);

            // Show animation
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);

            // Vibrate if supported
            if (navigator.vibrate && isYou) {
                navigator.vibrate([100, 50, 100, 50, 100, 50, 500]);
            }

            // Add new game button for master after 3 seconds
            if (gameState.isMaster) {
                setTimeout(() => {
                    const newGameBtn = document.createElement('button');
                    newGameBtn.textContent = 'üéÆ Nuova Partita';
                    newGameBtn.style.cssText = 'margin-top: 20px; width: auto; padding: 15px 30px;';
                    newGameBtn.onclick = () => {
                        startNewGame();
                    };
                    notification.appendChild(newGameBtn);
                }, 3000);
            }
        }
        
        function startNewGame() {
            if (!gameState.isMaster) return;
            
            // Just call newGame which handles everything properly
            newGame();
        }
        
        function getGameDuration() {
            if (!gameState.startTime) return '0:00';
            const duration = Date.now() - gameState.startTime;
            const minutes = Math.floor(duration / 60000);
            const seconds = Math.floor((duration % 60000) / 1000);
            return `${minutes}:${String(seconds).padStart(2, '0')}`;
        }

        function getNextActiveTurn() {
            const gfx = gameState.globalEffects;
            
            // Se stava giocando con Tocca a Me redirect, ripristina dal bersaglio
            if (gfx.toccaAMeRedirectFrom !== null) {
                const resumeFrom = gfx.toccaAMeRedirectFrom;
                gfx.toccaAMeRedirectFrom = null;
                gfx.toccaAMe = false;
                gfx.toccaAMeActivator = null;
                gfx.toccaAMeTarget = null;
                gameState.history.push('‚úã [Tocca a Me] Effetto terminato, il giro riprende normalmente.');
                // Trova il prossimo giocatore attivo dopo il bersaglio originale
                let nextIdx = resumeFrom;
                let att = 0;
                do {
                    if (gameState.direction === 'clockwise') {
                        nextIdx = (nextIdx + 1) % gameState.players.length;
                    } else {
                        nextIdx = (nextIdx - 1 + gameState.players.length) % gameState.players.length;
                    }
                    att++;
                } while ((gameState.players[nextIdx].isEliminated || gameState.players[nextIdx].skipTurn) && att < gameState.players.length);
                if (gameState.players[nextIdx].skipTurn && !gameState.players[nextIdx].isEliminated) {
                    gameState.history.push(`‚è≠Ô∏è ${gameState.players[nextIdx].name} salta il turno`);
                    gameState.players[nextIdx].skipTurn = false; // ‚Üê reset dopo il salto
                }
                return nextIdx;
            }
            
            // Check for extra turns first
            const currentPlayer = gameState.players[gameState.currentTurn];
            if (currentPlayer && currentPlayer.extraTurns > 0) {
                currentPlayer.extraTurns--;
                return gameState.currentTurn; // Stay on same player
            }

            const activePlayers = gameState.players.map((p, i) => i).filter(i => !gameState.players[i].isEliminated);
            
            if (activePlayers.length <= 1) return gameState.currentTurn;

            let nextIndex = gameState.currentTurn;
            let attempts = 0;
            
            do {
                if (gameState.direction === 'clockwise') {
                    nextIndex = (nextIndex + 1) % gameState.players.length;
                } else {
                    nextIndex = (nextIndex - 1 + gameState.players.length) % gameState.players.length;
                }
                attempts++;
                
                // Se il giocatore ha skipTurn attivo, aggiungilo alla history e resettalo
                if (gameState.players[nextIndex].skipTurn && !gameState.players[nextIndex].isEliminated) {
                    gameState.history.push(`‚è≠Ô∏è ${gameState.players[nextIndex].name} salta il turno`);
                    gameState.players[nextIndex].skipTurn = false; // ‚Üê reset dopo il salto
                }
                
            } while ((gameState.players[nextIndex].isEliminated || gameState.players[nextIndex].skipTurn) && attempts < gameState.players.length);

            // TOCCA A ME - se il prossimo giocatore √® il bersaglio, gioca l'attivatore
            if (gfx.toccaAMe && nextIndex === gfx.toccaAMeTarget) {
                const activator = gameState.players[gfx.toccaAMeActivator];
                if (activator && !activator.isEliminated) {
                    gfx.toccaAMeRedirectFrom = nextIndex; // Ricorda da dove riprendere
                    gameState.history.push(`‚úã [Tocca a Me] ${activator.name} gioca al posto di ${gameState.players[nextIndex].name}!`);
                    return gfx.toccaAMeActivator;
                } else {
                    // Attivatore eliminato, annulla effetto
                    gfx.toccaAMe = false;
                    gfx.toccaAMeActivator = null;
                    gfx.toccaAMeTarget = null;
                }
            }

            return nextIndex;
        }

        function animateHP(playerIndex, amount) {
            const card = document.getElementById(`player-card-${playerIndex}`);
            if (!card) return;

            if (amount < 0) {
                card.classList.add('animate-damage');
                setTimeout(() => card.classList.remove('animate-damage'), 500);
            } else {
                card.classList.add('animate-heal');
                setTimeout(() => card.classList.remove('animate-heal'), 500);
            }

            showFloatingNumber(card, amount);
        }

        function showFloatingNumber(element, amount) {
            const rect = element.getBoundingClientRect();
            const floater = document.createElement('div');
            floater.className = `floating-number ${amount < 0 ? 'damage' : 'heal'}`;
            floater.textContent = amount > 0 ? `+${amount}` : amount;
            floater.style.left = rect.left + rect.width / 2 + 'px';
            floater.style.top = rect.top + 'px';
            
            document.body.appendChild(floater);
            setTimeout(() => floater.remove(), 1000);
        }

        function playSound(type) {
            if (!window.AudioContext && !window.webkitAudioContext) return;
            
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            switch(type) {
                case 'hit':
                    // Suono di colpo potenziato - effetto esplosivo
                    const hitOsc = audioContext.createOscillator();
                    const hitGain = audioContext.createGain();
                    const hitNoise = audioContext.createBufferSource();
                    const hitNoiseGain = audioContext.createGain();
                    
                    // Crea rumore bianco per l'impatto
                    const hitBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
                    const hitData = hitBuffer.getChannelData(0);
                    for (let i = 0; i < hitBuffer.length; i++) {
                        hitData[i] = Math.random() * 2 - 1;
                    }
                    hitNoise.buffer = hitBuffer;
                    
                    hitOsc.connect(hitGain);
                    hitGain.connect(audioContext.destination);
                    hitNoise.connect(hitNoiseGain);
                    hitNoiseGain.connect(audioContext.destination);
                    
                    hitOsc.frequency.setValueAtTime(500, audioContext.currentTime);
                    hitOsc.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.15);
                    hitGain.gain.setValueAtTime(0.4, audioContext.currentTime);
                    hitGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    hitNoiseGain.gain.setValueAtTime(0.3, audioContext.currentTime);
                    hitNoiseGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
                    
                    hitOsc.type = 'sawtooth';
                    hitOsc.start(audioContext.currentTime);
                    hitOsc.stop(audioContext.currentTime + 0.15);
                    hitNoise.start(audioContext.currentTime);
                    hitNoise.stop(audioContext.currentTime + 0.08);
                    break;
                    
                case 'heal':
                    // Suono di cura magico - arpeggio ascendente con riverbero
                    const healFreqs = [261.63, 329.63, 392.00, 523.25]; // C4, E4, G4, C5
                    healFreqs.forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.value = freq;
                        osc.type = 'sine';
                        const delay = i * 0.08;
                        gain.gain.setValueAtTime(0.2, audioContext.currentTime + delay);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + delay + 0.4);
                        osc.start(audioContext.currentTime + delay);
                        osc.stop(audioContext.currentTime + delay + 0.4);
                    });
                    break;
                    
                case 'elimination':
                    // Suono di eliminazione epico - discesa drammatica
                    const elimOsc1 = audioContext.createOscillator();
                    const elimOsc2 = audioContext.createOscillator();
                    const elimGain = audioContext.createGain();
                    
                    elimOsc1.connect(elimGain);
                    elimOsc2.connect(elimGain);
                    elimGain.connect(audioContext.destination);
                    
                    elimOsc1.frequency.setValueAtTime(800, audioContext.currentTime);
                    elimOsc1.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + 0.6);
                    elimOsc2.frequency.setValueAtTime(400, audioContext.currentTime);
                    elimOsc2.frequency.exponentialRampToValueAtTime(20, audioContext.currentTime + 0.6);
                    
                    elimGain.gain.setValueAtTime(0.5, audioContext.currentTime);
                    elimGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
                    
                    elimOsc1.type = 'sawtooth';
                    elimOsc2.type = 'square';
                    elimOsc1.start(audioContext.currentTime);
                    elimOsc2.start(audioContext.currentTime);
                    elimOsc1.stop(audioContext.currentTime + 0.6);
                    elimOsc2.stop(audioContext.currentTime + 0.6);
                    break;
                    
                case 'revive':
                    // Suono di rianimazione celestiale - campane magiche
                    const reviveFreqs = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
                    reviveFreqs.forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.value = freq;
                        osc.type = 'triangle';
                        const delay = i * 0.1;
                        gain.gain.setValueAtTime(0.25, audioContext.currentTime + delay);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + delay + 0.5);
                        osc.start(audioContext.currentTime + delay);
                        osc.stop(audioContext.currentTime + delay + 0.5);
                    });
                    break;
                    
                case 'poker':
                    // Suono di vittoria epico - fanfara orchestrale
                    const victorySequence = [
                        { freq: 523.25, time: 0 },     // C5
                        { freq: 659.25, time: 0.12 },  // E5
                        { freq: 783.99, time: 0.24 },  // G5
                        { freq: 1046.50, time: 0.36 }, // C6
                        { freq: 1318.51, time: 0.48 }  // E6
                    ];
                    
                    victorySequence.forEach(note => {
                        const osc1 = audioContext.createOscillator();
                        const osc2 = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        
                        osc1.connect(gain);
                        osc2.connect(gain);
                        gain.connect(audioContext.destination);
                        
                        osc1.frequency.value = note.freq;
                        osc2.frequency.value = note.freq * 1.5;
                        osc1.type = 'sine';
                        osc2.type = 'triangle';
                        
                        gain.gain.setValueAtTime(0.35, audioContext.currentTime + note.time);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + note.time + 0.4);
                        
                        osc1.start(audioContext.currentTime + note.time);
                        osc2.start(audioContext.currentTime + note.time);
                        osc1.stop(audioContext.currentTime + note.time + 0.4);
                        osc2.stop(audioContext.currentTime + note.time + 0.4);
                    });
                    return;
            }
        }
        
        function screenFlash(type) {
            const flash = document.createElement('div');
            flash.className = `screen-flash ${type}`;
            document.body.appendChild(flash);
            
            setTimeout(() => flash.remove(), 1500);
            
            // Add shake effect for damage
            if (type === 'damage') {
                document.body.classList.add('shake');
                setTimeout(() => document.body.classList.remove('shake'), 500);
            }
        }
        
        function createParticles(x, y, type) {
            const particles = type === 'damage' ? ['üí•', 'üí¢', '‚ö°'] : 
                             type === 'heal' ? ['üíö', '‚ú®', 'üí´'] :
                             ['üåü', '‚ú®', '‚≠ê'];
            
            const count = type === 'revive' ? 12 : 8;
            
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = particles[Math.floor(Math.random() * particles.length)];
                
                const angle = (360 / count) * i;
                const distance = 100 + Math.random() * 50;
                const tx = Math.cos(angle * Math.PI / 180) * distance;
                const ty = Math.sin(angle * Math.PI / 180) * distance;
                
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.setProperty('--tx', tx + 'px');
                particle.style.setProperty('--ty', ty + 'px');
                
                document.body.appendChild(particle);
                
                setTimeout(() => particle.remove(), 1500);
            }
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                if (!gameState.startTime) return;
                
                const elapsed = Date.now() - gameState.startTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                
                document.getElementById('timer').textContent = 
                    `Tempo: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }

        // Master Controls
        function reverseDirection() {
            if (!gameState.isMaster) return;
            
            gameState.direction = gameState.direction === 'clockwise' ? 'counterclockwise' : 'clockwise';
            gameState.history.push('‚≠Æ Direzione invertita');
            
            // ===== OTTIMIZZAZIONE: Aggiorna UI prima, poi singolo update =====
            forceUIUpdate(); // Feedback immediato!
            
            database.ref('games/' + gameState.gameCode).update({ 
                direction: gameState.direction,
                history: gameState.history
            });
        }
        
        function rollbackLastTurn() {
            if (!gameState.isMaster) return;
            
            if (!gameState.previousState) {
                alert('Nessuna azione da annullare!');
                return;
            }
            
            if (!confirm('Vuoi annullare l\'ultima giocata e far ripetere il turno?')) return;
            
            // Restore previous state (HP, turn, effects, direction)
            gameState.players = gameState.previousState.players;
            gameState.currentTurn = gameState.previousState.currentTurn;
            gameState.history = gameState.previousState.history;
            gameState.stats = gameState.previousState.stats;
            gameState.globalEffects = gameState.previousState.globalEffects;
            gameState.direction = gameState.previousState.direction;
            
            gameState.history.push('‚Ü©Ô∏è Ultima giocata annullata dal Master ‚Äì il giocatore ripete il turno');
            
            forceUIUpdate();
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                currentTurn: gameState.currentTurn,
                history: gameState.history,
                stats: gameState.stats,
                globalEffects: gameState.globalEffects,
                direction: gameState.direction
            });
            
            // Clear previous state
            gameState.previousState = null;
        }

        function changeTurn() {
            if (!gameState.isMaster) return;
            
            const nextTurnIndex = parseInt(document.getElementById('next-turn-player').value);
            gameState.currentTurn = nextTurnIndex;
            
            const playerName = gameState.players[nextTurnIndex].name;
            gameState.history.push(`‚è≠Ô∏è Turno cambiato a ${playerName}`);
            
            // ===== OTTIMIZZAZIONE: Aggiorna UI prima, poi singolo update =====
            forceUIUpdate(); // Feedback immediato!
            
            database.ref('games/' + gameState.gameCode).update({ 
                currentTurn: nextTurnIndex,
                history: gameState.history 
            });
        }

        function modifyHP(type) {
            if (!gameState.isMaster) return;
            
            const selectedOptions = document.getElementById('target-players').selectedOptions;
            const amount = parseInt(document.getElementById('hp-amount').value);
            const activatorIndex = parseInt(document.getElementById('damage-activator-select').value);
            
            if (!amount || amount <= 0) {
                alert('Inserisci un valore valido!');
                return;
            }
            
            if (selectedOptions.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            const playerIndices = Array.from(selectedOptions).map(opt => parseInt(opt.value));
            
            if (type === 'damage') {
                // ===== OTTIMIZZAZIONE: Danni manuali veloci senza applyResult =====
                // Il Master applica danni diretti, bypassando le meccaniche complesse
                // Questo √® MOLTO pi√π veloce e d√† feedback immediato
                
                playerIndices.forEach(targetIndex => {
                    const target = gameState.players[targetIndex];
                    const activator = gameState.players[activatorIndex];
                    
                    // BOOMERANG: se il target √® l'attivatore del boomerang, accumula invece di applicare
                    const gfx = gameState.globalEffects;
                    if (gfx.boomerang && targetIndex === gfx.boomerangActivator) {
                        gfx.boomerangDamage = (gfx.boomerangDamage || 0) + amount;
                        gameState.history.push(`ü™É [Boomerang] ${target.name} accumula ${amount} danni manuali (totale: ${gfx.boomerangDamage})`);
                        return;
                    }
                    
                    // CANNONE KARMA: se l'attivatore non √® l'attivatore del karma, subisce i danni anche lui
                    if (gfx.cannoneKarma && activatorIndex !== gfx.cannoneKarmaActivator) {
                        activator.hp = Math.max(0, activator.hp - amount);
                        gameState.history.push(`üí• [Cannone Karma] ${activator.name} subisce ${amount} danni (danno manuale riflesso)`);
                        if (activator.hp === 0 && !activator.isEliminated) {
                            tryEliminatePlayer(activator, `(Cannone Karma)`);
                        }
                    }
                    
                    // Immunit√†
                    if (target.protettoreFato) { gameState.history.push(`üõ°Ô∏è‚ú® [Protettore] ${target.name} immune al danno manuale`); return; }
                    if (target.isImmortal) { gameState.history.push(`‚≠ê ${target.name} √® immortale`); return; }
                    
                    // Mano di Freya - converte in cura
                    if (target.manoFreya) {
                        target.hp += amount;
                        gameState.history.push(`üåø [Mano Freya] ${target.name} cura ${amount} HP`);
                        animateHP(targetIndex, amount);
                        return;
                    }
                    
                    // Volo Fenice - converte in cura x2
                    if (target.voloFenice) {
                        target.hp += amount * 2;
                        gameState.history.push(`ü¶Ö [Fenice] ${target.name} cura ${amount*2} HP`);
                        animateHP(targetIndex, amount * 2);
                        return;
                    }
                    
                    let dmgManuale = amount;
                    
                    // Armatura del Cavaliere - dimezza
                    if (target.armaturaCavaliere) {
                        dmgManuale = Math.floor(dmgManuale / 2);
                        gameState.history.push(`üõ°Ô∏è [Cavaliere] ${target.name}: danno dimezzato ‚Üí ${dmgManuale}`);
                    }
                    
                    // Elmo Maledetto - riflette all'attivatore
                    if (target.elmoMaledetto) {
                        activator.hp = Math.max(0, activator.hp - dmgManuale);
                        gameState.history.push(`‚õëÔ∏è [Elmo] ${activator.name} subisce ${dmgManuale} riflessi`);
                        if (activator.hp === 0 && !activator.isEliminated) tryEliminatePlayer(activator, `(Elmo Maledetto)`);
                    }
                    
                    // Specchio Maledetto - riflette e annulla (uso singolo)
                    if (target.rifletteDanni) {
                        activator.hp = Math.max(0, activator.hp - dmgManuale);
                        target.rifletteDanni = false;
                        if (target.temporaryEffects) target.temporaryEffects.rifletteDanni = false;
                        gameState.history.push(`ü™û [Specchio] ${target.name} riflette ${dmgManuale} su ${activator.name} (consumato)`);
                        if (activator.hp === 0 && !activator.isEliminated) tryEliminatePlayer(activator, `(Specchio)`);
                        animateHP(targetIndex, 0); animateHP(activatorIndex, -dmgManuale);
                        return;
                    }
                    
                    // DOMINO: propaga danno al giocatore successivo (escluso attivatore)
                    if (gfx.domino && targetIndex !== gfx.dominoActivator) {
                        let dominoIdx = targetIndex;
                        let att = 0;
                        do {
                            dominoIdx = gameState.direction === 'clockwise'
                                ? (dominoIdx + 1) % gameState.players.length
                                : (dominoIdx - 1 + gameState.players.length) % gameState.players.length;
                            att++;
                        } while ((gameState.players[dominoIdx].isEliminated || dominoIdx === gfx.dominoActivator || dominoIdx === targetIndex) && att < gameState.players.length);
                        if (att < gameState.players.length && !gameState.players[dominoIdx].isEliminated && dominoIdx !== gfx.dominoActivator) {
                            gameState.players[dominoIdx].hp = Math.max(0, gameState.players[dominoIdx].hp - dmgManuale);
                            gameState.history.push(`üÅ° [Domino] ${gameState.players[dominoIdx].name} subisce ${dmgManuale} danni a catena (manuale)!`);
                            if (gameState.players[dominoIdx].hp === 0 && !gameState.players[dominoIdx].isEliminated) {
                                tryEliminatePlayer(gameState.players[dominoIdx], `(Domino manuale)`, false, dmgManuale);
                            }
                        }
                    }
                    
                    // Applica danno effettivo al target
                    target.hp = Math.max(0, target.hp - dmgManuale);
                    
                    // Controlla eliminazione con resurrezione
                    if (target.hp === 0 && !target.isEliminated) {
                        tryEliminatePlayer(target, `(Danno manuale da ${activator.name})`, true, dmgManuale);
                    } else {
                        playSound('hit');
                    }
                    
                    // Animazione
                    animateHP(targetIndex, -dmgManuale);
                    
                    // History
                    gameState.history.push(`üéØ [Master] ${activator.name} infligge ${dmgManuale} danni manuali a ${target.name}${dmgManuale !== amount ? ` (originale: ${amount})` : ''}`);
                });
                
                // Limita history
                if (gameState.history.length > 50) {
                    gameState.history = gameState.history.slice(-50);
                }
                
                // ===== AGGIORNAMENTO OTTIMISTICO: UI prima, Firebase dopo =====
                forceUIUpdate(); // Feedback IMMEDIATO!
                
                // Update Firebase in background (singolo update per tutti i target)
                database.ref('games/' + gameState.gameCode).update({
                    players: gameState.players,
                    history: gameState.history
                });
            } else {
                // CURE - funzionamento normale (non attiva effetti)
                playerIndices.forEach(playerIndex => {
                    const player = gameState.players[playerIndex];
                    player.hp += amount;
                    gameState.history.push(`üíö ${player.name} recupera ${amount} HP (Master)`);
                    animateHP(playerIndex, amount);
                    playSound('heal');
                });
                
                // ===== OTTIMIZZAZIONE: Aggiorna UI PRIMA di Firebase =====
                forceUIUpdate(); // Feedback immediato!
                
                // Poi invia a Firebase in background
                database.ref('games/' + gameState.gameCode).update({
                    players: gameState.players,
                    history: gameState.history
                });
            }
            
            // Clear input
            document.getElementById('hp-amount').value = '';
        }

        function revivePlayer() {
            if (!gameState.isMaster) return;
            
            const selectedOptions = document.getElementById('target-players').selectedOptions;
            
            if (selectedOptions.length === 0) {
                alert('Seleziona almeno un giocatore da rianimare!');
                return;
            }
            
            const playerIndices = Array.from(selectedOptions).map(opt => parseInt(opt.value));
            
            playerIndices.forEach(playerIndex => {
                const player = gameState.players[playerIndex];
                
                if (!player.isEliminated) {
                    return; // Skip non-eliminated players
                }
                
                player.isEliminated = false;
                player.hp = 20;
                
                animateHP(playerIndex, 20);
                gameState.history.push(`üîÑ ${player.name} √® stato rianimato con 20 HP`);
            });
            
            playSound('revive');
            screenFlash('revive');
            createParticles(window.innerWidth / 2, window.innerHeight / 2, 'revive');
            
            // ===== OTTIMIZZAZIONE: Aggiorna UI prima di Firebase =====
            forceUIUpdate(); // Feedback immediato!
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function endGame() {
            if (!gameState.isMaster) return;
            
            if (!confirm('Sei sicuro di voler terminare la partita? Verr√† mostrato il vincitore e poi potrai resettare.')) return;
            
            const sorted = [...gameState.players].sort((a, b) => b.hp - a.hp);
            const winner = sorted[0];
            
            gameState.history.push(`üèÅ Partita terminata. Vincitore: ${winner.name} con ${winner.hp} HP`);
            
            database.ref('games/' + gameState.gameCode).update({
                history: gameState.history,
                gameEnded: true,
                winner: winner.name
            });
        }

        function swapHP(source) {
            if (!gameState.isMaster) return;
            
            const suffix = source === 'fato' ? '-fato' : '';
            const player1Index = parseInt(document.getElementById('swap-player-1' + suffix).value);
            const player2Index = parseInt(document.getElementById('swap-player-2' + suffix).value);
            
            if (isNaN(player1Index) || isNaN(player2Index) || player1Index === player2Index) {
                alert('Seleziona due giocatori diversi!');
                return;
            }
            
            const player1 = gameState.players[player1Index];
            const player2 = gameState.players[player2Index];
            
            // Swap HP values
            const tempHP = player1.hp;
            player1.hp = player2.hp;
            player2.hp = tempHP;
            
            gameState.history.push(`üîÑ ${player1.name} e ${player2.name} hanno scambiato HP (${player2.hp} ‚Üî ${player1.hp})`);
            
            // Animate both players
            animateHP(player1Index, 0);
            animateHP(player2Index, 0);
            
            forceUIUpdate();
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function newGame() {
            if (!gameState.isMaster) return;
            
            if (!confirm('Vuoi resettare la partita? Tutti gli HP e gli effetti saranno ripristinati. Nessuno verr√† disconnesso.')) return;
            
            // Remove any winner notification overlay
            document.querySelectorAll('.winner-notification, .hit-overlay').forEach(el => el.remove());
            
            // Use the initial HP that was set when the game was created
            const resetHP = gameState.initialHP || 70;
            
            // Reset all players - HP + TUTTI GLI EFFETTI (keep name, isMaster, connected)
            gameState.players.forEach(player => {
                player.hp = resetHP;
                player.isEliminated = false;
                player.extraTurns = 0;
                // Reset effetti individuali
                player.isImmortal = false;
                player.multiplier = 1;
                player.multiplierAppliedBy = null;
                player.skipTurn = false;
                player.customDiceCount = null;
                player.krakenMark = false;
                player.krakenMarkThreshold = 10;
                player.checkmateHP = null;
                player.damageToHeal = false;
                player.sunArmor = false;
                player.moonArmor = false;
                player.mareGuai = false;
                player.voloFenice = false;
                player.cactusAmari = false;
                player.catenaMaledetta = false;
                player.rifletteDanni = false;
                player.talismanRa = false;
                player.talismanRaValues = [];
                player.dadoAvvelenato = false;
                player.dadoAvvelenatotValues = [];
                player.interferenza = false;
                player.interferenzaPartner = null;
                player.cantoDelCigno = false;
                player.pattoDiavolo = false;
                player.pattoDiavoloUsed = false;
                player.tombaTutankhamon = false;
                player.reincarnazione = false;
                player.reincarnazioneUsed = false;
                player.boiaEsecutore = false;
                player.boiaEsecutoreTurns = 0;
                // Reset effetti temporanei
                player.temporaryEffects = {
                    immortal: false,
                    multiplier: false,
                    skipTurn: false,
                    customDice: false,
                    damageToHeal: false,
                    sunArmor: false,
                    moonArmor: false,
                    mareGuai: false,
                    voloFenice: false,
                    cactusAmari: false,
                    catenaMaledetta: false,
                    rifletteDanni: false,
                elmoMaledetto: false,
                manoFreya: false,
                armaturaCavaliere: false,
                    talismanRa: false,
                    dadoAvvelenato: false
                };
            });
            
            // Reset TUTTI gli effetti globali
            gameState.globalEffects = {
                cessateFuoco: false,
                cessateFuocoActivator: null,
                pariPazzo: false,
                pariPazzoActivator: null,
                pioggiaAcida: false,
                pioggiaAcidaActivator: null,
                cannoneKarma: false,
                cannoneKarmaActivator: null,
                bambolaVoodoo: false,
                bambolaVoodooActivator: null,
                capsulaRigenerativa: false,
                capsulaRigenerativaActivator: null,
                saldiEstivi: false,
                saldiEstiviActivator: null,
                giocoPulito: false,
                giocoPulitoActivator: null,
                altaMarea: false,
                altaMareaActivator: null,
                zebratura: false,
                zebraturaActivator: null,
                boomerang: false,
                boomerangActivator: null,
                boomerangDamage: 0,
                armaturaSpecchio: false,
                armaturaSpecchioActivator: null,
                sabbieMobili: false,
                sabbieMobiliActivator: null,
                contagio: false,
                contagioActivator: null,
                domino: false,
                dominoActivator: null,
                treMolio: false,
                treMolioActivator: null,
                nirvana: false,
                nirvanaActivator: null,
                toccaAMe: false,
                toccaAMeActivator: null,
                toccaAMeTarget: null,
                toccaAMeRedirectFrom: null,
                distorsione: false,
                distorsioneActivator: null,
                distorsioneTurnsLeft: 0
            };
            
            // Reset game state
            gameState.currentTurn = 0;
            gameState.direction = 'clockwise';
            gameState.history = ['üéÆ Partita resettata! Tutti gli HP e gli effetti sono stati ripristinati.'];
            gameState.startTime = Date.now();
            gameState.stats = {};
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                globalEffects: gameState.globalEffects,
                currentTurn: 0,
                direction: 'clockwise',
                history: gameState.history,
                startTime: gameState.startTime,
                gameEnded: false,
                winner: null,
                stats: gameState.stats
            });
            
            // Restart timer
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            startTimer();
        }
        
        function showQRModal() {
            if (!gameState.isMaster) return;
            
            const selectedIndex = parseInt(document.getElementById('qr-player-select').value);
            const selectedPlayer = gameState.players[selectedIndex];
            
            if (!selectedPlayer) {
                alert('Seleziona un giocatore!');
                return;
            }
            
            const modal = document.getElementById('qr-modal');
            const qrcodeContainer = document.getElementById('qrcode-modal');
            const gameCodeDisplay = document.getElementById('modal-game-code');
            
            // Clear previous QR code
            qrcodeContainer.innerHTML = '';
            
            // Generate new QR code with player name
            const gameUrl = window.location.origin + window.location.pathname + '?game=' + gameState.gameCode + '&player=' + encodeURIComponent(selectedPlayer.name);
            new QRCode(qrcodeContainer, {
                text: gameUrl,
                width: 256,
                height: 256,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
            
            // Display game code and player name
            gameCodeDisplay.textContent = gameState.gameCode + ' - ' + selectedPlayer.name;
            
            // Show modal
            modal.classList.add('show');
        }
        
        function closeQRModal() {
            const modal = document.getElementById('qr-modal');
            modal.classList.remove('show');
        }
        
        function toggleImmortality() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('immortal-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            // Toggle immortality for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.isImmortal = !player.isImmortal;
                
                // Mark as temporary effect
                if (!player.temporaryEffects) {
                    player.temporaryEffects = {};
                }
                player.temporaryEffects.immortal = player.isImmortal;
            });
            
            // Update Firebase
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].isImmortal ? 'attivata' : 'disattivata';
            gameState.history.push(`‚≠ê Immortalit√† ${status} per: ${playerNames} (temp)`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }
        
        function setMultiplier(multiplierValue) {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('multiplier-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            // Set multiplier for selected players
            const currentPlayerIndex = gameState.currentTurn;
            
            let alreadyHasMultiplier = [];
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                if (player.multiplier !== 1) {
                    alreadyHasMultiplier.push(player.name);
                }
                player.multiplier = multiplierValue;
                player.multiplierAppliedBy = currentPlayerIndex; // Salva chi ha applicato il moltiplicatore
                
                // Mark as temporary effect
                if (!player.temporaryEffects) {
                    player.temporaryEffects = {};
                }
                player.temporaryEffects.multiplier = true;
            });
            
            // Avvisa se alcuni giocatori avevano gi√† un moltiplicatore
            if (alreadyHasMultiplier.length > 0) {
                gameState.history.push(`‚ö†Ô∏è Moltiplicatore precedente sovrascritto per: ${alreadyHasMultiplier.join(', ')}`);
            }
            
            // Update Firebase
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const applierName = gameState.players[currentPlayerIndex].name;
            const multiplierText = multiplierValue === 0.5 ? '0.5 (met√† danni)' : '2 (danni doppi)';
            gameState.history.push(`‚ú® ${applierName} applica moltiplicatore x${multiplierText} a: ${playerNames} (fino al suo prossimo turno)`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }
        
        function removeMultiplier() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('multiplier-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            // Remove multiplier (set to 1) for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.multiplier = 1;
                player.multiplierAppliedBy = null;
                if (player.temporaryEffects) {
                    player.temporaryEffects.multiplier = false;
                }
            });
            
            // Update Firebase
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            gameState.history.push(`‚ùå Moltiplicatore rimosso per: ${playerNames}`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }
        
        function toggleSkipTurn() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('skip-turn-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            // Toggle skip turn for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.skipTurn = !player.skipTurn;
                
                // Mark as temporary effect
                if (!player.temporaryEffects) {
                    player.temporaryEffects = {};
                }
                player.temporaryEffects.skipTurn = player.skipTurn;
            });
            
            // Update Firebase
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].skipTurn ? 'attivato' : 'disattivato';
            gameState.history.push(`‚è≠Ô∏è Salta turno ${status} per: ${playerNames}`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }
        
        function setCustomDice() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('custom-dice-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            const diceValue = parseInt(document.getElementById('custom-dice-value').value);
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            if (!diceValue || diceValue < 1 || diceValue > 6) {
                alert('Inserisci un numero di dadi valido (1-6)!');
                return;
            }
            
            // Set custom dice for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.customDiceCount = diceValue;
                
                // Mark as temporary effect
                if (!player.temporaryEffects) {
                    player.temporaryEffects = {};
                }
                player.temporaryEffects.customDice = true;
            });
            
            // Update Firebase
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            gameState.history.push(`üé≤ Dadi personalizzati (${diceValue}) assegnati a: ${playerNames} (temp)`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }
        
        function removeCustomDice() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('custom-dice-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            // Remove custom dice for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.customDiceCount = null;
                if (player.temporaryEffects) {
                    player.temporaryEffects.customDice = false;
                }
            });
            
            // Update Firebase
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            gameState.history.push(`‚ùå Dadi personalizzati rimossi per: ${playerNames}`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }
        
        function resetTemporaryEffects(playerIndex) {
            const player = gameState.players[playerIndex];
            if (!player || !player.temporaryEffects) return;
            
            let resetMessage = [];
            
            // Reset immortality if temporary (only for the player who just played)
            if (player.temporaryEffects.immortal && player.isImmortal) {
                player.isImmortal = false;
                resetMessage.push('immortalit√†');
            }
            
            // Reset this player's own multiplier if it's marked as temporary (but NOT reincarnazione permanent multiplier)
            if (player.temporaryEffects.multiplier && player.multiplier !== 1 && !player.reincarnazioneMultiplier) {
                player.multiplier = 1;
                player.multiplierAppliedBy = null;
                resetMessage.push('moltiplicatore');
            }
            
            // Also clear any lingering cross-player multiplier (safety net)
            gameState.players.forEach((p, index) => {
                if (index !== playerIndex && p.multiplierAppliedBy === playerIndex && p.multiplier !== 1) {
                    if (p.temporaryEffects && !p.temporaryEffects.multiplier) {
                        // Only reset if not already handled by own reset
                        p.multiplier = 1;
                        p.multiplierAppliedBy = null;
                        resetMessage.push(`moltiplicatore (${p.name})`);
                    }
                }
            });
            
            // Reset skip turn if temporary (but only after it was skipped)
            // Skip turn will be handled separately in getNextActiveTurn
            
            // Reset custom dice if temporary (only for the player who just played)
            // ECCEZIONE: Non resettare se Patto Diavolo √® stato usato (2 dadi permanenti)
            if (player.temporaryEffects.customDice && player.customDiceCount) {
                if (!player.pattoDiavoloUsed) {
                    player.customDiceCount = null;
                    resetMessage.push('dadi personalizzati');
                }
                // Se pattoDiavoloUsed = true, mantieni customDiceCount = 2 per sempre
            }
            
            // Reset damage-to-heal if temporary
            if (player.temporaryEffects.damageToHeal && player.damageToHeal) {
                player.damageToHeal = false;
                resetMessage.push('conversione danni‚Üícure');
            }
            
            // Reset sun armor if temporary
            if (player.temporaryEffects.sunArmor && player.sunArmor) {
                player.sunArmor = false;
                resetMessage.push('armatura del sole');
            }
            
            // Reset moon armor if temporary
            if (player.temporaryEffects.moonArmor && player.moonArmor) {
                player.moonArmor = false;
                resetMessage.push('armatura della luna');
            }
            
            // Reset nuove meccaniche temporanee
            if (player.temporaryEffects.mareGuai && player.mareGuai) {
                player.mareGuai = false;
                resetMessage.push('mare di guai');
            }
            if (player.temporaryEffects.voloFenice && player.voloFenice) {
                player.voloFenice = false;
                resetMessage.push('volo della fenice');
            }
            if (player.temporaryEffects.cactusAmari && player.cactusAmari) {
                player.cactusAmari = false;
                resetMessage.push('cactus amari');
            }
            if (player.temporaryEffects.catenaMaledetta && player.catenaMaledetta) {
                player.catenaMaledetta = false;
                resetMessage.push('catena maledetta');
            }
            if (player.temporaryEffects.rifletteDanni && player.rifletteDanni) {
                player.rifletteDanni = false;
                resetMessage.push('specchio maledetto');
            }
            if (player.temporaryEffects.elmoMaledetto && player.elmoMaledetto) {
                player.elmoMaledetto = false;
                resetMessage.push('elmo maledetto');
            }
            if (player.temporaryEffects.manoFreya && player.manoFreya) {
                player.manoFreya = false;
                resetMessage.push('mano di freya');
            }
            if (player.temporaryEffects.armaturaCavaliere && player.armaturaCavaliere) {
                player.armaturaCavaliere = false;
                resetMessage.push('armatura cavaliere');
            }
            if (player.temporaryEffects.talismanRa && player.talismanRa) {
                player.talismanRa = false;
                player.talismanRaValues = [];
                resetMessage.push('talismano di ra');
            }
            if (player.temporaryEffects.dadoAvvelenato && player.dadoAvvelenato) {
                player.dadoAvvelenato = false;
                player.dadoAvvelenatotValues = [];
                resetMessage.push('dado avvelenato');
            }
            if (player.interferenza) {
                player.interferenza = false;
                player.interferenzaPartner = null;
                resetMessage.push('interferenza');
            }
            if (player.temporaryEffects.protettoreFato && player.protettoreFato) {
                player.protettoreFato = false;
                resetMessage.push('protettore del fato');
            }
            
            // Reset effetti globali se questo giocatore √® l'attivatore
            let globalReset = [];
            const gfx = gameState.globalEffects;
            
            if (gfx.cessateFuocoActivator === playerIndex && gfx.cessateFuoco) {
                gfx.cessateFuoco = false;
                gfx.cessateFuocoActivator = null;
                globalReset.push('cessate il fuoco');
            }
            if (gfx.pariPazzoActivator === playerIndex && gfx.pariPazzo) {
                gfx.pariPazzo = false;
                gfx.pariPazzoActivator = null;
                globalReset.push('pari pazzo');
            }
            if (gfx.bambolaVoodooActivator === playerIndex && gfx.bambolaVoodoo) {
                gfx.bambolaVoodoo = false;
                gfx.bambolaVoodooActivator = null;
                globalReset.push('bambola voodoo');
            }
            if (gfx.cannoneKarmaActivator === playerIndex && gfx.cannoneKarma) {
                gfx.cannoneKarma = false;
                gfx.cannoneKarmaActivator = null;
                globalReset.push('cannone karma');
            }
            if (gfx.pioggiaAcidaActivator === playerIndex && gfx.pioggiaAcida) {
                gfx.pioggiaAcida = false;
                gfx.pioggiaAcidaActivator = null;
                globalReset.push('pioggia acida');
            }
            if (gfx.capsulaRigenerativaActivator === playerIndex && gfx.capsulaRigenerativa) {
                gfx.capsulaRigenerativa = false;
                gfx.capsulaRigenerativaActivator = null;
                globalReset.push('capsula rigenerativa');
            }
            if (gfx.saldiEstiviActivator === playerIndex && gfx.saldiEstivi) {
                gfx.saldiEstivi = false;
                gfx.saldiEstiviActivator = null;
                globalReset.push('saldi estivi');
            }
            if (gfx.giocoPulitoActivator === playerIndex && gfx.giocoPulito) {
                gfx.giocoPulito = false;
                gfx.giocoPulitoActivator = null;
                globalReset.push('gioco pulito');
            }
            if (gfx.altaMareaActivator === playerIndex && gfx.altaMarea) {
                gfx.altaMarea = false;
                gfx.altaMareaActivator = null;
                globalReset.push('alta marea');
            }
            if (gfx.zebraturaActivator === playerIndex && gfx.zebratura) {
                gfx.zebratura = false;
                gfx.zebraturaActivator = null;
                globalReset.push('zebratura');
            }
            // Boomerang payout √® gestito in calculateDice() all'inizio del turno dell'attivatore
            if (gfx.armaturaSpecchioActivator === playerIndex && gfx.armaturaSpecchio) {
                gfx.armaturaSpecchio = false;
                gfx.armaturaSpecchioActivator = null;
                globalReset.push('armatura specchio');
            }
            if (gfx.sabbieMobiliActivator === playerIndex && gfx.sabbieMobili) {
                gfx.sabbieMobili = false;
                gfx.sabbieMobiliActivator = null;
                globalReset.push('sabbie mobili');
            }
            if (gfx.dominoActivator === playerIndex && gfx.domino) {
                gfx.domino = false;
                gfx.dominoActivator = null;
                globalReset.push('domino');
            }
            if (gfx.treMolioActivator === playerIndex && gfx.treMolio) {
                gfx.treMolio = false;
                gfx.treMolioActivator = null;
                globalReset.push('3 molio');
            }
            if (gfx.nirvanaActivator === playerIndex && gfx.nirvana) {
                gfx.nirvana = false;
                gfx.nirvanaActivator = null;
                globalReset.push('nirvana');
            }
            if (gfx.minotauroCorretoActivator === playerIndex && gfx.minotauroCorreto) {
                gfx.minotauroCorreto = false;
                gfx.minotauroCorretoActivator = null;
                globalReset.push('minotauro corrotto');
            }
            if (gfx.trollFaceActivator === playerIndex && gfx.trollFace) {
                gfx.trollFace = false;
                gfx.trollFaceActivator = null;
                gfx.trollFaceValue = null;
                globalReset.push('troll face');
            }
            
            // Decrementa turni 7 Bello
            if (gfx.setteBello && gfx.setteBelloActivator === playerIndex) {
                gfx.setteBelloTurnsLeft--;
                if (gfx.setteBelloTurnsLeft <= 0) {
                    gfx.setteBello = false;
                    gfx.setteBelloActivator = null;
                    gfx.setteBelloTurnsLeft = 0;
                    gameState.history.push(`üé∞ [7 Bello] Effetto scaduto per ${player.name} - non ha fatto 7 in tempo`);
                    globalReset.push('7 bello');
                }
            }
            
            // DISTORSIONE SPAZIO-TEMPORALE: decrementa al turno dell'attivatore
            if (gfx.distorsione && gfx.distorsioneActivator === playerIndex) {
                gfx.distorsioneTurnsLeft--;
                gameState.history.push(`‚è≥üåÄ [Distorsione] ${player.name} ha giocato il turno ${3 - gfx.distorsioneTurnsLeft}/3`);
                if (gfx.distorsioneTurnsLeft <= 0) {
                    gameState.history.push(`‚è≥üåÄ [Distorsione Spazio-Temporale] TEMPO SCADUTO! La partita termina ora!`);
                    gfx.distorsione = false;
                    gfx.distorsioneActivator = null;
                    gfx.distorsioneTurnsLeft = 0;
                    // Forza fine partita
                    const winner = determineWinner();
                    if (winner) {
                        database.ref('games/' + gameState.gameCode).update({
                            players: gameState.players, globalEffects: gfx,
                            history: gameState.history, gameEnded: true, winner: winner.name
                        });
                        showWinnerNotification(winner.name, winner.name === gameState.playerName);
                        return;
                    }
                }
            }
            
            if (globalReset.length > 0) {
                gameState.history.push(`‚è±Ô∏è Effetti globali terminati: ${globalReset.join(', ')}`);
            }
            
            // Decrementa turni Boia Esecutore
            if (player.boiaEsecutore && player.boiaEsecutoreTurns > 0) {
                player.boiaEsecutoreTurns--;
                if (player.boiaEsecutoreTurns === 0) {
                    player.boiaEsecutore = false;
                    gameState.history.push(`ü™ì Boia Esecutore terminato per ${player.name}`);
                }
            }
            
            // Clear temporary flags for the player who just played
            player.temporaryEffects = {
                immortal: false,
                multiplier: false,
                skipTurn: player.temporaryEffects.skipTurn,
                customDice: false,
                damageToHeal: false,
                sunArmor: false,
                moonArmor: false,
                mareGuai: false,
                voloFenice: false,
                cactusAmari: false,
                catenaMaledetta: false,
                rifletteDanni: false,
                elmoMaledetto: false,
                manoFreya: false,
                armaturaCavaliere: false,
                talismanRa: false,
                dadoAvvelenato: false
            };
            
            // Add history message if something was reset for this player
            if (resetMessage.length > 0) {
                gameState.history.push(`‚è±Ô∏è ${player.name}: reset ${resetMessage.join(', ')}`);
            }
        }
        
        function toggleKrakenMark() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('kraken-mark-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            // Toggle kraken mark for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.krakenMark = !player.krakenMark;
            });
            
            // Update Firebase
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].krakenMark ? 'applicato' : 'rimosso';
            gameState.history.push(`üêô Marchio del Kraken ${status} a: ${playerNames}`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }
        
        function setCheckmate() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('checkmate-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            const checkmateValue = parseInt(document.getElementById('checkmate-value').value);
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            if (!checkmateValue || checkmateValue < 1 || checkmateValue > 100) {
                alert('Inserisci un valore HP valido (1-100)!');
                return;
            }
            
            // Set checkmate for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.checkmateHP = checkmateValue;
            });
            
            // Update Firebase
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            gameState.history.push(`‚ôüÔ∏è Scacco Matto (${checkmateValue} HP) applicato a: ${playerNames}`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }
        
        function removeCheckmate() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('checkmate-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            // Remove checkmate for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.checkmateHP = null;
            });
            
            // Update Firebase
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            gameState.history.push(`‚ùå Scacco Matto rimosso da: ${playerNames}`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }
        
        function toggleDamageToHeal() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('damage-to-heal-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.damageToHeal = !player.damageToHeal;
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.damageToHeal = player.damageToHeal;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].damageToHeal ? 'attivata' : 'disattivata';
            gameState.history.push(`üí´ Conversione Danni‚ÜíCure ${status} per: ${playerNames} (temp)`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }
        
        function toggleSunArmor() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('sun-armor-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.sunArmor = !player.sunArmor;
                // CONFLITTO: Se attivo Sole, disattivo Luna
                if (player.sunArmor && player.moonArmor) {
                    player.moonArmor = false;
                    if (player.temporaryEffects) player.temporaryEffects.moonArmor = false;
                    gameState.history.push(`‚ö†Ô∏è Armatura della Luna disattivata per ${player.name} (conflitto con Armatura del Sole)`);
                }
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.sunArmor = player.sunArmor;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].sunArmor ? 'indossata' : 'rimossa';
            gameState.history.push(`‚òÄÔ∏è Armatura del Sole ${status} da: ${playerNames} (temp)`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }
        
        function toggleMoonArmor() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('moon-armor-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.moonArmor = !player.moonArmor;
                // CONFLITTO: Se attivo Luna, disattivo Sole
                if (player.moonArmor && player.sunArmor) {
                    player.sunArmor = false;
                    if (player.temporaryEffects) player.temporaryEffects.sunArmor = false;
                    gameState.history.push(`‚ö†Ô∏è Armatura del Sole disattivata per ${player.name} (conflitto con Armatura della Luna)`);
                }
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.moonArmor = player.moonArmor;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].moonArmor ? 'indossata' : 'rimossa';
            gameState.history.push(`üåô Armatura della Luna ${status} da: ${playerNames} (temp)`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }
    
        
        // ========== FUNZIONI CALCOLATRICE E STRUMENTI ==========
        
        function calculateExpression() {
            const input = document.getElementById('calc-input').value.trim();
            const resultDiv = document.getElementById('calc-result');
            
            if (!input) {
                alert('Inserisci un\'espressione da calcolare!');
                return;
            }
            
            try {
                const cleanInput = input.replace(/\s+/g, '');
                if (!/^[\d+\-*/().]+$/.test(cleanInput)) {
                    throw new Error('Caratteri non validi nell\'espressione');
                }
                
                const numbers = cleanInput.split(/[+\-*/()]/).filter(n => n !== '');
                if (numbers.length > 20) {
                    throw new Error('Troppi numeri! Massimo 20 numeri consentiti');
                }
                
                const result = eval(cleanInput);
                resultDiv.style.display = 'block';
                resultDiv.textContent = `Risultato: ${result}`;
                
                if (gameState.isMaster) {
                    gameState.history.push(`üßÆ Calcolo: ${input} = ${result}`);
                    database.ref('games/' + gameState.gameCode).update({ history: gameState.history });
                }
            } catch (error) {
                resultDiv.style.display = 'block';
                resultDiv.textContent = `Errore: ${error.message}`;
                resultDiv.style.color = '#ff0000';
                setTimeout(() => {
                    resultDiv.style.color = '#00ffff';
                }, 2000);
            }
        }

        function clearCalculator() {
            document.getElementById('calc-input').value = '';
            document.getElementById('calc-result').style.display = 'none';
        }

        function calculateTargetOnly() {
            const dice1 = parseInt(document.getElementById('tcalc-dice-0').value);
            const dice2 = parseInt(document.getElementById('tcalc-dice-1').value);
            const dice3 = parseInt(document.getElementById('tcalc-dice-2').value);
            const selectedDirection = document.getElementById('target-calc-direction').value;
            const resultDiv = document.getElementById('target-calc-result');
            
            // Use selected attivatore, fallback to currentTurn
            const attivatoreEl = document.getElementById('target-calc-attivatore');
            const shooterIdx = attivatoreEl && attivatoreEl.value !== '' ? parseInt(attivatoreEl.value) : gameState.currentTurn;
            
            const diceValues = [];
            if (dice1 >= 1 && dice1 <= 6) diceValues.push(dice1);
            if (dice2 >= 1 && dice2 <= 6) diceValues.push(dice2);
            if (dice3 >= 1 && dice3 <= 6) diceValues.push(dice3);
            
            if (diceValues.length === 0) {
                alert('Inserisci almeno un dado valido (1-6)!');
                return;
            }
            
            const sum = diceValues.reduce((a, b) => a + b, 0);
            const targetInfo = findTargetInfo(sum, shooterIdx, selectedDirection);
            const shooterName = gameState.players[shooterIdx]?.name || '?';
            
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = `
                <div style="font-size: 0.9em; color:#94a3b8; margin-bottom:4px;">Attivatore: <strong style="color:#facc15;">${shooterName}</strong></div>
                <div style="font-size: 1.1em; margin-bottom: 8px;">
                    Dadi: ${diceValues.join(', ')} = <strong>${sum}</strong>
                </div>
                <div style="color: #00ff88; font-size: 1.2em;">
                    üéØ Bersaglio: <strong>${targetInfo.targetName}</strong>
                </div>
                <div style="font-size: 0.9em; margin-top: 8px; opacity: 0.8;">
                    (${targetInfo.position}¬∞ giocatore attivo in senso ${selectedDirection === 'clockwise' ? 'orario' : 'antiorario'})
                </div>
            `;
            
            if (gameState.isMaster) {
                const directionText = selectedDirection === 'clockwise' ? 'orario' : 'antiorario';
                gameState.history.push(`üéØ Calcolo bersaglio di ${shooterName} (${directionText}): ${diceValues.join(',')} = ${sum} ‚Üí ${targetInfo.targetName}`);
                database.ref('games/' + gameState.gameCode).update({ history: gameState.history });
            }
        }

        function findTargetInfo(sum, shooterIndex, direction = null) {
            const activePlayers = gameState.players
                .map((p, i) => ({ player: p, index: i }))
                .filter(({ player, index }) => !player.isEliminated && index !== shooterIndex);

            if (activePlayers.length === 0) return { targetName: 'Nessuno', position: 0 };

            let count = sum % activePlayers.length;
            if (count === 0) count = activePlayers.length;

            // Usa la direzione passata come parametro, altrimenti usa quella di gameState
            const actualDirection = direction || gameState.direction;
            
            let sorted;
            if (actualDirection === 'clockwise') {
                sorted = [...activePlayers].sort((a, b) => {
                    const aAfter = a.index > shooterIndex ? a.index : a.index + 1000;
                    const bAfter = b.index > shooterIndex ? b.index : b.index + 1000;
                    return aAfter - bAfter;
                });
            } else {
                sorted = [...activePlayers].sort((a, b) => {
                    const aBefore = a.index < shooterIndex ? a.index : a.index - 1000;
                    const bBefore = b.index < shooterIndex ? b.index : b.index - 1000;
                    return bBefore - aBefore;
                });
            }

            const targetPos = (count - 1) % sorted.length;
            const target = sorted[targetPos];

            return {
                targetName: target.player.name,
                position: count,
                targetIndex: target.index
            };
        }

        // ========== MECCANICHE GLOBALI ==========
        
        function toggleCessateFuoco() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('cessate-fuoco-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            
            gameState.globalEffects.cessateFuoco = !gameState.globalEffects.cessateFuoco;
            
            if (gameState.globalEffects.cessateFuoco) {
                // Disattiva Zebratura se attiva (conflitto)
                if (gameState.globalEffects.zebratura) {
                    gameState.globalEffects.zebratura = false;
                    gameState.globalEffects.zebraturaActivator = null;
                    gameState.history.push(`‚ö†Ô∏è Zebratura disattivata (conflitto con Cessate il Fuoco)`);
                }
                gameState.globalEffects.cessateFuocoActivator = activatorIndex;
                gameState.history.push(`üïäÔ∏è Cessate il Fuoco attivato per 1 turno completo! Attivatore: ${gameState.players[activatorIndex].name}`);
            } else {
                gameState.globalEffects.cessateFuocoActivator = null;
                gameState.history.push(`üïäÔ∏è Cessate il Fuoco disattivato`);
            }
            
            forceUIUpdate(); // FASE 2: Feedback immediato toggle ‚ö°
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function togglePariPazzo() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('pari-pazzo-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            gameState.globalEffects.pariPazzo = !gameState.globalEffects.pariPazzo;
            
            if (gameState.globalEffects.pariPazzo) {
                gameState.globalEffects.pariPazzoActivator = activatorIndex;
                gameState.history.push(`üé≤ Di Pari Pazzo attivato per 1 turno completo! Attivatore: ${gameState.players[activatorIndex].name}`);
            } else {
                gameState.globalEffects.pariPazzoActivator = null;
                gameState.history.push(`üé≤ Di Pari Pazzo disattivato`);
            }
            
            forceUIUpdate(); // FASE 2: Feedback immediato toggle ‚ö°
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function toggleBambolaVoodoo() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('bambola-voodoo-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            gameState.globalEffects.bambolaVoodoo = !gameState.globalEffects.bambolaVoodoo;
            
            if (gameState.globalEffects.bambolaVoodoo) {
                gameState.globalEffects.bambolaVoodooActivator = activatorIndex;
                gameState.history.push(`ü™Ü Bambola Voodoo attivata! Attivatore (immune): ${gameState.players[activatorIndex].name} ‚Äì fino al suo prossimo turno i giocatori fanno danni a s√© stessi`);
            } else {
                gameState.globalEffects.bambolaVoodooActivator = null;
                gameState.history.push(`ü™Ü Bambola Voodoo disattivata`);
            }
            
            forceUIUpdate();
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function toggleCannoneKarma() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('cannone-karma-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            gameState.globalEffects.cannoneKarma = !gameState.globalEffects.cannoneKarma;
            
            if (gameState.globalEffects.cannoneKarma) {
                gameState.globalEffects.cannoneKarmaActivator = activatorIndex;
                gameState.history.push(`üí• Cannone del Karma attivato per 1 turno completo (escluso attivatore)! Attivatore: ${gameState.players[currentPlayerIndex].name}`);
            } else {
                gameState.globalEffects.cannoneKarmaActivator = null;
                gameState.history.push(`üí• Cannone del Karma disattivato`);
            }
            
            forceUIUpdate(); // FASE 2: Feedback immediato toggle ‚ö°
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function togglePioggiaAcida() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('pioggia-acida-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            gameState.globalEffects.pioggiaAcida = !gameState.globalEffects.pioggiaAcida;
            
            if (gameState.globalEffects.pioggiaAcida) {
                gameState.globalEffects.pioggiaAcidaActivator = activatorIndex;
                gameState.history.push(`‚òî Pioggia Acida attivata! Attivatore (immune): ${gameState.players[activatorIndex].name} ‚Äì fino al suo prossimo turno il dado pi√π alto infligge danni a tutti`);
            } else {
                gameState.globalEffects.pioggiaAcidaActivator = null;
                gameState.history.push(`‚òî Pioggia Acida disattivata`);
            }
            
            forceUIUpdate();
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function toggleCapsulaRigenerativa() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('capsula-rigenerativa-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            gameState.globalEffects.capsulaRigenerativa = !gameState.globalEffects.capsulaRigenerativa;
            
            if (gameState.globalEffects.capsulaRigenerativa) {
                // Disattiva Zebratura se attiva (conflitto)
                if (gameState.globalEffects.zebratura) {
                    gameState.globalEffects.zebratura = false;
                    gameState.globalEffects.zebraturaActivator = null;
                    gameState.history.push(`‚ö†Ô∏è Zebratura disattivata (conflitto con Capsula Rigenerativa)`);
                }
                gameState.globalEffects.capsulaRigenerativaActivator = activatorIndex;
                gameState.history.push(`üíä Capsula Rigenerativa attivata per 1 turno completo (incluso attivatore)! Attivatore: ${gameState.players[activatorIndex].name}`);
            } else {
                gameState.globalEffects.capsulaRigenerativaActivator = null;
                gameState.history.push(`üíä Capsula Rigenerativa disattivata`);
            }
            
            forceUIUpdate(); // FASE 2: Feedback immediato toggle ‚ö°
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function toggleSaldiEstivi() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('saldi-estivi-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            gameState.globalEffects.saldiEstivi = !gameState.globalEffects.saldiEstivi;
            
            if (gameState.globalEffects.saldiEstivi) {
                gameState.globalEffects.saldiEstiviActivator = activatorIndex;
                gameState.history.push(`üèñÔ∏è Saldi Estivi attivati per 1 turno completo! Solo i danni dimezzati. Attivatore: ${gameState.players[activatorIndex].name}`);
            } else {
                gameState.globalEffects.saldiEstiviActivator = null;
                gameState.history.push(`üèñÔ∏è Saldi Estivi disattivati`);
            }
            
            forceUIUpdate(); // FASE 2: Feedback immediato toggle ‚ö°
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function toggleGiocoPulito() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('gioco-pulito-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            gameState.globalEffects.giocoPulito = !gameState.globalEffects.giocoPulito;
            
            if (gameState.globalEffects.giocoPulito) {
                gameState.globalEffects.giocoPulitoActivator = activatorIndex;
                gameState.history.push(`‚öñÔ∏è Gioco Pulito attivato per 1 turno completo! Coppie/tris annullati, TUTTI gli effetti disattivati. Attivatore: ${gameState.players[activatorIndex].name}`);
                
                // Disattiva TUTTI gli altri effetti globali (tranne Gioco Pulito stesso)
                gameState.globalEffects.cessateFuoco = false;
                gameState.globalEffects.cessateFuocoActivator = null;
                gameState.globalEffects.pariPazzo = false;
                gameState.globalEffects.pariPazzoActivator = null;
                gameState.globalEffects.bambolaVoodoo = false;
                gameState.globalEffects.bambolaVoodooActivator = null;
                gameState.globalEffects.cannoneKarma = false;
                gameState.globalEffects.cannoneKarmaActivator = null;
                gameState.globalEffects.pioggiaAcida = false;
                gameState.globalEffects.pioggiaAcidaActivator = null;
                gameState.globalEffects.capsulaRigenerativa = false;
                gameState.globalEffects.capsulaRigenerativaActivator = null;
                gameState.globalEffects.saldiEstivi = false;
                gameState.globalEffects.saldiEstiviActivator = null;
                gameState.globalEffects.altaMarea = false;
                gameState.globalEffects.altaMareaActivator = null;
                gameState.globalEffects.zebratura = false;
                gameState.globalEffects.zebraturaActivator = null;
                gameState.globalEffects.boomerang = false;
                gameState.globalEffects.boomerangActivator = null;
                gameState.globalEffects.boomerangDamage = 0;
                gameState.globalEffects.armaturaSpecchio = false;
                gameState.globalEffects.armaturaSpecchioActivator = null;
                gameState.globalEffects.sabbieMobili = false;
                gameState.globalEffects.sabbieMobiliActivator = null;
                gameState.globalEffects.domino = false;
                gameState.globalEffects.dominoActivator = null;
                gameState.globalEffects.contagio = false;
                gameState.globalEffects.contagioActivator = null;
                gameState.globalEffects.treMolio = false;
                gameState.globalEffects.treMolioActivator = null;
                gameState.globalEffects.nirvana = false;
                gameState.globalEffects.nirvanaActivator = null;
                gameState.globalEffects.toccaAMe = false;
                gameState.globalEffects.toccaAMeActivator = null;
                gameState.globalEffects.toccaAMeTarget = null;
                gameState.globalEffects.toccaAMeRedirectFrom = null;
                
                // Rimuove TUTTI gli effetti individuali (eccetto protettoreFato)
                gameState.players.forEach(p => {
                    if (p.isEliminated) return;
                    p.isImmortal = false; p.multiplier = 1; p.multiplierAppliedBy = null;
                    p.skipTurn = false; p.customDiceCount = null; p.krakenMark = false;
                    p.checkmateHP = null; p.damageToHeal = false; p.sunArmor = false;
                    p.moonArmor = false; p.voloFenice = false; p.cactusAmari = false;
                    p.catenaMaledetta = false; p.rifletteDanni = false;
                    p.elmoMaledetto = false; p.manoFreya = false; p.armaturaCavaliere = false;
                    p.talismanRa = false; p.talismanRaValues = [];
                    p.dadoAvvelenato = false; p.dadoAvvelenatotValues = [];
                    p.interferenza = false; p.interferenzaPartner = null;
                    p.tiroCaricato = false; p.tiroCaricatoMultiplier = null;
                    p.cantoDelCigno = false; p.pattoDiavolo = false; p.pattoDiavoloUsed = false;
                    p.tombaTutankhamon = false; p.reincarnazione = false; p.reincarnazioneUsed = false;
                    p.boiaEsecutore = false; p.boiaEsecutoreTurns = 0;
                    if (p.temporaryEffects) Object.keys(p.temporaryEffects).forEach(k => { p.temporaryEffects[k] = false; });
                    // protettoreFato mai rimosso da gioco pulito
                });
                gameState.history.push(`‚öñÔ∏è [Gioco Pulito] Tutti gli effetti individuali rimossi istantaneamente!`);
            } else {
                gameState.globalEffects.giocoPulitoActivator = null;
                gameState.history.push(`‚öñÔ∏è Gioco Pulito disattivato`);
            }
            
            forceUIUpdate(); // FASE 2: Feedback immediato toggle ‚ö°
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        // ========== MECCANICHE IMMEDIATE ==========

        function activateTrottolaImpazzita() {
            if (!gameState.isMaster) return;
            
            if (!confirm('Attivare Trottola Impazzita? Tutti gli HP saranno trasferiti al giocatore successivo!')) return;
            
            const activePlayers = gameState.players.filter(p => !p.isEliminated);
            if (activePlayers.length < 2) {
                alert('Servono almeno 2 giocatori attivi!');
                return;
            }
            
            // Salva tutti gli HP attuali
            const hpValues = activePlayers.map(p => p.hp);
            
            // Trasferisci gli HP al giocatore successivo (in senso orario)
            activePlayers.forEach((player, index) => {
                const nextIndex = (index + 1) % activePlayers.length;
                player.hp = hpValues[nextIndex];
            });
            
            gameState.history.push(`üåÄ Trottola Impazzita! Tutti gli HP trasferiti al giocatore successivo`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
            
            // Anima tutti i giocatori
            activePlayers.forEach((player, index) => {
                const playerIndex = gameState.players.findIndex(p => p.name === player.name);
                animateHP(playerIndex, 0);
            });
        }

        function activateTartarugaLepre() {
            if (!gameState.isMaster) return;
            
            const activePlayers = gameState.players.filter(p => !p.isEliminated);
            if (activePlayers.length < 2) {
                alert('Servono almeno 2 giocatori attivi!');
                return;
            }
            
            // Trova il giocatore con pi√π HP
            let maxHP = 0;
            let maxHPPlayer = null;
            activePlayers.forEach(p => {
                if (p.hp > maxHP) {
                    maxHP = p.hp;
                    maxHPPlayer = p;
                }
            });
            
            if (!maxHPPlayer) return;
            
            // Calcola HP da perdere (met√†)
            const hpLost = Math.floor(maxHPPlayer.hp / 2);
            maxHPPlayer.hp -= hpLost;
            
            // Distribuisci equamente agli altri
            const otherPlayers = activePlayers.filter(p => p.name !== maxHPPlayer.name);
            const hpPerPlayer = Math.ceil(hpLost / otherPlayers.length);
            
            otherPlayers.forEach(p => {
                p.hp += hpPerPlayer;
            });
            
            gameState.history.push(`üê¢üê∞ Tartaruga e Lepre! ${maxHPPlayer.name} perde ${hpLost} HP, distribuiti agli altri (+${hpPerPlayer} HP ciascuno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
            
            // Anima tutti i giocatori
            activePlayers.forEach(player => {
                const playerIndex = gameState.players.findIndex(p => p.name === player.name);
                animateHP(playerIndex, 0);
            });
        }

        function activateYinYang() {
            if (!gameState.isMaster) return;
            
            if (!confirm('Attivare Yin e Yang? Tutti i giocatori avranno met√† HP iniziali!')) return;
            
            const activePlayers = gameState.players.filter(p => !p.isEliminated);
            const halfInitialHP = Math.ceil(gameState.initialHP / 2);
            
            activePlayers.forEach(p => {
                p.hp = halfInitialHP;
            });
            
            gameState.history.push(`‚òØÔ∏è Yin e Yang! Tutti i giocatori impostati a ${halfInitialHP} HP`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
            
            // Anima tutti i giocatori
            activePlayers.forEach(player => {
                const playerIndex = gameState.players.findIndex(p => p.name === player.name);
                animateHP(playerIndex, 0);
            });
        }

        function activateBilanciaFato() {
            if (!gameState.isMaster) return;
            
            if (!confirm('Attivare Bilancia del Fato? La differenza tra HP iniziali e attuali diventer√† il nuovo valore HP!')) return;
            
            const activePlayers = gameState.players.filter(p => !p.isEliminated);
            
            activePlayers.forEach(p => {
                const difference = Math.abs(gameState.initialHP - p.hp);
                p.hp = difference;
                
                // Previeni HP a 0 (minimo 1)
                if (p.hp === 0) p.hp = 1;
            });
            
            gameState.history.push(`‚öñÔ∏è Bilancia del Fato! HP = |HP iniziali - HP attuali|`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
            
            // Anima tutti i giocatori
            activePlayers.forEach(player => {
                const playerIndex = gameState.players.findIndex(p => p.name === player.name);
                animateHP(playerIndex, 0);
            });
        }

        function activateUguaglianza() {
            if (!gameState.isMaster) return;
            
            const divisor = parseInt(document.getElementById('uguaglianza-divisor').value);
            
            if (!divisor || divisor < 1 || divisor > 18) {
                alert('Inserisci un divisore valido (1-18)!');
                return;
            }
            
            const activePlayers = gameState.players.filter(p => !p.isEliminated);
            
            // Somma tutti gli HP
            const totalHP = activePlayers.reduce((sum, p) => sum + p.hp, 0);
            
            // Dividi e distribuisci
            const hpPerPlayer = Math.ceil(totalHP / divisor);
            
            activePlayers.forEach(p => {
                p.hp = hpPerPlayer;
            });
            
            gameState.history.push(`‚öñÔ∏è Uguaglianza! HP totali (${totalHP}) √∑ ${divisor} = ${hpPerPlayer} HP per tutti`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
            
            // Anima tutti i giocatori
            activePlayers.forEach(player => {
                const playerIndex = gameState.players.findIndex(p => p.name === player.name);
                animateHP(playerIndex, 0);
            });
        }

        function activateGeyserFuoco() {
            if (!gameState.isMaster) return;
            
            const activatorIndex = parseInt(document.getElementById('geyser-activator').value);
            const baseDamage = parseInt(document.getElementById('geyser-damage').value);
            
            if (isNaN(activatorIndex)) { alert('Seleziona un attivatore!'); return; }
            if (!baseDamage || baseDamage < 1 || baseDamage > 100) { alert('Inserisci un danno base valido (1-100)!'); return; }
            
            const activator = gameState.players[activatorIndex];
            if (!confirm(`Attivare Geyser di Fuoco con danno base ${baseDamage}? ${activator.name} sar√† immune.`)) return;
            
            let cumulativeDamage = 0;
            let hitCount = 0;
            
            for (let i = 1; i < gameState.players.length; i++) {
                const playerIndex = (activatorIndex + i) % gameState.players.length;
                const player = gameState.players[playerIndex];
                if (player.isEliminated || playerIndex === activatorIndex) continue;
                
                hitCount++;
                cumulativeDamage = baseDamage * hitCount;
                
                // Rispetta effetti individuali
                if (player.protettoreFato) {
                    gameState.history.push(`üõ°Ô∏è‚ú® [Protettore] ${player.name} immune al Geyser (${cumulativeDamage} danni bloccati)`);
                    continue;
                }
                if (player.isImmortal) {
                    gameState.history.push(`‚≠ê ${player.name} √® immortale, immune al Geyser`);
                    continue;
                }
                if (player.voloFenice) {
                    player.hp += cumulativeDamage * 2;
                    gameState.history.push(`ü¶Ö [Fenice] ${player.name}: Geyser ${cumulativeDamage} ‚Üí cura ${cumulativeDamage * 2}`);
                    animateHP(playerIndex, cumulativeDamage * 2);
                    continue;
                }
                if (player.damageToHeal) {
                    player.hp += cumulativeDamage;
                    gameState.history.push(`üí´ [D‚ÜíC] ${player.name}: Geyser ${cumulativeDamage} ‚Üí cura`);
                    animateHP(playerIndex, cumulativeDamage);
                    continue;
                }
                // Specchio Maledetto - riflette all'attivatore
                if (player.rifletteDanni) {
                    activator.hp = Math.max(0, activator.hp - cumulativeDamage);
                    player.rifletteDanni = false;
                    if (player.temporaryEffects) player.temporaryEffects.rifletteDanni = false;
                    gameState.history.push(`ü™û [Specchio Maledetto] ${player.name} riflette ${cumulativeDamage} danni su ${activator.name} (consumato)`);
                    if (activator.hp === 0 && !activator.isEliminated) tryEliminatePlayer(activator, `(Specchio da ${player.name})`, false);
                    animateHP(activatorIndex, -cumulativeDamage);
                    continue;
                }
                // Cactus Amari - riflette x2
                if (player.cactusAmari) {
                    const reflected = cumulativeDamage * 2;
                    activator.hp = Math.max(0, activator.hp - reflected);
                    gameState.history.push(`üåµ [Cactus] ${player.name} riflette ${reflected} danni su ${activator.name}`);
                    if (activator.hp === 0 && !activator.isEliminated) tryEliminatePlayer(activator, `(Cactus da ${player.name})`, false);
                }
                // Elmo Maledetto - riflette anche all'attivatore
                if (player.elmoMaledetto) {
                    activator.hp = Math.max(0, activator.hp - cumulativeDamage);
                    gameState.history.push(`‚õëÔ∏è [Elmo Maledetto] ${activator.name} subisce ${cumulativeDamage} danni riflessi da ${player.name}`);
                    if (activator.hp === 0 && !activator.isEliminated) tryEliminatePlayer(activator, `(Elmo Maledetto)`, false);
                }
                
                let dmg = cumulativeDamage;
                if (player.armaturaCavaliere) dmg = Math.floor(dmg / 2);
                if (player.manoFreya) { player.hp += dmg; gameState.history.push(`üåø [Mano Freya] ${player.name} cura ${dmg}`); animateHP(playerIndex, dmg); continue; }
                
                player.hp = Math.max(0, player.hp - dmg);
                if (player.hp === 0 && !player.isEliminated) {
                    tryEliminatePlayer(player, `(Geyser da ${activator.name})`, false, geyserDmg);
                }
                gameState.history.push(`üî• Geyser: ${player.name} subisce ${dmg} danni`);
                animateHP(playerIndex, -dmg);
            }
            
            gameState.history.push(`üî• Geyser di Fuoco attivato da ${activator.name}! Danno base: ${baseDamage}`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

// Continua nel prossimo file...
        // ========== MECCANICHE SU SINGOLI GIOCATORI ==========

        function toggleMareGuai() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('mare-guai-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            const currentPlayerIndex = gameState.currentTurn;
            
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.mareGuai = !player.mareGuai;
                
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.mareGuai = player.mareGuai;
            });
            
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].mareGuai ? 'attivato' : 'disattivato';
            gameState.history.push(`üåä Un Mare di Guai ${status} per: ${playerNames} (temp - 1 turno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function setTalismanRa() {
            if (!gameState.isMaster) return;
            
            const playerIndex = parseInt(document.getElementById('talismano-ra-player').value);
            const val1 = parseInt(document.getElementById('talismano-ra-val1').value);
            const val2 = parseInt(document.getElementById('talismano-ra-val2').value);
            
            if (isNaN(playerIndex)) {
                alert('Seleziona un giocatore!');
                return;
            }
            
            if (!val1 || val1 < 1 || val1 > 6 || !val2 || val2 < 1 || val2 > 6) {
                alert('Inserisci valori validi per i dadi (1-6)!');
                return;
            }
            
            const player = gameState.players[playerIndex];
            player.talismanRa = true;
            player.talismanRaValues = [val1, val2];
            
            if (!player.temporaryEffects) player.temporaryEffects = {};
            player.temporaryEffects.talismanRa = true;
            
            gameState.history.push(`üåû Talismano di Ra attivato per ${player.name}! Valori: ${val1}, ${val2} (temp - 1 turno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function removeTalismanRa() {
            if (!gameState.isMaster) return;
            
            const playerIndex = parseInt(document.getElementById('talismano-ra-player').value);
            
            if (isNaN(playerIndex)) {
                alert('Seleziona un giocatore!');
                return;
            }
            
            const player = gameState.players[playerIndex];
            player.talismanRa = false;
            player.talismanRaValues = [];
            
            if (player.temporaryEffects) player.temporaryEffects.talismanRa = false;
            
            gameState.history.push(`‚ùå Talismano di Ra rimosso da ${player.name}`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function setDadoAvvelenato() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('dado-avvelenato-player');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            const val1 = parseInt(document.getElementById('dado-avvelenato-val1').value);
            const val2 = parseInt(document.getElementById('dado-avvelenato-val2').value);
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            if (!val1 || val1 < 1 || val1 > 6 || !val2 || val2 < 1 || val2 > 6) {
                alert('Inserisci valori validi per i dadi (1-6)!');
                return;
            }
            
            selectedIndices.forEach(playerIndex => {
                const player = gameState.players[playerIndex];
                player.dadoAvvelenato = true;
                player.dadoAvvelenatotValues = [val1, val2];
                
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.dadoAvvelenato = true;
            });
            
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            gameState.history.push(`‚ò†Ô∏è Dado Avvelenato attivato per: ${playerNames}! Valori: ${val1}, ${val2} (temp - 1 turno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function removeDadoAvvelenato() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('dado-avvelenato-player');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            selectedIndices.forEach(playerIndex => {
                const player = gameState.players[playerIndex];
                player.dadoAvvelenato = false;
                player.dadoAvvelenatotValues = [];
                
                if (player.temporaryEffects) player.temporaryEffects.dadoAvvelenato = false;
            });
            
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            gameState.history.push(`‚ùå Dado Avvelenato rimosso da: ${playerNames}`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function setInterferenza() {
            if (!gameState.isMaster) return;
            
            const player1Index = parseInt(document.getElementById('interferenza-player1').value);
            const player2Index = parseInt(document.getElementById('interferenza-player2').value);
            
            if (isNaN(player1Index) || isNaN(player2Index)) {
                alert('Seleziona entrambi i giocatori!');
                return;
            }
            
            if (player1Index === player2Index) {
                alert('Seleziona due giocatori diversi!');
                return;
            }
            
            const player1 = gameState.players[player1Index];
            const player2 = gameState.players[player2Index];
            
            player1.interferenza = true;
            player1.interferenzaPartner = player2Index;
            
            gameState.history.push(`üîÄ Interferenza attivata! ${player1.name} trasferisce danni a ${player2.name} (temp - 1 turno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function removeInterferenza() {
            if (!gameState.isMaster) return;
            
            const player1Index = parseInt(document.getElementById('interferenza-player1').value);
            
            if (isNaN(player1Index)) {
                alert('Seleziona il giocatore!');
                return;
            }
            
            const player1 = gameState.players[player1Index];
            player1.interferenza = false;
            player1.interferenzaPartner = null;
            
            gameState.history.push(`‚ùå Interferenza rimossa da ${player1.name}`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function toggleVoloFenice() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('volo-fenice-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.voloFenice = !player.voloFenice;
                
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.voloFenice = player.voloFenice;
            });
            
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].voloFenice ? 'attivato' : 'disattivato';
            gameState.history.push(`ü¶Ö Volo della Fenice ${status} per: ${playerNames} (temp - 1 turno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function toggleCactusAmari() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('cactus-amari-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.cactusAmari = !player.cactusAmari;
                
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.cactusAmari = player.cactusAmari;
            });
            
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].cactusAmari ? 'attivato' : 'disattivato';
            gameState.history.push(`üåµ Cactus Amari ${status} per: ${playerNames} (temp - 1 turno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function toggleCatenaMaledetta() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('catena-maledetta-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.catenaMaledetta = !player.catenaMaledetta;
                
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.catenaMaledetta = player.catenaMaledetta;
            });
            
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].catenaMaledetta ? 'attivata' : 'disattivata';
            gameState.history.push(`‚õìÔ∏è Catena Maledetta ${status} per: ${playerNames} (temp - 1 turno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function toggleRiflettiDanni() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('rifletti-danni-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.rifletteDanni = !player.rifletteDanni;
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.rifletteDanni = player.rifletteDanni;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].rifletteDanni ? 'attivato' : 'disattivato';
            gameState.history.push(`ü™û Specchio Maledetto ${status} per: ${playerNames} (uso singolo)`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

        function toggleElmoMaledetto() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('elmo-maledetto-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.elmoMaledetto = !player.elmoMaledetto;
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.elmoMaledetto = player.elmoMaledetto;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].elmoMaledetto ? 'attivato' : 'disattivato';
            gameState.history.push(`‚õëÔ∏è Elmo Maledetto ${status} per: ${playerNames} (1 turno)`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

        function toggleManoFreya() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('mano-freya-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.manoFreya = !player.manoFreya;
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.manoFreya = player.manoFreya;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].manoFreya ? 'attivata' : 'disattivata';
            gameState.history.push(`üåø Mano di Freya ${status} per: ${playerNames} (1 turno)`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

        function toggleArmaturaCavaliere() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('armatura-cavaliere-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.armaturaCavaliere = !player.armaturaCavaliere;
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.armaturaCavaliere = player.armaturaCavaliere;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].armaturaCavaliere ? 'attivata' : 'disattivata';
            gameState.history.push(`üõ°Ô∏è Armatura del Cavaliere ${status} per: ${playerNames} (1 turno)`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

// Continua...

        
        function setAltaMarea() {
            if (!gameState.isMaster) return;
            const playerIndex = parseInt(document.getElementById('alta-marea-player').value);
            if (isNaN(playerIndex)) { alert('Seleziona un giocatore!'); return; }
            gameState.globalEffects.altaMarea = true;
            gameState.globalEffects.altaMareaActivator = playerIndex;
            gameState.history.push(`üåä Alta Marea attivata! Attivatore: ${gameState.players[playerIndex].name} (fino al suo prossimo turno)`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function removeAltaMarea() {
            if (!gameState.isMaster) return;
            gameState.globalEffects.altaMarea = false;
            gameState.globalEffects.altaMareaActivator = null;
            gameState.history.push(`‚ùå Alta Marea rimossa`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function setZebratura() {
            if (!gameState.isMaster) return;
            const playerIndex = parseInt(document.getElementById('zebratura-player').value);
            if (isNaN(playerIndex)) { alert('Seleziona un giocatore!'); return; }
            // Disattiva Capsula Rigenerativa se attiva (conflitto)
            if (gameState.globalEffects.capsulaRigenerativa) {
                gameState.globalEffects.capsulaRigenerativa = false;
                gameState.globalEffects.capsulaRigenerativaActivator = null;
                gameState.history.push(`‚ö†Ô∏è Capsula Rigenerativa disattivata (conflitto con Zebratura)`);
            }
            // Disattiva Cessate Fuoco se attivo (conflitto)
            if (gameState.globalEffects.cessateFuoco) {
                gameState.globalEffects.cessateFuoco = false;
                gameState.globalEffects.cessateFuocoActivator = null;
                gameState.history.push(`‚ö†Ô∏è Cessate il Fuoco disattivato (conflitto con Zebratura)`);
            }
            gameState.globalEffects.zebratura = true;
            gameState.globalEffects.zebraturaActivator = playerIndex;
            gameState.history.push(`ü¶ì Zebratura attivata! Attivatore: ${gameState.players[playerIndex].name} (fino al suo prossimo turno)`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function removeZebratura() {
            if (!gameState.isMaster) return;
            gameState.globalEffects.zebratura = false;
            gameState.globalEffects.zebraturaActivator = null;
            gameState.history.push(`‚ùå Zebratura rimossa`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function setBoomerang() {
            if (!gameState.isMaster) return;
            const playerIndex = parseInt(document.getElementById('boomerang-player').value);
            if (isNaN(playerIndex)) { alert('Seleziona un giocatore!'); return; }
            // Disattiva Armatura Specchio se attiva (conflitto)
            if (gameState.globalEffects.armaturaSpecchio) {
                gameState.globalEffects.armaturaSpecchio = false;
                gameState.globalEffects.armaturaSpecchioActivator = null;
                gameState.history.push(`‚ö†Ô∏è Armatura Specchio disattivata (conflitto con Boomerang)`);
            }
            gameState.globalEffects.boomerang = true;
            gameState.globalEffects.boomerangActivator = playerIndex;
            gameState.globalEffects.boomerangDamage = 0;
            gameState.history.push(`ü™É Boomerang attivato! ${gameState.players[playerIndex].name} non subisce danni (fino al suo prossimo turno)`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function removeBoomerang() {
            if (!gameState.isMaster) return;
            gameState.globalEffects.boomerang = false;
            gameState.globalEffects.boomerangActivator = null;
            gameState.globalEffects.boomerangDamage = 0;
            gameState.history.push(`‚ùå Boomerang rimosso`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function setArmaturaSpecchio() {
            if (!gameState.isMaster) return;
            const playerIndex = parseInt(document.getElementById('armatura-specchio-player').value);
            if (isNaN(playerIndex)) { alert('Seleziona un giocatore!'); return; }
            // Disattiva Boomerang se attivo (conflitto)
            if (gameState.globalEffects.boomerang) {
                gameState.globalEffects.boomerang = false;
                gameState.globalEffects.boomerangActivator = null;
                gameState.globalEffects.boomerangDamage = 0;
                gameState.history.push(`‚ö†Ô∏è Boomerang disattivato (conflitto con Armatura Specchio)`);
            }
            gameState.globalEffects.armaturaSpecchio = true;
            gameState.globalEffects.armaturaSpecchioActivator = playerIndex;
            gameState.history.push(`ü™û Armatura a Specchio attivata! ${gameState.players[playerIndex].name} distribuisce danni (fino al suo prossimo turno)`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function removeArmaturaSpecchio() {
            if (!gameState.isMaster) return;
            gameState.globalEffects.armaturaSpecchio = false;
            gameState.globalEffects.armaturaSpecchioActivator = null;
            gameState.history.push(`‚ùå Armatura a Specchio rimossa`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function setSabbieMobili() {
            if (!gameState.isMaster) return;
            const playerIndex = parseInt(document.getElementById('sabbie-mobili-player').value);
            if (isNaN(playerIndex)) { alert('Seleziona un giocatore!'); return; }
            gameState.globalEffects.sabbieMobili = true;
            gameState.globalEffects.sabbieMobiliActivator = playerIndex;
            gameState.history.push(`‚è≥ Sabbie Mobili attivate! (fino al prossimo turno di ${gameState.players[playerIndex].name})`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function removeSabbieMobili() {
            if (!gameState.isMaster) return;
            gameState.globalEffects.sabbieMobili = false;
            gameState.globalEffects.sabbieMobiliActivator = null;
            gameState.history.push(`‚ùå Sabbie Mobili rimosse`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function set7Bello() {
            if (!gameState.isMaster) return;
            const playerIndex = parseInt(document.getElementById('sette-bello-player').value);
            if (isNaN(playerIndex)) { alert('Seleziona un giocatore!'); return; }
            gameState.globalEffects.setteBello = true;
            gameState.globalEffects.setteBelloActivator = playerIndex;
            gameState.globalEffects.setteBelloTurnsLeft = 2; // 2 turni per fare 7
            gameState.history.push(`üé∞ 7 Bello attivato! ${gameState.players[playerIndex].name} ha 2 turni per fare 7 ed eliminare il settimo giocatore`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function remove7Bello() {
            if (!gameState.isMaster) return;
            gameState.globalEffects.setteBello = false;
            gameState.globalEffects.setteBelloActivator = null;
            gameState.globalEffects.setteBelloTurnsLeft = 0;
            gameState.history.push(`‚ùå 7 Bello rimosso`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function toggleCantoCigno() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('canto-cigno-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.cantoDelCigno = !player.cantoDelCigno;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].cantoDelCigno ? 'attivato' : 'disattivato';
            gameState.history.push(`ü¶¢ Canto del Cigno ${status} per: ${playerNames}`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

        function togglePattoDiavolo() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('patto-diavolo-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.pattoDiavolo = !player.pattoDiavolo;
                player.pattoDiavoloUsed = false;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].pattoDiavolo ? 'attivato' : 'disattivato';
            gameState.history.push(`üòà Patto con il Diavolo ${status} per: ${playerNames}`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

        function toggleTombaTutankhamon() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('tomba-tutankhamon-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.tombaTutankhamon = !player.tombaTutankhamon;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].tombaTutankhamon ? 'attivata' : 'disattivata';
            gameState.history.push(`üè∫ Tomba di Tutankhamon ${status} per: ${playerNames}`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

        function toggleReincarnazione() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('reincarnazione-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.reincarnazione = !player.reincarnazione;
                player.reincarnazioneUsed = false;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].reincarnazione ? 'attivata' : 'disattivata';
            gameState.history.push(`‚ôªÔ∏è Reincarnazione ${status} per: ${playerNames}`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

        function toggleBoiaEsecutore() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('boia-esecutore-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.boiaEsecutore = !player.boiaEsecutore;
                player.boiaEsecutoreTurns = player.boiaEsecutore ? 2 : 0;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].boiaEsecutore ? 'attivato' : 'disattivato';
            gameState.history.push(`ü™ì Boia Esecutore ${status} per: ${playerNames} (dura 2 turni)`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

        // ===== DOMINO =====
        function toggleDomino() {
            if (!gameState.isMaster) return;
            const activatorIndex = parseInt(document.getElementById('domino-activator').value);
            if (isNaN(activatorIndex)) { alert('Seleziona un attivatore!'); return; }
            
            gameState.globalEffects.domino = !gameState.globalEffects.domino;
            if (gameState.globalEffects.domino) {
                gameState.globalEffects.dominoActivator = activatorIndex;
                gameState.history.push(`üÅ° Domino attivato da ${gameState.players[activatorIndex].name}! I danni si propagano al giocatore successivo.`);
            } else {
                gameState.globalEffects.dominoActivator = null;
                gameState.history.push('üÅ° Domino disattivato.');
            }
            forceUIUpdate(); // FASE 2: Feedback immediato toggle ‚ö°
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        // ===== CONTAGIO =====
        function toggleContagio() {
            if (!gameState.isMaster) return;
            const activatorIndex = parseInt(document.getElementById('contagio-activator').value);
            if (isNaN(activatorIndex)) { alert('Seleziona un attivatore!'); return; }
            
            gameState.globalEffects.contagio = !gameState.globalEffects.contagio;
            if (gameState.globalEffects.contagio) {
                gameState.globalEffects.contagioActivator = activatorIndex;
                gameState.history.push(`ü¶† Contagio attivato da ${gameState.players[activatorIndex].name}! L'eliminazione propaga il danno a tutti.`);
            } else {
                gameState.globalEffects.contagioActivator = null;
                gameState.history.push('ü¶† Contagio disattivato.');
            }
            forceUIUpdate(); // FASE 2: Feedback immediato toggle ‚ö°
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        // ===== 3 MOLIO =====
        function toggleTreMolio() {
            if (!gameState.isMaster) return;
            const activatorIndex = parseInt(document.getElementById('tre-molio-activator').value);
            if (isNaN(activatorIndex)) { alert('Seleziona un attivatore!'); return; }
            
            gameState.globalEffects.treMolio = !gameState.globalEffects.treMolio;
            if (gameState.globalEffects.treMolio) {
                gameState.globalEffects.treMolioActivator = activatorIndex;
                gameState.history.push(`üéØ 3 Molio attivato da ${gameState.players[activatorIndex].name}! Un 3 nei dadi = danno totale a tutti.`);
            } else {
                gameState.globalEffects.treMolioActivator = null;
                gameState.history.push('üéØ 3 Molio disattivato.');
            }
            forceUIUpdate(); // FASE 2: Feedback immediato toggle ‚ö°
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        // ===== NIRVANA =====
        function toggleNirvana() {
            if (!gameState.isMaster) return;
            const activatorIndex = parseInt(document.getElementById('nirvana-activator').value);
            if (isNaN(activatorIndex)) { alert('Seleziona un attivatore!'); return; }
            
            gameState.globalEffects.nirvana = !gameState.globalEffects.nirvana;
            if (gameState.globalEffects.nirvana) {
                gameState.globalEffects.nirvanaActivator = activatorIndex;
                gameState.history.push(`üßò Nirvana attivato da ${gameState.players[activatorIndex].name}! Guadagna HP pari ai dadi altrui.`);
            } else {
                gameState.globalEffects.nirvanaActivator = null;
                gameState.history.push('üßò Nirvana disattivato.');
            }
            forceUIUpdate(); // FASE 2: Feedback immediato toggle ‚ö°
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        // ===== TOCCA A ME =====
        function setToccaAMe() {
            if (!gameState.isMaster) return;
            const activatorIndex = parseInt(document.getElementById('tocca-a-me-activator').value);
            const targetIndex = parseInt(document.getElementById('tocca-a-me-target').value);
            if (isNaN(activatorIndex) || isNaN(targetIndex)) { alert('Seleziona attivatore e bersaglio!'); return; }
            if (activatorIndex === targetIndex) { alert('Attivatore e bersaglio devono essere diversi!'); return; }
            
            gameState.globalEffects.toccaAMe = true;
            gameState.globalEffects.toccaAMeActivator = activatorIndex;
            gameState.globalEffects.toccaAMeTarget = targetIndex;
            gameState.history.push(`‚úã Tocca a Me: ${gameState.players[activatorIndex].name} giocher√† al posto di ${gameState.players[targetIndex].name}!`);
            forceUIUpdate(); // FASE 2: Feedback immediato toggle ‚ö°
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function removeToccaAMe() {
            if (!gameState.isMaster) return;
            gameState.globalEffects.toccaAMe = false;
            gameState.globalEffects.toccaAMeActivator = null;
            gameState.globalEffects.toccaAMeTarget = null;
            gameState.globalEffects.toccaAMeRedirectFrom = null;
            gameState.history.push('‚úã Tocca a Me disattivato.');
            forceUIUpdate(); // FASE 2: Feedback immediato toggle ‚ö°
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        // ===== PROTETTORE DEL FATO =====
        function toggleProtettoreFato() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('protettore-fato-players');
            const selectedIndices = Array.from(select.selectedOptions).map(option => parseInt(option.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.protettoreFato = !player.protettoreFato;
                // Mark as temporary: expires at that player's own next turn
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.protettoreFato = player.protettoreFato;
            });
            
            const status = gameState.players[selectedIndices[0]].protettoreFato ? 'attivato' : 'disattivato';
            const names = selectedIndices.map(i => gameState.players[i].name).join(', ');
            gameState.history.push(`üõ°Ô∏è‚ú® Protettore del Fato ${status} per: ${names} ‚Äì blocca danni e effetti negativi fino al suo prossimo turno`);
            forceUIUpdate();
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        // ===== DISTORSIONE SPAZIO-TEMPORALE =====
        function toggleDistorsione() {
            if (!gameState.isMaster) return;
            const activatorSelect = document.getElementById('distorsione-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            if (isNaN(activatorIndex)) { alert('Seleziona un attivatore!'); return; }
            
            const gfx = gameState.globalEffects;
            gfx.distorsione = !gfx.distorsione;
            
            if (gfx.distorsione) {
                gfx.distorsioneActivator = activatorIndex;
                gfx.distorsioneTurnsLeft = 3;
                gameState.history.push(`‚è≥üåÄ Distorsione Spazio-Temporale attivata da ${gameState.players[activatorIndex].name}! La partita termina al 3¬∞ suo turno (o se viene eliminato).`);
            } else {
                gfx.distorsioneActivator = null;
                gfx.distorsioneTurnsLeft = 0;
                gameState.history.push(`‚è≥üåÄ Distorsione Spazio-Temporale disattivata`);
            }
            forceUIUpdate();
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gfx, history: gameState.history });
        }

        // ===== TIRO CARICATO =====
        function setTiroCaricato() {
            if (!gameState.isMaster) return;
            const playerIndex = parseInt(document.getElementById('tiro-caricato-player').value);
            const multiplier = parseInt(document.getElementById('tiro-caricato-multiplier').value);
            if (isNaN(playerIndex)) { alert('Seleziona un giocatore!'); return; }
            if (isNaN(multiplier) || multiplier < 2 || multiplier > 15) { alert('Moltiplicatore deve essere tra 2 e 15!'); return; }
            
            const player = gameState.players[playerIndex];
            player.tiroCaricato = true;
            player.tiroCaricatoMultiplier = multiplier;
            
            gameState.history.push(`‚ö° Tiro Caricato impostato per ${player.name} con moltiplicatore x${multiplier}!`);
            forceUIUpdate();
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function removeTiroCaricato() {
            if (!gameState.isMaster) return;
            const playerIndex = parseInt(document.getElementById('tiro-caricato-player').value);
            if (isNaN(playerIndex)) { alert('Seleziona un giocatore!'); return; }
            
            const player = gameState.players[playerIndex];
            player.tiroCaricato = false;
            player.tiroCaricatoMultiplier = null;
            
            gameState.history.push(`‚ö° Tiro Caricato rimosso da ${player.name}.`);
            forceUIUpdate();
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        // ===== MINOTAURO CORROTTO =====
        function toggleMinotauroCorreto() {
            if (!gameState.isMaster) return;
            const activatorIndex = parseInt(document.getElementById('minotauro-corrotto-activator').value);
            if (isNaN(activatorIndex)) { alert('Seleziona un attivatore!'); return; }
            
            gameState.globalEffects.minotauroCorreto = !gameState.globalEffects.minotauroCorreto;
            if (gameState.globalEffects.minotauroCorreto) {
                gameState.globalEffects.minotauroCorretoActivator = activatorIndex;
                gameState.history.push(`üêÇ Minotauro Corrotto attivato da ${gameState.players[activatorIndex].name}! Solo danni dispari sono validi.`);
            } else {
                gameState.globalEffects.minotauroCorretoActivator = null;
                gameState.history.push('üêÇ Minotauro Corrotto disattivato.');
            }
            forceUIUpdate();
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        // ===== TROLL FACE =====
        function setTrollFace() {
            if (!gameState.isMaster) return;
            const activatorIndex = parseInt(document.getElementById('troll-face-activator').value);
            const value = parseInt(document.getElementById('troll-face-value').value);
            if (isNaN(activatorIndex)) { alert('Seleziona un attivatore!'); return; }
            if (isNaN(value) || value < 1 || value > 6) { alert('Valore deve essere tra 1 e 6!'); return; }
            
            gameState.globalEffects.trollFace = true;
            gameState.globalEffects.trollFaceActivator = activatorIndex;
            gameState.globalEffects.trollFaceValue = value;
            
            gameState.history.push(`üòà Troll Face attivato da ${gameState.players[activatorIndex].name}! Il valore ${value} diventa 0 per tutti gli altri.`);
            forceUIUpdate();
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function removeTrollFace() {
            if (!gameState.isMaster) return;
            gameState.globalEffects.trollFace = false;
            gameState.globalEffects.trollFaceActivator = null;
            gameState.globalEffects.trollFaceValue = null;
            gameState.history.push('üòà Troll Face disattivato.');
            forceUIUpdate();
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        // ===== NEW: Render Active Effects Panel =====
        function renderActiveEffects() {
            const container = document.getElementById('active-effects-list');
            if (!container) return;
            
            // ===== PERFORMANCE: Skip render if nothing changed =====
            const gfxKey = JSON.stringify(gameState.globalEffects) + '|' + gameState.players.map(p => 
                p.name+':'+[p.isImmortal,p.multiplier,p.rifletteDanni,p.elmoMaledetto,p.manoFreya,
                p.armaturaCavaliere,p.damageToHeal,p.voloFenice,p.cactusAmari,p.catenaMaledetta,
                p.protettoreFato,p.skipTurn,p.krakenMark,p.checkmateHP,p.cantoDelCigno,
                p.pattoDiavolo,p.tombaTutankhamon,p.reincarnazione,p.boiaEsecutore,p.tiroCaricato].join(',')
            ).join('|');
            if (container._gfxKey === gfxKey) return;
            container._gfxKey = gfxKey;
            
            let html = '';
            const gfx = gameState.globalEffects;
            const isMaster = gameState.isMaster;
            const initHP = gameState.initialHP || 70;
            const halfHP = Math.ceil(initHP / 2);

            // Helper: description map for global effects
            const globalDesc = {
                'Cessate il Fuoco':     `üïäÔ∏è Attaccante si auto-cura invece di colpire`,
                'Di Pari Pazzo':        `üé≤ Somma pari ‚Üí danni a s√© stessi`,
                'Bambola Voodoo':       `ü™Ü Tutti (escluso attivatore) fanno danni a s√© stessi`,
                'Cannone Karma':        `üí• Attivatore viene colpito dai propri danni`,
                'Pioggia Acida':        `‚òî Dado pi√π alto infligge danni a tutti (escluso attivatore)`,
                'Capsula Rigenerativa': `üíä Tutti si curano invece di fare danni`,
                'Saldi Estivi':         `üèñÔ∏è Solo i danni dimezzati (le cure rimangono invariate)`,
                'Gioco Pulito':         `‚öñÔ∏è Coppia/Tris annullati + rimuove TUTTI gli effetti individuali`,
                'Alta Marea':           `üåä ‚â§${halfHP} HP ‚Üí danni √ó0.5 | >${halfHP} HP ‚Üí danni √ó2`,
                'Zebratura':            `ü¶ì Somma pari ‚Üí cura | Somma dispari ‚Üí danno`,
                'Boomerang':            `ü™É Danni accumulati al portatore ‚Üí inizio prossimo turno inflitti a TUTTI`,
                'Armatura Specchio':    `ü™û Danni divisi equamente tra tutti i giocatori`,
                'Sabbie Mobili':        `‚è≥ Chi viene colpito salta il turno (no cumulo, attivatore immune)`,
                'Domino':               `üÅ° Ogni danno replicato al giocatore successivo (escluso attivatore)`,
                'Contagio':             `ü¶† Quando un giocatore viene eliminato, tutti gli altri subiscono lo stesso danno`,
                '3 Molio':              `üéØ Se esce un 3 ‚Üí danni totali a tutti (escluso attivatore)`,
                'Nirvana':              `üßò Attivatore si cura del totale dei dadi altrui`,
                'Tocca a Me':           `‚úã Quando tocca al target, l'attivatore gioca al suo posto (uso singolo)`,
                'Minotauro Corrotto':   `üêÇ Danni pari vengono annullati`,
                'Troll Face':           `üòà Un valore dado ‚Üí 0 anzich√© il suo numero`,
                '7 Bello':              `üé∞ Se attivatore fa somma 7 ‚Üí elimina il 7¬∞ giocatore in ordine`,
                'Distorsione':          `‚è≥üåÄ La partita termina al 3¬∞ turno dell'attivatore o se viene eliminato`,
            };

            // ‚îÄ‚îÄ GLOBAL EFFECTS ‚îÄ‚îÄ
            const globalEffects = [];
            if (gfx.cessateFuoco)       globalEffects.push({icon:'üïäÔ∏è', name:'Cessate il Fuoco',     key:'Cessate il Fuoco',     activator: gameState.players[gfx.cessateFuocoActivator]?.name});
            if (gfx.pariPazzo)          globalEffects.push({icon:'üé≤', name:'Di Pari Pazzo',         key:'Di Pari Pazzo',         activator: gameState.players[gfx.pariPazzoActivator]?.name});
            if (gfx.bambolaVoodoo)      globalEffects.push({icon:'ü™Ü', name:'Bambola Voodoo',        key:'Bambola Voodoo',        activator: gameState.players[gfx.bambolaVoodooActivator]?.name});
            if (gfx.cannoneKarma)       globalEffects.push({icon:'üí•', name:'Cannone Karma',         key:'Cannone Karma',         activator: gameState.players[gfx.cannoneKarmaActivator]?.name});
            if (gfx.pioggiaAcida)       globalEffects.push({icon:'‚òî', name:'Pioggia Acida',         key:'Pioggia Acida',         activator: gameState.players[gfx.pioggiaAcidaActivator]?.name});
            if (gfx.capsulaRigenerativa)globalEffects.push({icon:'üíä', name:'Capsula Rigenerativa',  key:'Capsula Rigenerativa',  activator: gameState.players[gfx.capsulaRigenerativaActivator]?.name});
            if (gfx.saldiEstivi)        globalEffects.push({icon:'üèñÔ∏è', name:'Saldi Estivi',          key:'Saldi Estivi',          activator: gameState.players[gfx.saldiEstiviActivator]?.name});
            if (gfx.giocoPulito)        globalEffects.push({icon:'‚öñÔ∏è', name:'Gioco Pulito',          key:'Gioco Pulito',          activator: gameState.players[gfx.giocoPulitoActivator]?.name});
            if (gfx.altaMarea) {
                const amAct = gameState.players[gfx.altaMareaActivator]?.name;
                // Build per-player multiplier summary
                const amSummary = gameState.players
                    .filter(p => !p.isEliminated)
                    .map(p => {
                        const mult = p.hp > halfHP ? '√ó2' : '√ó0.5';
                        return `${p.name} (${p.hp}HP‚Üí${mult})`;
                    }).join(', ');
                globalEffects.push({icon:'üåä', name:'Alta Marea', key:'Alta Marea', activator: amAct, extra: amSummary});
            }
            if (gfx.zebratura)          globalEffects.push({icon:'ü¶ì', name:'Zebratura',             key:'Zebratura',             activator: gameState.players[gfx.zebraturaActivator]?.name});
            if (gfx.boomerang)          globalEffects.push({icon:'ü™É', name:'Boomerang ('+gfx.boomerangDamage+'dmg acc.)', key:'Boomerang', activator: gameState.players[gfx.boomerangActivator]?.name});
            if (gfx.armaturaSpecchio)   globalEffects.push({icon:'ü™û', name:'Armatura Specchio',     key:'Armatura Specchio',     activator: gameState.players[gfx.armaturaSpecchioActivator]?.name});
            if (gfx.sabbieMobili)       globalEffects.push({icon:'‚è≥', name:'Sabbie Mobili',         key:'Sabbie Mobili',         activator: gameState.players[gfx.sabbieMobiliActivator]?.name});
            if (gfx.domino)             globalEffects.push({icon:'üÅ°', name:'Domino',                key:'Domino',                activator: gameState.players[gfx.dominoActivator]?.name});
            if (gfx.contagio)           globalEffects.push({icon:'ü¶†', name:'Contagio',              key:'Contagio',              activator: gameState.players[gfx.contagioActivator]?.name});
            if (gfx.treMolio)           globalEffects.push({icon:'üéØ', name:'3 Molio',               key:'3 Molio',               activator: gameState.players[gfx.treMolioActivator]?.name});
            if (gfx.nirvana)            globalEffects.push({icon:'üßò', name:'Nirvana',               key:'Nirvana',               activator: gameState.players[gfx.nirvanaActivator]?.name});
            if (gfx.toccaAMe)           globalEffects.push({icon:'‚úã', name:'Tocca a Me',            key:'Tocca a Me',            activator: (gameState.players[gfx.toccaAMeActivator]?.name||'?') + ' ‚Üí ' + (gameState.players[gfx.toccaAMeTarget]?.name||'?')});
            if (gfx.minotauroCorreto)   globalEffects.push({icon:'üêÇ', name:'Minotauro Corrotto',    key:'Minotauro Corrotto',    activator: gameState.players[gfx.minotauroCorretoActivator]?.name});
            if (gfx.trollFace)          globalEffects.push({icon:'üòà', name:'Troll Face ('+gfx.trollFaceValue+'‚Üí0)', key:'Troll Face', activator: gameState.players[gfx.trollFaceActivator]?.name});
            if (gfx.setteBello)         globalEffects.push({icon:'üé∞', name:'7 Bello ('+gfx.setteBelloTurnsLeft+'t)', key:'7 Bello', activator: gameState.players[gfx.setteBelloActivator]?.name});
            if (gfx.distorsione)        globalEffects.push({icon:'‚è≥üåÄ', name:'Distorsione ('+gfx.distorsioneTurnsLeft+'t rimanenti)', key:'Distorsione', activator: gameState.players[gfx.distorsioneActivator]?.name});

            if (globalEffects.length > 0) {
                html += '<div class="effects-section"><div class="effects-section-title">üåç Effetti Globali</div>';
                globalEffects.forEach(eff => {
                    const removeBtn = isMaster
                        ? `<button class="effect-remove" onclick="removeGlobalEffect('${eff.key}')" title="Rimuovi">‚úï</button>`
                        : '';
                    const baseName = eff.key === '7 Bello' ? '7 Bello' : eff.key === 'Troll Face' ? 'Troll Face' : eff.key;
                    const desc = globalDesc[baseName] || '';
                    html += `<div class="active-effect global-effect" style="flex-direction:column;align-items:flex-start;gap:3px;">
                        <div style="display:flex;align-items:center;gap:6px;width:100%;">
                            <span class="effect-icon">${eff.icon}</span>
                            <span class="effect-name">${eff.name}</span>
                            <span class="effect-by" style="margin-left:auto;">da ${eff.activator || '?'}</span>
                            ${removeBtn}
                        </div>
                        ${desc ? `<div style="font-size:0.75em;color:#94a3b8;padding-left:26px;">${desc}</div>` : ''}
                        ${eff.extra ? `<div style="font-size:0.72em;color:#fbbf24;padding-left:26px;margin-top:2px;">${eff.extra}</div>` : ''}
                    </div>`;
                });
                html += '</div>';
            }

            // Description map for player effects
            const playerEffDesc = {
                'immortal':         '‚≠ê Nessun danno subito',
                'multiplier':       (p) => `‚ú® Danni ricevuti √ó${p.multiplier}${p.reincarnazioneMultiplier ? ' (permanente)' : ''}`,
                'skipTurn':         '‚è≠Ô∏è Salta il prossimo turno',
                'customDice':       (p) => `üé≤ Tira ${p.customDiceCount} dadi`,
                'krakenMark':       'üêô A ‚â§10 HP viene eliminato direttamente',
                'checkmate':        (p) => `‚ôüÔ∏è Alla soglia esatta di ${p.checkmateHP} HP viene eliminato`,
                'damageToHeal':     'üí´ Danni ricevuti convertiti in cura',
                'sunArmor':         '‚òÄÔ∏è Danni dispari ‚Üí cura | danni pari ‚Üí danno normale',
                'moonArmor':        'üåô Danni pari ‚Üí cura | danni dispari ‚Üí danno normale',
                'voloFenice':       'ü¶Ö Danni ricevuti convertiti in cura √ó2',
                'cactusAmari':      'üåµ Subisce danno ma lo riflette √ó2 all\'attaccante',
                'catenaMaledetta':  '‚õìÔ∏è Danni ricevuti propagati ai giocatori adiacenti',
                'rifletteDanni':    'ü™û Specchio Maledetto: prossimo colpo rimbalzato all\'attaccante (uso singolo)',
                'cantoDelCigno':    'ü¶¢ Sopravvive con 1 HP invece di essere eliminato + pesca 2 carte del Fato',
                'pattoDiavolo':     'üòà Torna in vita con 20 HP + solo 2 dadi per sempre',
                'tombaTutankhamon': 'üè∫ Risorge con met√† HP iniziali + salta il prossimo turno',
                'reincarnazione':   '‚ôªÔ∏è Risorge con HP iniziali + danni √ó2 permanenti',
                'boiaEsecutore':    (p) => `ü™ì ${p.boiaEsecutoreTurns}t: se elimina qualcuno, elimina automaticamente il successivo`,
                'extraTurns':       (p) => `üîÑ +${p.extraTurns} turni extra`,
                'protettoreFato':   'üõ°Ô∏è‚ú® Immuni a tutti i danni e effetti negativi (solo il Master pu√≤ rimuoverlo)',
                'tiroCaricato':     (p) => `‚ö° Prossimo danno √ó${p.tiroCaricatoMultiplier||2}`,
                'dadoAvvelenato':   (p) => `‚ò†Ô∏è Valori ${(p.dadoAvvelenatotValues||[]).join('/')} ‚Üí altri giocatori che li tirano subiscono val1√óval2 danni`,
                'talismanRa':       (p) => `üåû Valori ${(p.talismanRaValues||[]).join('/')} ‚Üí quando altri li tirano, si cura di val1√óval2`,
                'interferenza':     'üîÄ Trasferisce i danni ricevuti al partner',
                'elmoMaledetto':    '‚õëÔ∏è I danni ricevuti vengono riflessi anche all\'attaccante (1 turno)',
                'manoFreya':        'üåø I danni ricevuti vengono convertiti in cure (1 turno)',
                'armaturaCavaliere':'üõ°Ô∏è I danni ricevuti vengono dimezzati (1 turno)',
            };

            // ‚îÄ‚îÄ PLAYER EFFECTS ‚îÄ‚îÄ
            let playerEffects = [];
            gameState.players.forEach((player, idx) => {
                if (player.isEliminated) return;
                let effects = [];
                if (player.isImmortal)       effects.push({label:'‚≠ê Immortale',                              key:'immortal',          desc:playerEffDesc['immortal']});
                if (player.multiplier !== 1) effects.push({label:'‚ú® √ó' + player.multiplier,                  key:'multiplier',        desc:typeof playerEffDesc['multiplier']==='function'?playerEffDesc['multiplier'](player):playerEffDesc['multiplier']});
                if (player.skipTurn)         effects.push({label:'‚è≠Ô∏è Salta Turno',                            key:'skipTurn',          desc:playerEffDesc['skipTurn']});
                if (player.customDiceCount)  effects.push({label:'üé≤ '+player.customDiceCount+'d',             key:'customDice',        desc:typeof playerEffDesc['customDice']==='function'?playerEffDesc['customDice'](player):playerEffDesc['customDice']});
                if (player.krakenMark)       effects.push({label:'üêô Kraken',                                  key:'krakenMark',        desc:playerEffDesc['krakenMark']});
                if (player.checkmateHP)      effects.push({label:'‚ôüÔ∏è Scacco ‚â§'+player.checkmateHP,             key:'checkmate',         desc:typeof playerEffDesc['checkmate']==='function'?playerEffDesc['checkmate'](player):playerEffDesc['checkmate']});
                if (player.damageToHeal)     effects.push({label:'üí´ D‚ÜíC',                                    key:'damageToHeal',      desc:playerEffDesc['damageToHeal']});
                if (player.sunArmor)         effects.push({label:'‚òÄÔ∏è Armatura Sole',                           key:'sunArmor',          desc:playerEffDesc['sunArmor']});
                if (player.moonArmor)        effects.push({label:'üåô Armatura Luna',                           key:'moonArmor',         desc:playerEffDesc['moonArmor']});
                if (player.voloFenice)       effects.push({label:'ü¶Ö Fenice',                                  key:'voloFenice',        desc:playerEffDesc['voloFenice']});
                if (player.cactusAmari)      effects.push({label:'üåµ Cactus',                                  key:'cactusAmari',       desc:playerEffDesc['cactusAmari']});
                if (player.catenaMaledetta)  effects.push({label:'‚õìÔ∏è Catena',                                  key:'catenaMaledetta',   desc:playerEffDesc['catenaMaledetta']});
                if (player.rifletteDanni)    effects.push({label:'ü™û Specchio',                             key:'rifletteDanni',     desc:playerEffDesc['rifletteDanni']});
                if (player.elmoMaledetto)    effects.push({label:'‚õëÔ∏è Elmo',                                  key:'elmoMaledetto',     desc:playerEffDesc['elmoMaledetto']});
                if (player.manoFreya)        effects.push({label:'üåø Freya',                                  key:'manoFreya',         desc:playerEffDesc['manoFreya']});
                if (player.armaturaCavaliere)effects.push({label:'üõ°Ô∏è Cavaliere',                             key:'armaturaCavaliere', desc:playerEffDesc['armaturaCavaliere']});
                if (player.cantoDelCigno)    effects.push({label:'ü¶¢ Canto Cigno',                             key:'cantoDelCigno',     desc:playerEffDesc['cantoDelCigno']});
                if (player.pattoDiavolo)     effects.push({label:'üòà Patto Diavolo',                          key:'pattoDiavolo',      desc:playerEffDesc['pattoDiavolo']});
                if (player.tombaTutankhamon) effects.push({label:'üè∫ Tutankhamon',                             key:'tombaTutankhamon',  desc:playerEffDesc['tombaTutankhamon']});
                if (player.reincarnazione)   effects.push({label:'‚ôªÔ∏è Reincarnazione',                         key:'reincarnazione',    desc:playerEffDesc['reincarnazione']});
                if (player.boiaEsecutore)    effects.push({label:'ü™ì Boia '+player.boiaEsecutoreTurns+'t',     key:'boiaEsecutore',     desc:typeof playerEffDesc['boiaEsecutore']==='function'?playerEffDesc['boiaEsecutore'](player):playerEffDesc['boiaEsecutore']});
                if (player.extraTurns > 0)   effects.push({label:'üîÑ +'+player.extraTurns+' turni',           key:'extraTurns',        desc:typeof playerEffDesc['extraTurns']==='function'?playerEffDesc['extraTurns'](player):playerEffDesc['extraTurns']});
                if (player.protettoreFato)   effects.push({label:'üõ°Ô∏è‚ú® Protettore',                          key:'protettoreFato',    desc:playerEffDesc['protettoreFato']});
                if (player.tiroCaricato)     effects.push({label:'‚ö° Tiro √ó'+(player.tiroCaricatoMultiplier||2), key:'tiroCaricato',   desc:typeof playerEffDesc['tiroCaricato']==='function'?playerEffDesc['tiroCaricato'](player):playerEffDesc['tiroCaricato']});
                if (player.dadoAvvelenato)   effects.push({label:'‚ò†Ô∏è Dado Avv.',                              key:'dadoAvvelenato',    desc:playerEffDesc['dadoAvvelenato']});
                if (player.talismanRa)       effects.push({label:'üåû Talismano Ra',                           key:'talismanRa',        desc:playerEffDesc['talismanRa']});
                if (player.interferenza)     effects.push({label:'üîÄ Interferenza',                           key:'interferenza',      desc:playerEffDesc['interferenza']});

                if (effects.length > 0) {
                    playerEffects.push({name: player.name, effects, idx});
                }
            });

            if (playerEffects.length > 0) {
                html += '<div class="effects-section"><div class="effects-section-title">üë§ Effetti Giocatori</div>';
                playerEffects.forEach(pe => {
                    html += `<div class="player-effects-row" style="flex-direction:column;align-items:flex-start;gap:6px;">
                        <span class="pe-name" style="font-size:0.9em;color:#e2e8f0;font-weight:700;">${pe.name}</span>
                        <div class="pe-badges" style="display:flex;flex-direction:column;gap:5px;width:100%;">`;
                    pe.effects.forEach(eff => {
                        const descHtml = eff.desc ? `<div style="font-size:0.72em;color:#94a3b8;margin-top:1px;">${eff.desc}</div>` : '';
                        if (isMaster) {
                            html += `<div style="display:flex;align-items:flex-start;gap:4px;">
                                <div style="flex:1;">
                                    <span class="pe-badge" style="display:inline-block;">${eff.label}</span>
                                    ${descHtml}
                                </div>
                                <button class="effect-remove" onclick="removePlayerEffect(${pe.idx},'${eff.key}')" title="Rimuovi" style="width:18px!important;height:18px;min-height:18px!important;font-size:10px;flex-shrink:0;margin-top:2px;">‚úï</button>
                            </div>`;
                        } else {
                            html += `<div>
                                <span class="pe-badge">${eff.label}</span>
                                ${descHtml}
                            </div>`;
                        }
                    });
                    html += `</div></div>`;
                });
                html += '</div>';
            }

            if (!html) {
                html = '<div class="no-effects">Nessun effetto attivo</div>';
            }

            container.innerHTML = html;
        }
        
        // ===== Remove global effect by name =====
        function removeGlobalEffect(name) {
            if (!gameState.isMaster) return;
            const gfx = gameState.globalEffects;

            // Tocca a Me ‚Äì special cleanup
            if (name === 'Tocca a Me') {
                gfx.toccaAMe = false;
                gfx.toccaAMeActivator = null;
                gfx.toccaAMeTarget = null;
                gfx.toccaAMeRedirectFrom = null;
                gameState.history.push('‚ùå Effetto globale Tocca a Me rimosso dal Master');
                database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
                return;
            }
            // Troll Face ‚Äì name includes the value so use key-based matching
            if (name === 'Troll Face') {
                gfx.trollFace = false;
                gfx.trollFaceActivator = null;
                gfx.trollFaceValue = null;
                gameState.history.push('‚ùå Effetto globale Troll Face rimosso dal Master');
                database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
                return;
            }
            // 7 Bello
            if (name === '7 Bello') {
                gfx.setteBello = false;
                gfx.setteBelloActivator = null;
                gfx.setteBelloTurnsLeft = 0;
                gameState.history.push('‚ùå Effetto globale 7 Bello rimosso dal Master');
                database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
                return;
            }
            // Distorsione
            if (name === 'Distorsione') {
                gfx.distorsione = false;
                gfx.distorsioneActivator = null;
                gfx.distorsioneTurnsLeft = 0;
                gameState.history.push('‚ùå Distorsione Spazio-Temporale rimossa dal Master');
                database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
                return;
            }

            const effectMap = {
                'Cessate il Fuoco':    'cessateFuoco',
                'Di Pari Pazzo':       'pariPazzo',
                'Bambola Voodoo':      'bambolaVoodoo',
                'Cannone Karma':       'cannoneKarma',
                'Pioggia Acida':       'pioggiaAcida',
                'Capsula Rigenerativa':'capsulaRigenerativa',
                'Saldi Estivi':        'saldiEstivi',
                'Gioco Pulito':        'giocoPulito',
                'Alta Marea':          'altaMarea',
                'Zebratura':           'zebratura',
                'Boomerang':           'boomerang',
                'Armatura Specchio':   'armaturaSpecchio',
                'Sabbie Mobili':       'sabbieMobili',
                'Domino':              'domino',
                'Contagio':            'contagio',
                '3 Molio':             'treMolio',
                'Nirvana':             'nirvana',
                'Minotauro Corrotto':  'minotauroCorreto'
            };

            // Handle names that include extra info (e.g. 'Alta Marea')
            const key = effectMap[name];
            if (key) {
                gfx[key] = false;
                gfx[key + 'Activator'] = null;
                if (key === 'boomerang') gfx.boomerangDamage = 0;
                gameState.history.push('‚ùå Effetto globale ' + name + ' rimosso dal Master');
                database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
            }
        }

        // ===== Remove single player effect =====
        function removePlayerEffect(playerIdx, effectKey) {
            if (!gameState.isMaster) return;
            const player = gameState.players[playerIdx];
            if (!player) return;
            switch (effectKey) {
                case 'immortal':        player.isImmortal = false; break;
                case 'multiplier':      player.multiplier = 1; player.multiplierAppliedBy = null; break;
                case 'skipTurn':        player.skipTurn = false; if (player.temporaryEffects) player.temporaryEffects.skipTurn = false; break;
                case 'customDice':      player.customDiceCount = null; break;
                case 'krakenMark':      player.krakenMark = false; break;
                case 'checkmate':       player.checkmateHP = null; break;
                case 'damageToHeal':    player.damageToHeal = false; break;
                case 'sunArmor':        player.sunArmor = false; break;
                case 'moonArmor':       player.moonArmor = false; break;
                case 'voloFenice':      player.voloFenice = false; break;
                case 'cactusAmari':     player.cactusAmari = false; break;
                case 'catenaMaledetta': player.catenaMaledetta = false; break;
                case 'rifletteDanni':   player.rifletteDanni = false; break;
                case 'mareGuai':        player.mareGuai = false; break;
                case 'cantoDelCigno':   player.cantoDelCigno = false; break;
                case 'pattoDiavolo':    player.pattoDiavolo = false; break;
                case 'tombaTutankhamon':player.tombaTutankhamon = false; break;
                case 'reincarnazione':  player.reincarnazione = false; break;
                case 'boiaEsecutore':   player.boiaEsecutore = false; player.boiaEsecutoreTurns = 0; break;
                case 'extraTurns':      player.extraTurns = 0; break;
                case 'protettoreFato':  player.protettoreFato = false; break;
                case 'tiroCaricato':    player.tiroCaricato = false; player.tiroCaricatoMultiplier = null; break;
                case 'dadoAvvelenato':  player.dadoAvvelenato = false; player.dadoAvvelenatotValues = []; break;
                case 'talismanRa':      player.talismanRa = false; player.talismanRaValues = []; break;
                case 'interferenza':    player.interferenza = false; player.interferenzaPartner = null; break;
                default: return;
            }
            gameState.history.push('‚ùå Effetto ' + effectKey + ' rimosso da ' + player.name + ' dal Master');
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }
        
        // ===== NEW: Remove all effects from all players =====
        function removeAllEffects() {
            if (!gameState.isMaster) return;
            if (!confirm('Rimuovere TUTTI gli effetti da TUTTI i giocatori?')) return;
            
            // Reset global effects
            const gfx = gameState.globalEffects;
            Object.keys(gfx).forEach(k => {
                if (typeof gfx[k] === 'boolean') gfx[k] = false;
                else if (typeof gfx[k] === 'number') gfx[k] = 0;
                else gfx[k] = null;
            });
            
            // Reset player effects
            gameState.players.forEach(p => {
                p.isImmortal = false;
                p.multiplier = 1;
                p.multiplierAppliedBy = null;
                p.skipTurn = false;
                p.customDiceCount = null;
                p.damageToHeal = false;
                p.sunArmor = false;
                p.moonArmor = false;
                p.mareGuai = false;
                p.voloFenice = false;
                p.cactusAmari = false;
                p.catenaMaledetta = false;
                p.rifletteDanni = false;
                p.extraTurns = 0;
                if (p.temporaryEffects) {
                    Object.keys(p.temporaryEffects).forEach(k => p.temporaryEffects[k] = false);
                }
            });
            
            gameState.history.push('üßπ Master ha rimosso TUTTI gli effetti da tutti i giocatori');
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }
        
        // ===== NEW: Set extra turns for a player =====
        function setExtraTurns() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('extra-turns-player');
            const turnsInput = document.getElementById('extra-turns-count');
            const playerIndex = parseInt(select.value);
            const turns = parseInt(turnsInput.value);
            
            if (isNaN(playerIndex) || isNaN(turns) || turns < 1 || turns > 5) {
                alert('Seleziona un giocatore e un numero di turni valido (1-5)!');
                return;
            }
            
            const player = gameState.players[playerIndex];
            player.extraTurns = turns;
            
            gameState.history.push('üîÑ ' + player.name + ' ha ' + turns + ' turni extra!');
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function playerCalcTarget() {
            const dice = [];
            for (let i = 0; i < 3; i++) {
                const v = parseInt(document.getElementById('player-tcalc-' + i).value);
                if (!v || v < 1 || v > 6) { alert('Inserisci valori validi (1-6)!'); return; }
                dice.push(v);
            }
            const sum = dice.reduce((a,b) => a+b, 0);
            
            // Use selected attivatore if present, otherwise fallback to self
            const attivatoreEl = document.getElementById('player-tcalc-attivatore');
            let shooterIdx;
            if (attivatoreEl && attivatoreEl.value !== '') {
                shooterIdx = parseInt(attivatoreEl.value);
            } else {
                shooterIdx = gameState.players.findIndex(p => p.name === gameState.playerName);
            }
            if (shooterIdx < 0) { alert('Giocatore non trovato!'); return; }
            
            const targetIdx = findTarget(sum, shooterIdx);
            const target = targetIdx >= 0 ? gameState.players[targetIdx] : null;
            const shooterName = gameState.players[shooterIdx]?.name || '?';
            const resultDiv = document.getElementById('player-target-result');
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = target
                ? `<div style="font-size:0.85em;color:#94a3b8;margin-bottom:3px;">Attivatore: <strong style="color:#facc15;">${shooterName}</strong></div>üéØ Bersaglio: <strong>${target.name}</strong> (Somma: ${sum})`
                : `<div style="font-size:0.85em;color:#94a3b8;margin-bottom:3px;">Attivatore: <strong style="color:#facc15;">${shooterName}</strong></div>‚ùå Nessun bersaglio`;
        }

        function quickSkipTurn() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('next-turn-player');
            const playerIndex = parseInt(select.value);
            if (isNaN(playerIndex)) { alert('Seleziona un giocatore!'); return; }
            const player = gameState.players[playerIndex];
            player.skipTurn = !player.skipTurn;
            if (player.temporaryEffects) player.temporaryEffects.skipTurn = player.skipTurn;
            const status = player.skipTurn ? 'attivato' : 'disattivato';
            gameState.history.push('‚è≠Ô∏è Salta Turno ' + status + ' per: ' + player.name);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

        // ===== EFFETTI FATO: selezione e chiusura automatica =====
        function selectFatoEffect(value) {
            document.querySelectorAll('.fato-panel').forEach(p => p.style.display = 'none');
            if (value) {
                const panel = document.getElementById('fato-' + value);
                if (panel) panel.style.display = 'block';
            }
        }

        // Generic: close a details accordion and scroll to top
        function closeAccordionAfter(detailsId, delay) {
            setTimeout(() => {
                const details = document.getElementById(detailsId);
                if (details) details.removeAttribute('open');
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }, delay || 400);
        }

        function closeFatoAfter() {
            setTimeout(() => {
                const details = document.getElementById('effetti-fato-details');
                if (details) details.removeAttribute('open');
                const sel = document.getElementById('fato-effect-select');
                if (sel) sel.value = '';
                document.querySelectorAll('.fato-panel').forEach(p => p.style.display = 'none');
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }, 400);
        }

        // ‚îÄ‚îÄ Delegated auto-close for all accordions ‚îÄ‚îÄ
        // Fato: close after any non-remove button inside a fato-panel
        document.addEventListener('click', function(e) {
            const btn = e.target.closest('button');
            if (!btn) return;

            // Fato panels
            const fatoPanel = btn.closest('.fato-panel');
            if (fatoPanel) {
                if (btn.textContent.includes('‚ùå') || btn.textContent.includes('Rimuovi')) return;
                closeFatoAfter();
                return;
            }

            // Other accordions: find parent details with id
            const parentDetails = btn.closest('details[id]');
            if (!parentDetails) return;
            const id = parentDetails.id;

            // Don't auto-close for remove/rimuovi buttons, or swap-hp, or end-game / new-game, QR, calc clear
            if (btn.textContent.includes('‚ùå') || btn.textContent.includes('Rimuovi')) return;
            if (btn.id === 'swap-hp-btn') return; // Scambia HP stays
            if (btn.id === 'end-game-btn' || btn.id === 'new-game-btn') return;
            if (btn.id === 'show-qr-btn') return;
            if (btn.textContent.trim() === 'üóëÔ∏è') return; // calc clear buttons
            if (btn.textContent.includes('= Calcola') || btn.textContent.includes('Calcola')) {
                // For calc expression only (no target) don't close
                if (id === 'accordion-calcolo' && !btn.textContent.includes('üéØ')) return;
            }

            const closeable = ['accordion-turni', 'accordion-calcolo', 'accordion-opzioni'];
            if (closeable.includes(id)) {
                closeAccordionAfter(id, 400);
            }
        });

        function setMasterNote() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('master-note-player');
            const playerIndex = parseInt(select.value);
            const noteInput = document.getElementById('master-note-text');
            const note = noteInput.value.trim();
            
            if (isNaN(playerIndex)) {
                alert('Seleziona un giocatore!');
                return;
            }
            
            const player = gameState.players[playerIndex];
            player.masterNote = note;
            
            if (note) {
                gameState.history.push(`üìù Nota aggiunta a ${player.name}: "${note}"`);
            } else {
                gameState.history.push(`‚ùå Nota rimossa da ${player.name}`);
            }
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
            
            // Pulisci il campo input
            noteInput.value = '';
        }

    </script>
</body>
</html>