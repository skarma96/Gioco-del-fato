<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Gioco del Fato</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Smooth scrolling */
        html {
            scroll-behavior: smooth;
            -webkit-text-size-adjust: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0f;
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(156, 39, 176, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(233, 30, 99, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(63, 81, 181, 0.15) 0%, transparent 50%);
            background-attachment: fixed;
            color: #e8e8e8;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            padding: max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right)) max(10px, env(safe-area-inset-bottom)) max(10px, env(safe-area-inset-left));
            overflow-x: hidden;
            transition: box-shadow 0.3s ease;
            position: relative;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* Rimuovere le stelle animate su mobile - troppo pesante */
        body::before {
            display: none;
        }
        
        /* Reduce animations on devices that prefer reduced motion */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        body.my-turn {
            box-shadow: inset 0 0 0 4px #00ff88;
        }
        
        /* Screen Flash Animations */
        @keyframes damageFlash {
            0% { background-color: rgba(255, 0, 0, 0); }
            50% { background-color: rgba(255, 0, 0, 0.3); }
            100% { background-color: rgba(255, 0, 0, 0); }
        }
        
        @keyframes healFlash {
            0% { background-color: rgba(78, 204, 163, 0); }
            50% { background-color: rgba(78, 204, 163, 0.25); }
            100% { background-color: rgba(78, 204, 163, 0); }
        }
        
        @keyframes reviveFlash {
            0% { background-color: rgba(255, 215, 0, 0); }
            25% { background-color: rgba(255, 215, 0, 0.3); }
            50% { background-color: rgba(78, 204, 163, 0.3); }
            75% { background-color: rgba(255, 215, 0, 0.3); }
            100% { background-color: rgba(255, 215, 0, 0); }
        }
        
        .screen-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
        }
        
        .screen-flash.damage {
            animation: damageFlash 0.4s ease-out;
        }
        
        .screen-flash.heal {
            animation: healFlash 0.5s ease-out;
        }
        
        .screen-flash.revive {
            animation: reviveFlash 1s ease-out;
        }
        
        /* Particle effects */
        .particle {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            font-size: 2em;
            animation: particleFloat 1.5s ease-out forwards;
        }
        
        @keyframes particleFloat {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(1) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translate(var(--tx), var(--ty)) scale(0.3) rotate(360deg);
            }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
            20%, 40%, 60%, 80% { transform: translateX(10px); }
        }
        
        body.shake {
            animation: shake 0.5s ease;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 15px;
            position: relative;
            z-index: 1;
        }

        h1 {
            text-align: center;
            background: linear-gradient(135deg, #ff00ff 0%, #00ffff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
            font-size: 2em;
            font-weight: 900;
            letter-spacing: 3px;
            position: relative;
            filter: drop-shadow(0 0 15px rgba(138, 43, 226, 0.6));
            text-transform: uppercase;
        }
        
        h1::before {
            content: 'üé≤ ';
        }
        
        h1::after {
            content: ' üé≤';
        }

        .setup-screen, .game-screen {
            background: rgba(20, 20, 40, 0.92);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s ease;
            position: relative;
            will-change: transform;
        }
        
        .setup-screen:active,
        .game-screen:active {
            transform: scale(0.99);
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #00ffff 0%, #ff00ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            font-size: 1em;
            letter-spacing: 1px;
            text-transform: uppercase;
            filter: drop-shadow(0 0 8px rgba(0, 255, 255, 0.6));
        }

        input, select {
            width: 100%;
            padding: 16px;
            min-height: 50px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 15px;
            background: rgba(10, 10, 30, 0.9);
            color: #00ffff;
            font-size: 16px;
            transition: all 0.4s ease;
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.5),
                0 0 0 rgba(0, 255, 255, 0);
            font-weight: 600;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #00ffff;
            background: rgba(0, 30, 50, 0.95);
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.5),
                0 0 30px rgba(0, 255, 255, 0.6),
                0 0 60px rgba(0, 255, 255, 0.3);
            transform: translateY(-2px);
            color: #fff;
        }
        
        input::placeholder {
            color: rgba(0, 255, 255, 0.5);
        }

        button {
            width: 100%;
            padding: 18px;
            min-height: 50px;
            background: linear-gradient(135deg, #ff00ff 0%, #00ffff 100%);
            color: #fff;
            border: none;
            border-radius: 15px;
            font-size: 17px;
            font-weight: 900;
            cursor: pointer;
            margin-top: 12px;
            transition: transform 0.2s ease, opacity 0.2s ease;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            -webkit-tap-highlight-color: transparent;
        }
        
        button:active {
            transform: scale(0.97);
            opacity: 0.9;
        }

        button:disabled {
            background: linear-gradient(135deg, #555 0%, #666 100%);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.5;
        }

        .player-input {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .player-input input {
            flex: 1;
        }

        .player-input button {
            width: auto;
            padding: 12px 20px;
            margin: 0;
            background: #dc3545;
        }

        #qrcode-container {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%);
            border-radius: 15px;
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
        }

        #qrcode {
            display: inline-block;
            max-width: 100%;
            height: auto;
        }
        
        #qrcode canvas,
        #qrcode img {
            max-width: 100% !important;
            height: auto !important;
            width: auto !important;
        }

        .share-link {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(30, 30, 45, 0.9) 0%, rgba(20, 20, 35, 0.8) 100%);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            word-break: break-all;
            font-size: 14px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .share-link strong {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .players-list {
            margin: 20px 0;
        }

        .player-card {
            background: linear-gradient(135deg, rgba(40, 20, 60, 0.9) 0%, rgba(20, 10, 40, 0.85) 100%);
            border-radius: 15px;
            padding: 18px;
            margin-bottom: 12px;
            border: 2px solid rgba(138, 43, 226, 0.3);
            border-left: 5px solid rgba(138, 43, 226, 0.6);
            transition: transform 0.2s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            position: relative;
        }
        
        .player-card:active {
            transform: scale(0.98);
        }

        .player-card.active-turn {
            border-left-color: #00ff88;
            border-left-width: 6px;
            background: linear-gradient(135deg, rgba(0, 100, 60, 0.3) 0%, rgba(0, 50, 40, 0.25) 100%);
            box-shadow: 
                0 4px 20px rgba(0, 255, 136, 0.4),
                inset 0 0 20px rgba(0, 255, 136, 0.15);
        }

        .player-card.eliminated {
            opacity: 0.5;
            border-left-color: #dc3545;
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-name {
            font-weight: 800;
            font-size: 1.2em;
            background: linear-gradient(135deg, #00ffff 0%, #ff00ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 0.5px;
            filter: drop-shadow(0 0 8px rgba(0, 255, 255, 0.5));
            word-wrap: break-word;
            line-height: 1.3;
            margin-bottom: 8px;
        }

        .player-hp {
            font-size: 1.8em;
            font-weight: 900;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8), 0 0 40px rgba(0, 255, 136, 0.4);
            letter-spacing: 1px;
        }

        .player-hp.low {
            color: #ff0066;
            text-shadow: 0 0 20px rgba(255, 0, 102, 0.8), 0 0 40px rgba(255, 0, 102, 0.4);
            animation: warning-pulse 1s infinite;
        }
        
        @keyframes warning-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .dice-calculator {
            background: linear-gradient(135deg, rgba(30, 30, 45, 0.8) 0%, rgba(20, 20, 35, 0.7) 100%);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .dice-inputs {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .dice-input {
            flex: 1;
            min-width: 60px;
        }

        .dice-input input {
            text-align: center;
            font-size: 2em;
            font-weight: 900;
            background: linear-gradient(135deg, rgba(10, 10, 40, 0.95) 0%, rgba(30, 10, 60, 0.9) 100%);
            border: 3px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            color: #00ffff;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
            box-shadow: 
                0 4px 15px rgba(0, 0, 0, 0.5),
                inset 0 2px 8px rgba(0, 0, 0, 0.6),
                0 0 20px rgba(0, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .dice-input input:focus {
            border-color: #ff00ff;
            background: linear-gradient(135deg, rgba(30, 10, 60, 1) 0%, rgba(60, 10, 80, 0.95) 100%);
            color: #ff00ff;
            text-shadow: 0 0 20px rgba(255, 0, 255, 1);
            box-shadow: 
                0 6px 20px rgba(255, 0, 255, 0.4),
                inset 0 2px 8px rgba(0, 0, 0, 0.6),
                0 0 40px rgba(255, 0, 255, 0.4);
            transform: scale(1.1) rotate(2deg);
        }

        .result-display {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.25) 0%, rgba(75, 0, 130, 0.15) 100%);
            border: 3px solid #ff00ff;
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            text-align: center;
            box-shadow: 0 0 25px rgba(255, 0, 255, 0.3);
            position: relative;
        }

        .result-display h3 {
            background: linear-gradient(135deg, #ff00ff 0%, #00ffff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 12px;
            font-size: 1.4em;
            font-weight: 900;
            filter: drop-shadow(0 0 8px rgba(255, 0, 255, 0.5));
            position: relative;
            z-index: 1;
        }

        .history {
            max-height: 250px;
            overflow-y: auto;
            background: rgba(10, 10, 20, 0.8);
            border: 2px solid rgba(255, 215, 0, 0.2);
            border-radius: 12px;
            padding: 15px 15px 15px 25px;
            margin: 15px 0;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        
        .history::before {
            content: '';
            position: absolute;
            left: 10px;
            top: 15px;
            bottom: 15px;
            width: 2px;
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.3) 0%, rgba(255, 215, 0, 0.1) 100%);
        }

        .history-item {
            padding: 12px 12px 12px 20px;
            margin-bottom: 12px;
            background: linear-gradient(135deg, rgba(30, 30, 45, 0.6) 0%, rgba(20, 20, 35, 0.5) 100%);
            border-left: 3px solid rgba(255, 215, 0, 0.4);
            border-radius: 8px;
            font-size: 0.9em;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .history-item::before {
            content: '';
            position: absolute;
            left: -18px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background: #ffd700;
            border-radius: 50%;
            border: 2px solid rgba(10, 10, 20, 0.8);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .history-item .icon {
            font-size: 1.2em;
            min-width: 25px;
            text-align: center;
        }
        
        .history-item.damage {
            border-left-color: #ff6b6b;
        }
        
        .history-item.damage::before {
            background: #ff6b6b;
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }
        
        .history-item.heal {
            border-left-color: #4ecca3;
        }
        
        .history-item.heal::before {
            background: #4ecca3;
            box-shadow: 0 0 10px rgba(78, 204, 163, 0.5);
        }
        
        .history-item.special {
            border-left-color: #ffd700;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15) 0%, rgba(255, 237, 78, 0.1) 100%);
        }
        
        .history-item:hover {
            background: linear-gradient(135deg, rgba(40, 40, 55, 0.7) 0%, rgba(30, 30, 45, 0.6) 100%);
            border-left-color: #ffd700;
            transform: translateX(3px);
        }

        .timer {
            text-align: center;
            font-size: 1.3em;
            font-weight: 800;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.3) 0%, rgba(75, 0, 130, 0.2) 100%);
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 15px;
            padding: 12px 20px;
            margin: 15px 0;
            color: #ff00ff;
            text-shadow: 0 0 15px rgba(255, 0, 255, 0.6);
            box-shadow: 
                0 0 20px rgba(138, 43, 226, 0.3),
                inset 0 0 15px rgba(138, 43, 226, 0.1);
            letter-spacing: 2px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .master-controls {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.08) 0%, rgba(255, 237, 78, 0.05) 100%);
            border: 2px solid rgba(255, 215, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 
                0 8px 25px rgba(255, 215, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .master-controls h3 {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 18px;
            text-align: center;
            font-size: 1.2em;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .control-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .control-group button {
            padding: 10px;
            font-size: 14px;
        }

        .hp-modifier {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 10px 0;
        }

        .hp-modifier input {
            width: 100%;
            font-size: 22px !important;
            padding: 20px !important;
            min-height: 65px !important;
            border: 3px solid rgba(0, 255, 255, 0.5) !important;
            background: rgba(10, 10, 30, 0.95) !important;
            color: #00ffff !important;
            border-radius: 12px !important;
            text-align: center;
            font-weight: bold;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .hp-modifier input:focus {
            outline: none;
            border-color: #ff00ff !important;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }

        .hp-modifier button {
            width: 100%;
            padding: 16px 15px;
            margin: 0;
            min-height: 55px;
            font-size: 16px;
        }

        .hidden {
            display: none;
        }

        .leaderboard {
            background: linear-gradient(135deg, rgba(30, 30, 45, 0.8) 0%, rgba(20, 20, 35, 0.7) 100%);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .leaderboard h3 {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.2em;
            font-weight: 700;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, rgba(30, 30, 45, 0.6) 0%, rgba(20, 20, 35, 0.5) 100%);
            border-left: 3px solid rgba(100, 100, 150, 0.5);
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .leaderboard-item:hover {
            background: linear-gradient(135deg, rgba(40, 40, 55, 0.7) 0%, rgba(30, 30, 45, 0.6) 100%);
            transform: translateX(5px);
        }

        .leaderboard-item.winner {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 237, 78, 0.15) 100%);
            border: 3px solid #ffd700;
            border-left: 5px solid #ffd700;
            box-shadow: 
                0 0 25px rgba(255, 215, 0, 0.4),
                inset 0 0 15px rgba(255, 215, 0, 0.1);
            font-weight: 700;
        }

        @keyframes damage {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        @keyframes heal {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .animate-damage {
            animation: damage 0.5s ease;
        }

        .animate-heal {
            animation: heal 0.5s ease;
        }

        .floating-number {
            position: fixed;
            font-size: 2em;
            font-weight: bold;
            pointer-events: none;
            animation: float-up 1s ease-out forwards;
            z-index: 1000;
        }

        .floating-number.damage {
            color: #ff6b6b;
        }

        .floating-number.heal {
            color: #4ecca3;
        }

        @keyframes float-up {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-100px); }
        }

        .direction-indicator {
            text-align: center;
            padding: 12px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.12) 0%, rgba(255, 237, 78, 0.08) 100%);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            margin: 10px 0;
            font-weight: 700;
            font-size: 1.05em;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.1);
        }
        
        /* QR Code Modal */
        .qr-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            padding: 20px;
        }
        
        .qr-modal.show {
            display: flex;
        }
        
        .qr-modal-content {
            background: linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%);
            border-radius: 20px;
            padding: 30px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
            text-align: center;
            position: relative;
        }
        
        .qr-modal-content h2 {
            color: #1a1a2e;
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        
        .qr-modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: #ff0066;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
        }
        
        .qr-modal-close:active {
            transform: scale(0.9);
        }
        
        .qr-modal #qrcode-modal {
            display: inline-block;
            margin: 20px 0;
        }
        
        .qr-modal .share-info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(138, 43, 226, 0.1);
            border: 2px solid rgba(138, 43, 226, 0.3);
            border-radius: 12px;
            color: #1a1a2e;
            font-weight: 600;
        }
        
        .qr-modal .game-code {
            font-size: 1.5em;
            color: #ff00ff;
            font-weight: 900;
            margin: 10px 0;
            letter-spacing: 2px;
        }

        @media (max-width: 480px) {
            body {
                padding: max(8px, env(safe-area-inset-top)) max(8px, env(safe-area-inset-right)) max(8px, env(safe-area-inset-bottom)) max(8px, env(safe-area-inset-left));
            }
            
            /* Fix per iOS - evita elementi che spariscono durante scroll */
            .player-card,
            .setup-screen,
            .game-screen,
            button,
            input,
            select {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
                backface-visibility: hidden;
                -webkit-backface-visibility: hidden;
            }
            
            .container {
                padding: 8px;
                -webkit-overflow-scrolling: touch;
            }
            
            h1 { 
                font-size: 1.6em;
                letter-spacing: 2px;
                margin-bottom: 15px;
            }
            
            h1::before,
            h1::after {
                font-size: 0.8em;
            }
            
            .setup-screen, .game-screen {
                padding: 18px 15px;
                border-radius: 18px;
            }
            
            label {
                font-size: 0.9em;
                margin-bottom: 6px;
            }
            
            input, select {
                padding: 14px 12px;
                font-size: 16px;
                border-radius: 12px;
            }
            
            button {
                padding: 16px 14px;
                font-size: 15px;
                letter-spacing: 1.5px;
                margin-top: 10px;
            }
            
            .player-card { 
                padding: 14px 12px;
                margin-bottom: 10px;
                border-radius: 12px;
            }
            
            .player-name {
                font-size: 1.1em !important;
            }
            
            .player-hp {
                font-size: 1.5em !important;
            }
            
            .dice-inputs { 
                gap: 8px;
                justify-content: center;
            }
            
            .dice-input {
                min-width: 70px;
                flex: 0 1 70px;
            }
            
            .dice-input input {
                font-size: 1.6em;
                padding: 12px 8px;
                height: 70px;
            }
            
            .control-group { 
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .winner-notification {
                padding: 30px 20px;
                min-width: 280px;
            }
            
            .winner-notification h2 {
                font-size: 1.8em;
            }
            
            .eliminated-notification {
                padding: 30px 20px;
                min-width: 280px;
            }
            
            .eliminated-notification h2 {
                font-size: 2em;
            }
            
            .result-display {
                padding: 16px 12px;
                border-radius: 12px;
            }
            
            .result-display h3 {
                font-size: 1.15em;
            }
            
            .dice-result {
                width: 40px;
                height: 40px;
                line-height: 40px;
                font-size: 20px;
                margin: 0 3px;
            }
            
            .history {
                max-height: 200px;
                padding: 12px 12px 12px 20px;
                margin: 12px 0;
            }
            
            .history-item {
                padding: 10px 10px 10px 15px;
                margin-bottom: 8px;
                font-size: 0.85em;
            }
            
            .timer {
                font-size: 1.1em;
                padding: 10px 15px;
                margin: 12px 0;
            }
            
            .direction-indicator {
                padding: 10px;
                font-size: 0.95em;
                margin: 8px 0;
            }
            
            #current-turn {
                font-size: 1.05em;
                margin: 12px 0;
            }
            
            .dice-calculator h3 {
                font-size: 1.1em;
                margin-bottom: 12px;
            }
            
            .master-controls h3 {
                font-size: 1.1em;
            }
            
            .qrcode-container {
                padding: 20px;
            }
            
            #qrcode canvas {
                max-width: 100%;
                height: auto !important;
                width: auto !important;
            }
            
            /* Miglioramenti touch per mobile */
            button,
            input,
            select,
            .dice-input input {
                touch-action: manipulation;
            }
            
            /* Testo pi√π leggibile */
            .player-card,
            .history-item,
            .result-display {
                line-height: 1.5;
            }
        }
        
        /* Extra small devices */
        @media (max-width: 360px) {
            h1 {
                font-size: 1.5em;
            }
            
            .dice-input {
                min-width: 60px;
                flex: 0 1 60px;
            }
            
            .dice-input input {
                font-size: 1.4em;
                height: 60px;
            }
            
            button {
                font-size: 14px;
                padding: 14px 12px;
            }
        }
        
        /* Landscape mode on mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .container {
                padding: 5px;
            }
            
            h1 {
                font-size: 1.3em;
                margin-bottom: 8px;
            }
            
            .setup-screen, .game-screen {
                padding: 12px;
            }
            
            .player-card {
                padding: 10px;
                margin-bottom: 8px;
            }
            
            input, select, button {
                padding: 10px;
            }
        }

        /* Eliminated Notification */
        .eliminated-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.98) 0%, rgba(50, 0, 0, 0.98) 100%);
            border: 4px solid #ff0000;
            border-radius: 20px;
            padding: 40px 30px;
            text-align: center;
            z-index: 2001;
            box-shadow: 
                0 0 60px rgba(255, 0, 0, 0.9),
                inset 0 0 40px rgba(255, 0, 0, 0.3);
            min-width: 300px;
            max-width: 90%;
        }

        .eliminated-notification.show {
            animation: eliminatedAppear 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
        }

        .eliminated-notification h2 {
            font-size: 2.5em;
            color: #ff0000;
            text-shadow: 0 0 30px rgba(255, 0, 0, 1);
            margin-bottom: 20px;
            font-weight: 900;
        }

        /* Winner Notification */
        .winner-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.98) 0%, rgba(255, 237, 78, 0.98) 100%);
            border: 5px solid #ffd700;
            border-radius: 25px;
            padding: 50px 40px;
            text-align: center;
            z-index: 2001;
            box-shadow: 
                0 0 80px rgba(255, 215, 0, 1),
                inset 0 0 50px rgba(255, 255, 255, 0.3);
            min-width: 320px;
            max-width: 90%;
        }

        .winner-notification.show {
            animation: winnerAppear 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
        }

        .winner-notification h2 {
            font-size: 2.8em;
            color: #1a1a2e;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            margin-bottom: 20px;
            font-weight: 900;
        }

        .winner-notification .winner-name {
            font-size: 2.2em;
            color: #1a1a2e;
            margin: 20px 0;
            font-weight: 900;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .game-stats {
            background: rgba(20, 20, 30, 0.9);
            border-radius: 15px;
            padding: 20px;
            margin-top: 25px;
            text-align: left;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .game-stats h3 {
            color: #ffd700;
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid #ffd700;
        }
        
        .stat-item .label {
            color: #e8e8e8;
            font-weight: 600;
        }
        
        .stat-item .value {
            color: #4ecca3;
            font-weight: 700;
        }

        .hit-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .hit-overlay.show {
            opacity: 1;
        }

        .hit-overlay.show {
            opacity: 1;
        }

        @keyframes eliminatedAppear {
            0% {
                transform: translate(-50%, -50%) scale(0) rotate(-180deg);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes winnerAppear {
            0% {
                transform: translate(-50%, -50%) scale(0) rotate(180deg);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2) rotate(-10deg);
            }
            100% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
                opacity: 1;
            }
        }
        
        /* Stili per i gruppi collassabili */
        .control-category {
            background: rgba(30, 30, 45, 0.6);
            border: 2px solid rgba(138, 43, 226, 0.3);
            border-radius: 12px;
            margin: 15px 0;
            overflow: hidden;
        }
        
        .control-category summary {
            padding: 15px 20px;
            font-size: 1.1em;
            font-weight: 700;
            cursor: pointer;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.2) 0%, rgba(75, 0, 130, 0.15) 100%);
            border-bottom: 1px solid rgba(138, 43, 226, 0.2);
            user-select: none;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
            color: #00ffff;
        }
        
        .control-category summary:hover {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.3) 0%, rgba(75, 0, 130, 0.25) 100%);
        }
        
        .control-category summary::-webkit-details-marker {
            display: none;
        }
        
        .control-category summary::before {
            content: '‚ñ∂';
            display: inline-block;
            width: 20px;
            transition: transform 0.3s ease;
        }
        
        .control-category[open] summary::before {
            transform: rotate(90deg);
        }
        
        .category-content {
            padding: 20px;
        }
        
        .control-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .control-group button {
            flex: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé≤ Gioco del Fato üé≤</h1>

        <!-- Setup Screen -->
        <div id="setup-screen" class="setup-screen">
            <!-- Auto role detection, no manual selection needed -->
            
            <!-- Master Setup -->
            <div id="master-setup" class="hidden">
                <div class="input-group">
                    <label>Il tuo nome (Master)</label>
                    <input type="text" id="master-name" placeholder="Inserisci il tuo nome">
                </div>
                <div class="input-group">
                    <label>Numero di giocatori (incluso te)</label>
                    <input type="number" id="num-players" min="2" max="18" value="4">
                </div>
                <div class="input-group">
                    <label>HP iniziali</label>
                    <input type="number" id="initial-hp" value="70">
                </div>
                <div id="player-names-container"></div>
                <button id="create-game-btn">Crea Partita</button>
            </div>

            <!-- Player Join -->
            <div id="player-join" class="hidden">
                <div class="input-group">
                    <label>Seleziona il tuo nome</label>
                    <select id="player-name-select">
                        <option value="">Caricamento...</option>
                    </select>
                </div>
                <button id="join-game-btn">Unisciti alla Partita</button>
                
                <div style="margin-top: 20px; text-align: center; color: #888; font-size: 0.9em;">
                    Codice Partita: <strong id="display-game-code" style="color: #ffd700;"></strong>
                </div>
            </div>

            <!-- QR Code Display -->
            <div id="qr-display" class="hidden">
                <h3 style="color: #ffd700; text-align: center;">Partita Creata!</h3>
                <div id="qrcode-container">
                    <div id="qrcode"></div>
                </div>
                <div class="share-link">
                    <strong>Codice Partita:</strong><br>
                    <span id="game-code-display"></span>
                </div>
                <div style="margin-top: 15px; padding: 15px; background: rgba(78, 204, 163, 0.1); border: 2px solid rgba(78, 204, 163, 0.3); border-radius: 10px;">
                    <div style="color: #4ecca3; font-weight: bold; margin-bottom: 8px;">üë• Giocatori Connessi:</div>
                    <div id="connected-players-list"></div>
                </div>
                <button id="start-game-btn">Inizia Partita</button>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="game-screen hidden">
            <div class="timer" id="timer">Tempo: 00:00</div>
            
            <div class="direction-indicator" id="direction">
                Direzione: ‚≠Æ Oraria
            </div>

            <div id="current-turn" style="text-align: center; font-size: 1.2em; color: #ffd700; margin: 15px 0;">
                Turno di: <strong id="turn-player"></strong>
            </div>

            <!-- Dice Calculator -->
            <div class="dice-calculator" id="dice-calculator">
                <h3 style="color: #ffd700; text-align: center;">Calcolatore Dadi</h3>
                <div class="dice-inputs" id="dice-inputs"></div>
                <button id="calculate-btn">Calcola e Applica</button>
                <div class="result-display hidden" id="result-display">
                    <h3>Risultato</h3>
                    <div id="result-text"></div>
                </div>
            </div>

            <!-- Players List -->
            <div class="players-list" id="players-list"></div>

            <!-- Leaderboard -->
            <div class="leaderboard">
                <h3>üìä Classifica</h3>
                <div id="leaderboard-list"></div>
            </div>

            <!-- History -->
            <div class="history" id="history"></div>

            <!-- Master Controls -->
                        <!-- Master Controls -->
            <div id="master-controls" class="master-controls hidden">
                <h3>üëë Controlli Master</h3>
                
                <!-- Calcolatrice Avanzata -->
                <details class="control-category">
                    <summary>üßÆ Strumenti di Calcolo</summary>
                    <div class="category-content">
                        <div class="input-group">
                            <label>Calcolatrice (somma/sottrazione fino a 20 numeri)</label>
                            <div id="calculator-inputs" style="display: flex; flex-direction: column; gap: 8px; margin: 10px 0;">
                                <input type="text" id="calc-input" placeholder="Es: 5 + 3 - 2 + 10" style="font-size: 1.1em;">
                                <div style="display: flex; gap: 10px;">
                                    <button onclick="calculateExpression()" style="flex: 1;">= Calcola</button>
                                    <button onclick="clearCalculator()" style="flex: 1; background: #dc3545;">üóëÔ∏è Pulisci</button>
                                </div>
                                <div id="calc-result" style="background: rgba(0,255,255,0.1); padding: 12px; border-radius: 8px; display: none; font-size: 1.2em; font-weight: 700; color: #00ffff; text-align: center;"></div>
                            </div>
                        </div>
                        
                        <div class="input-group">
                            <label>Calcolo Bersaglio (senza applicare danno)</label>
                            <div class="dice-inputs" id="target-calc-dice">
                                <div class="dice-input"><input type="number" id="tcalc-dice-0" min="1" max="6" placeholder="D1"></div>
                                <div class="dice-input"><input type="number" id="tcalc-dice-1" min="1" max="6" placeholder="D2"></div>
                                <div class="dice-input"><input type="number" id="tcalc-dice-2" min="1" max="6" placeholder="D3"></div>
                            </div>
                            <div style="margin: 10px 0;">
                                <label style="font-size: 0.9em; color: #888;">Direzione:</label>
                                <select id="target-calc-direction" style="margin-left: 8px; padding: 4px 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: #fff; border-radius: 4px;">
                                    <option value="clockwise">üîÑ Orario</option>
                                    <option value="counterclockwise">üîÉ Antiorario</option>
                                </select>
                            </div>
                            <button onclick="calculateTargetOnly()">üéØ Calcola Bersaglio</button>
                            <div id="target-calc-result" style="background: rgba(255,0,255,0.1); padding: 12px; border-radius: 8px; display: none; margin-top: 10px; color: #ff00ff; font-weight: 600;"></div>
                        </div>
                    </div>
                </details>

                <!-- Controlli Base -->
                <details class="control-category">
                    <summary>‚öôÔ∏è Controlli Base</summary>
                    <div class="category-content">
                        <div class="control-group">
                            <button id="reverse-direction-btn">üîÑ Inverti Direzione</button>
                            <button id="rollback-btn">‚Ü©Ô∏è Annulla Ultima</button>
                        </div>
                        
                        <div class="input-group">
                            <label>Mostra QR Code per Rientro</label>
                            <select id="qr-player-select"></select>
                            <button id="show-qr-btn">üì± Mostra QR Code</button>
                        </div>
                        
                        <div class="input-group">
                            <label>Cambia Turno</label>
                            <select id="next-turn-player"></select>
                            <button id="change-turn-btn">‚è≠Ô∏è Cambia Turno</button>
                        </div>

                        <div class="input-group">
                            <label>Applica Danni Personalizzati (con attivazione effetti)</label>
                            <label style="font-size: 0.9em; color: #888;">Attivatore (chi infligge i danni):</label>
                            <select id="damage-activator-select"></select>
                            <label style="font-size: 0.9em; color: #888; margin-top: 8px;">Bersagli (tieni premuto Ctrl/Cmd per multipli):</label>
                            <select id="target-players" multiple size="5"></select>
                            <div class="hp-modifier">
                                <input type="number" id="hp-amount" placeholder="Valore HP">
                                <button id="damage-btn">üí• Danno (con effetti)</button>
                                <button id="heal-btn">üíö Cura</button>
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Scambia HP tra Giocatori</label>
                            <select id="swap-player-1"></select>
                            <select id="swap-player-2" style="margin-top: 10px;"></select>
                            <button id="swap-hp-btn">üîÑ Scambia HP</button>
                        </div>
                    </div>
                </details>

                <!-- Effetti Permanenti -->
                <details class="control-category">
                    <summary>‚ôæÔ∏è Effetti Permanenti</summary>
                    <div class="category-content">
                        <div class="input-group">
                            <label>Marchio del Kraken üêô (seleziona uno o pi√π giocatori)</label>
                            <select id="kraken-mark-players" multiple size="5"></select>
                            <button id="toggle-kraken-mark-btn" style="background: linear-gradient(135deg, #1a0033 0%, #330066 100%); border: 2px solid #9933ff;">üêô Attiva/Disattiva Marchio</button>
                            <div style="font-size: 0.85em; color: #ff6b6b; margin-top: 8px; padding: 8px; background: rgba(255,0,0,0.1); border-radius: 8px; border: 1px solid rgba(255,0,0,0.3);">
                                ‚ö†Ô∏è <strong>Effetto permanente:</strong> Eliminazione automatica a 10 HP o meno
                            </div>
                        </div>
                        
                        <div class="input-group">
                            <label>Scacco Matto ‚ôüÔ∏è (seleziona uno o pi√π giocatori)</label>
                            <select id="checkmate-players" multiple size="5"></select>
                            <div class="hp-modifier">
                                <input type="number" id="checkmate-value" placeholder="HP di eliminazione" min="1" max="100" value="30">
                                <button id="set-checkmate-btn" style="background: linear-gradient(135deg, #1a0033 0%, #4d0000 100%); border: 2px solid #ff3333;">‚ôüÔ∏è Imposta Scacco Matto</button>
                                <button id="remove-checkmate-btn" style="background: #dc3545;">‚ùå Rimuovi</button>
                            </div>
                            <div style="font-size: 0.85em; color: #ff6b6b; margin-top: 8px; padding: 8px; background: rgba(255,0,0,0.1); border-radius: 8px; border: 1px solid rgba(255,0,0,0.3);">
                                ‚ö†Ô∏è <strong>Effetto permanente:</strong> Eliminazione automatica al valore HP specificato
                            </div>
                        </div>
                    </div>
                </details>

                <!-- Effetti Temporanei (1 Turno) -->
                <details class="control-category">
                    <summary>‚è±Ô∏è Effetti Temporanei (1 Turno)</summary>
                    <div class="category-content">
                        <div class="input-group">
                            <label>Immortalit√† (seleziona uno o pi√π giocatori - Ctrl/Cmd per multipli)</label>
                            <select id="immortal-players" multiple size="5"></select>
                            <button id="toggle-immortality-btn">‚≠ê Attiva/Disattiva Immortalit√†</button>
                        </div>
                        
                        <div class="input-group">
                            <label>Moltiplicatore Danni/Cure (seleziona uno o pi√π giocatori)</label>
                            <select id="multiplier-players" multiple size="5"></select>
                            <div class="hp-modifier">
                                <button id="set-multiplier-half-btn" style="background: linear-gradient(135deg, #1a4d1a 0%, #2d7a2d 100%);">üõ°Ô∏è Met√† Danni (x0.5)</button>
                                <button id="set-multiplier-double-btn" style="background: linear-gradient(135deg, #4d1a1a 0%, #7a2d2d 100%);">‚öîÔ∏è Danni Doppi (x2)</button>
                                <button id="remove-multiplier-btn" style="background: #dc3545;">‚ùå Rimuovi</button>
                            </div>
                            <div style="font-size: 0.85em; color: #aaa; margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                                üí° Il moltiplicatore dura fino al prossimo turno di chi lo ha applicato
                            </div>
                        </div>
                        
                        <div class="input-group">
                            <label>Salta Turno (seleziona uno o pi√π giocatori)</label>
                            <select id="skip-turn-players" multiple size="5"></select>
                            <button id="toggle-skip-turn-btn">‚è≠Ô∏è Attiva/Disattiva Salta Turno</button>
                        </div>
                        
                        <div class="input-group">
                            <label>Conversione Danni ‚Üí Cure üí´ (seleziona uno o pi√π giocatori)</label>
                            <select id="damage-to-heal-players" multiple size="5"></select>
                            <button id="toggle-damage-to-heal-btn" style="background: linear-gradient(135deg, #ff1493 0%, #ff69b4 100%);">üí´ Attiva/Disattiva Conversione</button>
                            <div style="font-size: 0.85em; color: #ff69b4; margin-top: 8px; padding: 8px; background: rgba(255,20,147,0.1); border-radius: 8px;">
                                üí° Dura 1 turno - I danni subiti diventano cure
                            </div>
                        </div>
                        
                        <div class="input-group">
                            <label>Armatura del Sole ‚òÄÔ∏è (seleziona uno o pi√π giocatori)</label>
                            <select id="sun-armor-players" multiple size="5"></select>
                            <button id="toggle-sun-armor-btn" style="background: linear-gradient(135deg, #ff8c00 0%, #ffd700 100%);">‚òÄÔ∏è Attiva/Disattiva Armatura Sole</button>
                            <div style="font-size: 0.85em; color: #ffa500; margin-top: 8px; padding: 8px; background: rgba(255,140,0,0.1); border-radius: 8px;">
                                üí° Dura 1 turno - Danni dispari diventano cure
                            </div>
                        </div>
                        
                        <div class="input-group">
                            <label>Armatura della Luna üåô (seleziona uno o pi√π giocatori)</label>
                            <select id="moon-armor-players" multiple size="5"></select>
                            <button id="toggle-moon-armor-btn" style="background: linear-gradient(135deg, #191970 0%, #4169e1 100%);">üåô Attiva/Disattiva Armatura Luna</button>
                            <div style="font-size: 0.85em; color: #87ceeb; margin-top: 8px; padding: 8px; background: rgba(25,25,112,0.2); border-radius: 8px;">
                                üí° Dura 1 turno - Danni pari diventano cure
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Dadi Personalizzati (seleziona uno o pi√π giocatori)</label>
                            <select id="custom-dice-players" multiple size="5"></select>
                            <div class="hp-modifier">
                                <input type="number" id="custom-dice-value" placeholder="Numero dadi (1-6)" min="1" max="6" value="3">
                                <button id="set-custom-dice-btn">üé≤ Imposta Dadi</button>
                                <button id="remove-custom-dice-btn" style="background: #dc3545;">‚ùå Rimuovi</button>
                            </div>
                            <div style="font-size: 0.85em; color: #aaa; margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                                üí° I dadi personalizzati durano solo per il prossimo turno del giocatore
                            </div>
                        </div>
                    </div>
                </details>

<!-- Continua nel prossimo messaggio... -->
                <!-- Nuove Meccaniche Globali -->
                <details class="control-category">
                    <summary>üåç Meccaniche Globali (Tutti i Giocatori)</summary>
                    <div class="category-content">
                        <div class="input-group">
                            <label>Cessate il Fuoco üïäÔ∏è</label>
                            <select id="cessate-fuoco-activator" style="margin-bottom: 10px;">
                                <option value="">Seleziona Attivatore</option>
                            </select>
                            <button id="toggle-cessate-fuoco-btn" style="background: linear-gradient(135deg, #4CAF50 0%, #8BC34A 100%);">üïäÔ∏è Attiva/Disattiva Cessate il Fuoco</button>
                            <div style="font-size: 0.85em; color: #4CAF50; margin-top: 8px; padding: 8px; background: rgba(76,175,80,0.1); border-radius: 8px;">
                                üí° Per 1 turno completo: tutti curano invece di danneggiare. L'attivatore si cura della met√† del danno di ogni giocata altrui
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Di Pari Pazzo üé≤</label>
                            <select id="pari-pazzo-activator" style="margin-bottom: 10px;">
                                <option value="">Seleziona Attivatore</option>
                            </select>
                            <button id="toggle-pari-pazzo-btn" style="background: linear-gradient(135deg, #FF5722 0%, #FF9800 100%);">üé≤ Attiva/Disattiva Di Pari Pazzo</button>
                            <div style="font-size: 0.85em; color: #FF5722; margin-top: 8px; padding: 8px; background: rgba(255,87,34,0.1); border-radius: 8px;">
                                üí° Per 1 turno completo: chi ottiene somma pari subisce danno pari alla propria giocata
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Bambola Voodoo ü™Ü</label>
                            <select id="bambola-voodoo-activator" style="margin-bottom: 10px;">
                                <option value="">Seleziona Attivatore</option>
                            </select>
                            <button id="toggle-bambola-voodoo-btn" style="background: linear-gradient(135deg, #9C27B0 0%, #E91E63 100%);">ü™Ü Attiva/Disattiva Bambola Voodoo</button>
                            <div style="font-size: 0.85em; color: #9C27B0; margin-top: 8px; padding: 8px; background: rgba(156,39,176,0.1); border-radius: 8px;">
                                üí° Per 1 turno completo (escluso attivatore): ogni giocatore infligge danni a s√© stesso
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Cannone del Karma üí•</label>
                            <select id="cannone-karma-activator" style="margin-bottom: 10px;">
                                <option value="">Seleziona Attivatore</option>
                            </select>
                            <button id="toggle-cannone-karma-btn" style="background: linear-gradient(135deg, #F44336 0%, #B71C1C 100%);">üí• Attiva/Disattiva Cannone Karma</button>
                            <div style="font-size: 0.85em; color: #F44336; margin-top: 8px; padding: 8px; background: rgba(244,67,54,0.1); border-radius: 8px;">
                                üí° Per 1 turno completo (escluso attivatore): tutti infliggono danni sia al bersaglio che a s√© stessi
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Pioggia Acida ‚òî</label>
                            <select id="pioggia-acida-activator" style="margin-bottom: 10px;">
                                <option value="">Seleziona Attivatore</option>
                            </select>
                            <button id="toggle-pioggia-acida-btn" style="background: linear-gradient(135deg, #4CAF50 0%, #FFC107 100%);">‚òî Attiva/Disattiva Pioggia Acida</button>
                            <div style="font-size: 0.85em; color: #4CAF50; margin-top: 8px; padding: 8px; background: rgba(76,175,80,0.1); border-radius: 8px;">
                                üí° Per 1 turno completo (escluso attivatore): ogni giocatore subisce danno pari al dado pi√π alto ottenuto
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Capsula Rigenerativa üíä</label>
                            <select id="capsula-rigenerativa-activator" style="margin-bottom: 10px;">
                                <option value="">Seleziona Attivatore</option>
                            </select>
                            <button id="toggle-capsula-rigenerativa-btn" style="background: linear-gradient(135deg, #00BCD4 0%, #03A9F4 100%);">üíä Attiva/Disattiva Capsula Rigenerativa</button>
                            <div style="font-size: 0.85em; color: #00BCD4; margin-top: 8px; padding: 8px; background: rgba(0,188,212,0.1); border-radius: 8px;">
                                üí° Per 1 turno completo (incluso attivatore): ogni lancio fa guadagnare punti vita
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Saldi Estivi üèñÔ∏è</label>
                            <select id="saldi-estivi-activator" style="margin-bottom: 10px;">
                                <option value="">Seleziona Attivatore</option>
                            </select>
                            <button id="toggle-saldi-estivi-btn" style="background: linear-gradient(135deg, #FFEB3B 0%, #FFC107 100%);">üèñÔ∏è Attiva/Disattiva Saldi Estivi</button>
                            <div style="font-size: 0.85em; color: #FFC107; margin-top: 8px; padding: 8px; background: rgba(255,193,7,0.1); border-radius: 8px;">
                                üí° Per 1 turno completo: tutti i danni inflitti sono dimezzati
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Gioco Pulito ‚öñÔ∏è</label>
                            <select id="gioco-pulito-activator" style="margin-bottom: 10px;">
                                <option value="">Seleziona Attivatore</option>
                            </select>
                            <button id="toggle-gioco-pulito-btn" style="background: linear-gradient(135deg, #607D8B 0%, #90A4AE 100%);">‚öñÔ∏è Attiva/Disattiva Gioco Pulito</button>
                            <div style="font-size: 0.85em; color: #607D8B; margin-top: 8px; padding: 8px; background: rgba(96,125,139,0.1); border-radius: 8px;">
                                üí° Per 1 turno completo: annulla coppie/tris e disattiva tutti gli altri effetti
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Trottola Impazzita üåÄ</label>
                            <button id="trottola-impazzita-btn" style="background: linear-gradient(135deg, #9C27B0 0%, #673AB7 100%);">üåÄ Attiva Trottola Impazzita</button>
                            <div style="font-size: 0.85em; color: #9C27B0; margin-top: 8px; padding: 8px; background: rgba(156,39,176,0.1); border-radius: 8px;">
                                üí° Effetto immediato: trasferisce tutti gli HP al giocatore successivo nel senso di gioco
                            </div>
                        </div>

                        <div class="input-group">
                            <label>La Tartaruga e la Lepre üê¢üê∞</label>
                            <button id="tartaruga-lepre-btn" style="background: linear-gradient(135deg, #8BC34A 0%, #CDDC39 100%);">üê¢üê∞ Attiva Tartaruga e Lepre</button>
                            <div style="font-size: 0.85em; color: #8BC34A; margin-top: 8px; padding: 8px; background: rgba(139,195,74,0.1); border-radius: 8px;">
                                üí° Effetto immediato: il giocatore con pi√π HP perde met√† HP, distribuiti agli altri
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Yin e Yang ‚òØÔ∏è</label>
                            <button id="yin-yang-btn" style="background: linear-gradient(135deg, #000000 0%, #FFFFFF 100%); color: #FFD700;">‚òØÔ∏è Attiva Yin e Yang</button>
                            <div style="font-size: 0.85em; color: #666; margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.05); border-radius: 8px; border: 1px solid #ccc;">
                                üí° Effetto immediato: tutti i giocatori impostano HP a met√† degli HP iniziali
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Bilancia del Fato ‚öñÔ∏è</label>
                            <button id="bilancia-fato-btn" style="background: linear-gradient(135deg, #795548 0%, #A1887F 100%);">‚öñÔ∏è Attiva Bilancia del Fato</button>
                            <div style="font-size: 0.85em; color: #795548; margin-top: 8px; padding: 8px; background: rgba(121,85,72,0.1); border-radius: 8px;">
                                üí° Effetto immediato: differenza tra HP iniziali e attuali diventa il nuovo valore HP
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Uguaglianza ‚öñÔ∏è</label>
                            <div class="hp-modifier">
                                <input type="number" id="uguaglianza-divisor" placeholder="Divisore (1-18)" min="1" max="18" value="1">
                                <button id="uguaglianza-btn" style="background: linear-gradient(135deg, #3F51B5 0%, #5C6BC0 100%);">‚öñÔ∏è Attiva Uguaglianza</button>
                            </div>
                            <div style="font-size: 0.85em; color: #3F51B5; margin-top: 8px; padding: 8px; background: rgba(63,81,181,0.1); border-radius: 8px;">
                                üí° Effetto immediato: somma tutti gli HP, divide per il numero inserito, redistribuisce
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Geyser di Fuoco üî•</label>
                            <div class="hp-modifier">
                                <input type="number" id="geyser-damage" placeholder="Danno base" min="1" max="100" value="6">
                                <button id="geyser-fuoco-btn" style="background: linear-gradient(135deg, #FF5722 0%, #FF9800 100%);">üî• Attiva Geyser di Fuoco</button>
                            </div>
                            <div style="font-size: 0.85em; color: #FF5722; margin-top: 8px; padding: 8px; background: rgba(255,87,34,0.1); border-radius: 8px;">
                                üí° Effetto immediato: danni progressivi dal giocatore successivo (x1, x2, x3...). Attivatore immune
                            </div>
                        </div>
                    </div>
                </details>

                <!-- Meccaniche Su Singoli Giocatori -->
                <details class="control-category">
                    <summary>üë§ Meccaniche Su Singoli Giocatori</summary>
                    <div class="category-content">
                        <div class="input-group">
                            <label>Un Mare di Guai üåä (seleziona uno o pi√π giocatori)</label>
                            <select id="mare-guai-players" multiple size="5"></select>
                            <button id="toggle-mare-guai-btn" style="background: linear-gradient(135deg, #00BCD4 0%, #0097A7 100%);">üåä Attiva/Disattiva Mare di Guai</button>
                            <div style="font-size: 0.85em; color: #00BCD4; margin-top: 8px; padding: 8px; background: rgba(0,188,212,0.1); border-radius: 8px;">
                                üí° Per 1 turno: se colpito, danno duplicato all'attaccante che salta il turno successivo
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Talismano di Ra üåû (seleziona giocatore e inserisci valori)</label>
                            <select id="talismano-ra-player"></select>
                            <div style="display: flex; gap: 10px; margin: 10px 0;">
                                <input type="number" id="talismano-ra-val1" placeholder="Dado 1 (1-6)" min="1" max="6" style="flex: 1;">
                                <input type="number" id="talismano-ra-val2" placeholder="Dado 2 (1-6)" min="1" max="6" style="flex: 1;">
                            </div>
                            <button id="set-talismano-ra-btn" style="background: linear-gradient(135deg, #FFC107 0%, #FFD54F 100%);">üåû Imposta Talismano Ra</button>
                            <button id="remove-talismano-ra-btn" style="background: #dc3545;">‚ùå Rimuovi</button>
                            <div style="font-size: 0.85em; color: #FFC107; margin-top: 8px; padding: 8px; background: rgba(255,193,7,0.1); border-radius: 8px;">
                                üí° Per 1 turno: guadagna HP = prodotto dei dadi quando altri giocatori ottengono quei valori
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Dado Avvelenato ‚ò†Ô∏è (seleziona giocatore e inserisci valori)</label>
                            <select id="dado-avvelenato-player"></select>
                            <div style="display: flex; gap: 10px; margin: 10px 0;">
                                <input type="number" id="dado-avvelenato-val1" placeholder="Dado 1 (1-6)" min="1" max="6" style="flex: 1;">
                                <input type="number" id="dado-avvelenato-val2" placeholder="Dado 2 (1-6)" min="1" max="6" style="flex: 1;">
                            </div>
                            <button id="set-dado-avvelenato-btn" style="background: linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%);">‚ò†Ô∏è Imposta Dado Avvelenato</button>
                            <button id="remove-dado-avvelenato-btn" style="background: #dc3545;">‚ùå Rimuovi</button>
                            <div style="font-size: 0.85em; color: #4CAF50; margin-top: 8px; padding: 8px; background: rgba(76,175,80,0.1); border-radius: 8px;">
                                üí° Per 1 turno: infligge danni = prodotto dei dadi a chi ottiene quei valori
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Interferenza üîÄ (seleziona 2 giocatori)</label>
                            <select id="interferenza-player1"></select>
                            <select id="interferenza-player2" style="margin-top: 10px;"></select>
                            <button id="set-interferenza-btn" style="background: linear-gradient(135deg, #9C27B0 0%, #BA68C8 100%);">üîÄ Imposta Interferenza</button>
                            <button id="remove-interferenza-btn" style="background: #dc3545;">‚ùå Rimuovi</button>
                            <div style="font-size: 0.85em; color: #9C27B0; margin-top: 8px; padding: 8px; background: rgba(156,39,176,0.1); border-radius: 8px;">
                                üí° Per 1 turno: quando player1 viene colpito, danni trasferiti a player2
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Volo della Fenice ü¶Ö (seleziona giocatore)</label>
                            <select id="volo-fenice-players" multiple size="5"></select>
                            <button id="toggle-volo-fenice-btn" style="background: linear-gradient(135deg, #FF5722 0%, #FF9800 100%);">ü¶Ö Attiva/Disattiva Volo Fenice</button>
                            <div style="font-size: 0.85em; color: #FF5722; margin-top: 8px; padding: 8px; background: rgba(255,87,34,0.1); border-radius: 8px;">
                                üí° Per 1 turno: riceve cure raddoppiate al posto dei danni
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Cactus Amari üåµ (seleziona giocatore)</label>
                            <select id="cactus-amari-players" multiple size="5"></select>
                            <button id="toggle-cactus-amari-btn" style="background: linear-gradient(135deg, #8BC34A 0%, #AED581 100%);">üåµ Attiva/Disattiva Cactus Amari</button>
                            <div style="font-size: 0.85em; color: #8BC34A; margin-top: 8px; padding: 8px; background: rgba(139,195,74,0.1); border-radius: 8px;">
                                üí° Per 1 turno: quando colpito, subisce danno e riflette il doppio all'attaccante
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Catena Maledetta ‚õìÔ∏è (seleziona giocatore)</label>
                            <select id="catena-maledetta-players" multiple size="5"></select>
                            <button id="toggle-catena-maledetta-btn" style="background: linear-gradient(135deg, #607D8B 0%, #78909C 100%);">‚õìÔ∏è Attiva/Disattiva Catena Maledetta</button>
                            <div style="font-size: 0.85em; color: #607D8B; margin-top: 8px; padding: 8px; background: rgba(96,125,139,0.1); border-radius: 8px;">
                                üí° Per 1 turno: quando colpito, infligge stesso danno ai giocatori adiacenti
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Alta Marea üåä (seleziona attivatore)</label>
                            <select id="alta-marea-player"></select>
                            <button id="set-alta-marea-btn" style="background: linear-gradient(135deg, #00BCD4 0%, #00ACC1 100%);">üåä Imposta Alta Marea</button>
                            <button id="remove-alta-marea-btn" style="background: #dc3545;">‚ùå Rimuovi</button>
                            <div style="font-size: 0.85em; color: #00BCD4; margin-top: 8px; padding: 8px; background: rgba(0,188,212,0.1); border-radius: 8px;">
                                üí° Fino al turno successivo dell'attivatore: HP>50% danni x2, HP<50% danni /2
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Zebratura ü¶ì (seleziona attivatore)</label>
                            <select id="zebratura-player"></select>
                            <button id="set-zebratura-btn" style="background: linear-gradient(135deg, #000000 0%, #FFFFFF 100%); color: #FFD700;">ü¶ì Imposta Zebratura</button>
                            <button id="remove-zebratura-btn" style="background: #dc3545;">‚ùå Rimuovi</button>
                            <div style="font-size: 0.85em; color: #666; margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.05); border-radius: 8px; border: 1px solid #ccc;">
                                üí° Fino al turno successivo dell'attivatore: somme pari curano, somme dispari danneggiano
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Rifletti Danni üõ°Ô∏è (seleziona giocatore)</label>
                            <select id="rifletti-danni-players" multiple size="5"></select>
                            <button id="toggle-rifletti-danni-btn" style="background: linear-gradient(135deg, #2196F3 0%, #64B5F6 100%);">üõ°Ô∏è Attiva/Disattiva Rifletti Danni</button>
                            <div style="font-size: 0.85em; color: #2196F3; margin-top: 8px; padding: 8px; background: rgba(33,150,243,0.1); border-radius: 8px;">
                                üí° Per 1 turno: riflette danni ricevuti sull'attaccante
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Boomerang ü™É (seleziona attivatore)</label>
                            <select id="boomerang-player"></select>
                            <button id="set-boomerang-btn" style="background: linear-gradient(135deg, #FF9800 0%, #FFB74D 100%);">ü™É Imposta Boomerang</button>
                            <button id="remove-boomerang-btn" style="background: #dc3545;">‚ùå Rimuovi</button>
                            <div style="font-size: 0.85em; color: #FF9800; margin-top: 8px; padding: 8px; background: rgba(255,152,0,0.1); border-radius: 8px;">
                                üí° Fino al turno successivo: non subisce danni, che vengono accumulati e inflitti a tutti
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Armatura a Specchio ü™û (seleziona attivatore)</label>
                            <select id="armatura-specchio-player"></select>
                            <button id="set-armatura-specchio-btn" style="background: linear-gradient(135deg, #00BCD4 0%, #80DEEA 100%);">ü™û Imposta Armatura Specchio</button>
                            <button id="remove-armatura-specchio-btn" style="background: #dc3545;">‚ùå Rimuovi</button>
                            <div style="font-size: 0.85em; color: #00BCD4; margin-top: 8px; padding: 8px; background: rgba(0,188,212,0.1); border-radius: 8px;">
                                üí° Fino al turno successivo: danni distribuiti equamente tra tutti (incluso s√© stesso)
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Sabbie Mobili ‚è≥ (seleziona attivatore)</label>
                            <select id="sabbie-mobili-player"></select>
                            <button id="set-sabbie-mobili-btn" style="background: linear-gradient(135deg, #FFC107 0%, #FFD54F 100%);">‚è≥ Imposta Sabbie Mobili</button>
                            <button id="remove-sabbie-mobili-btn" style="background: #dc3545;">‚ùå Rimuovi</button>
                            <div style="font-size: 0.85em; color: #FFC107; margin-top: 8px; padding: 8px; background: rgba(255,193,7,0.1); border-radius: 8px;">
                                üí° Fino al turno successivo: ogni giocatore colpito salta il turno successivo (escluso attivatore)
                            </div>
                        </div>
                    </div>
                </details>

                <!-- Resurrezione e Effetti Speciali -->
                <details class="control-category">
                    <summary>üíÄ Resurrezione e Carte Speciali</summary>
                    <div class="category-content">
                        <button id="revive-btn">üîÑ Rianimazione</button>
                        
                        <div class="input-group">
                            <label>Canto del Cigno ü¶¢ (seleziona giocatore)</label>
                            <select id="canto-cigno-players" multiple size="5"></select>
                            <button id="toggle-canto-cigno-btn" style="background: linear-gradient(135deg, #E1F5FE 0%, #B3E5FC 100%); color: #01579B;">ü¶¢ Attiva/Disattiva Canto del Cigno</button>
                            <div style="font-size: 0.85em; color: #0288D1; margin-top: 8px; padding: 8px; background: rgba(2,136,209,0.1); border-radius: 8px;">
                                üí° Se perde tutti gli HP, torna con 1 HP. Si disattiva dopo l'uso
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Patto con il Diavolo üòà (seleziona giocatore)</label>
                            <select id="patto-diavolo-players" multiple size="5"></select>
                            <button id="toggle-patto-diavolo-btn" style="background: linear-gradient(135deg, #B71C1C 0%, #F44336 100%);">üòà Attiva/Disattiva Patto Diavolo</button>
                            <div style="font-size: 0.85em; color: #B71C1C; margin-top: 8px; padding: 8px; background: rgba(183,28,28,0.1); border-radius: 8px;">
                                üí° Se perde tutti gli HP, torna con 20 HP ma usa solo 2 dadi. Si disattiva dopo l'uso
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Tomba di Tutankhamon üè∫ (seleziona giocatore)</label>
                            <select id="tomba-tutankhamon-players" multiple size="5"></select>
                            <button id="toggle-tomba-tutankhamon-btn" style="background: linear-gradient(135deg, #FF6F00 0%, #FF9800 100%);">üè∫ Attiva/Disattiva Tomba Tutankhamon</button>
                            <div style="font-size: 0.85em; color: #FF6F00; margin-top: 8px; padding: 8px; background: rgba(255,111,0,0.1); border-radius: 8px;">
                                üí° Se perde tutti gli HP, torna con met√† HP iniziali ma salta il turno. Si disattiva dopo l'uso
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Reincarnazione ‚ôªÔ∏è (seleziona giocatore)</label>
                            <select id="reincarnazione-players" multiple size="5"></select>
                            <button id="toggle-reincarnazione-btn" style="background: linear-gradient(135deg, #4CAF50 0%, #8BC34A 100%);">‚ôªÔ∏è Attiva/Disattiva Reincarnazione</button>
                            <div style="font-size: 0.85em; color: #4CAF50; margin-top: 8px; padding: 8px; background: rgba(76,175,80,0.1); border-radius: 8px;">
                                üí° Se perde tutti gli HP, torna con HP iniziali ma danni x2 permanentemente. Si disattiva dopo l'uso
                            </div>
                        </div>

                        <div class="input-group">
                            <label>Boia Esecutore ü™ì (seleziona giocatore)</label>
                            <select id="boia-esecutore-players" multiple size="5"></select>
                            <button id="toggle-boia-esecutore-btn" style="background: linear-gradient(135deg, #212121 0%, #424242 100%);">ü™ì Attiva/Disattiva Boia Esecutore</button>
                            <div style="font-size: 0.85em; color: #424242; margin-top: 8px; padding: 8px; background: rgba(33,33,33,0.1); border-radius: 8px; border: 1px solid #666;">
                                üí° Dura 2 turni: se elimina qualcuno, elimina istantaneamente anche il giocatore successivo
                            </div>
                        </div>
                    </div>
                </details>

                <!-- Fine Partita -->
                <details class="control-category">
                    <summary>üèÅ Fine Partita</summary>
                    <div class="category-content">
                        <button id="end-game-btn" style="background: #dc3545;">üèÅ Termina Partita</button>
                        <button id="new-game-btn" style="background: linear-gradient(135deg, #4ecca3 0%, #3ab795 100%);">üéÆ Nuova Partita</button>
                    </div>
                </details>
            </div>
        </div>
    </div>


    <!-- QR Code Modal -->
    <div id="qr-modal" class="qr-modal">
        <div class="qr-modal-content">
            <button class="qr-modal-close" id="qr-modal-close">√ó</button>
            <h2>üì± QR Code Partita</h2>
            <div id="qrcode-modal"></div>
            <div class="share-info">
                <p><strong>Codice Partita:</strong></p>
                <div class="game-code" id="modal-game-code"></div>
                <p style="margin-top: 10px; font-size: 0.9em;">Scansiona il QR code o inserisci il codice per entrare</p>
            </div>
        </div>
    </div>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
  apiKey: "AIzaSyAv1tYe2jwc3abq128Ci5PvJK1HTTuF3tY",
  authDomain: "gioco-del-fato.firebaseapp.com",
  databaseURL: "https://gioco-del-fato-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "gioco-del-fato",
  storageBucket: "gioco-del-fato.firebasestorage.app",
  messagingSenderId: "358068623557",
  appId: "1:358068623557:web:dad9bbba9da419e186f8ac"
};

        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        let gameState = {
            gameCode: null,
            isMaster: false,
            playerName: null,
            currentTurn: 0,
            direction: 'clockwise',
            diceCount: 3,
            players: [],
            history: [],
            startTime: null,
            initialHP: 70,
            stats: {}, // Track game statistics
            previousState: null, // For rollback
            globalEffects: {
                cessateFuoco: false,
                cessateFuocoActivator: null,
                pariPazzo: false,
                pariPazzoActivator: null,
                bambolaVoodoo: false,
                bambolaVoodooActivator: null,
                cannoneKarma: false,
                cannoneKarmaActivator: null,
                pioggiaAcida: false,
                pioggiaAcidaActivator: null,
                capsulaRigenerativa: false,
                capsulaRigenerativaActivator: null,
                saldiEstivi: false,
                saldiEstiviActivator: null,
                giocoPulito: false,
                giocoPulitoActivator: null,
                altaMarea: false,
                altaMareaActivator: null,
                zebratura: false,
                zebraturaActivator: null,
                boomerang: false,
                boomerangActivator: null,
                boomerangDamage: 0,
                armaturaSpecchio: false,
                armaturaSpecchioActivator: null,
                sabbieMobili: false,
                sabbieMobiliActivator: null
            }
        };

        let timerInterval = null;

        // Setup Event Listeners
        document.getElementById('num-players').addEventListener('change', generatePlayerNameInputs);

        document.getElementById('create-game-btn').addEventListener('click', createGame);
        document.getElementById('join-game-btn').addEventListener('click', joinGame);
        document.getElementById('start-game-btn').addEventListener('click', startGame);
        document.getElementById('calculate-btn').addEventListener('click', calculateDice);
        
        // Master Controls
        document.getElementById('reverse-direction-btn')?.addEventListener('click', reverseDirection);
        document.getElementById('rollback-btn')?.addEventListener('click', rollbackLastTurn);
        document.getElementById('change-turn-btn')?.addEventListener('click', changeTurn);
        document.getElementById('damage-btn')?.addEventListener('click', () => modifyHP('damage'));
        document.getElementById('heal-btn')?.addEventListener('click', () => modifyHP('heal'));
        document.getElementById('revive-btn')?.addEventListener('click', revivePlayer);
        document.getElementById('swap-hp-btn')?.addEventListener('click', swapHP);
        document.getElementById('end-game-btn')?.addEventListener('click', endGame);
        document.getElementById('new-game-btn')?.addEventListener('click', newGame);
        document.getElementById('show-qr-btn')?.addEventListener('click', showQRModal);
        document.getElementById('qr-modal-close')?.addEventListener('click', closeQRModal);
        document.getElementById('toggle-immortality-btn')?.addEventListener('click', toggleImmortality);
        document.getElementById('set-multiplier-half-btn')?.addEventListener('click', () => setMultiplier(0.5));
        document.getElementById('set-multiplier-double-btn')?.addEventListener('click', () => setMultiplier(2));
        document.getElementById('remove-multiplier-btn')?.addEventListener('click', removeMultiplier);
        document.getElementById('toggle-skip-turn-btn')?.addEventListener('click', toggleSkipTurn);
        document.getElementById('set-custom-dice-btn')?.addEventListener('click', setCustomDice);
        document.getElementById('remove-custom-dice-btn')?.addEventListener('click', removeCustomDice);
        document.getElementById('toggle-kraken-mark-btn')?.addEventListener('click', toggleKrakenMark);
        document.getElementById('set-checkmate-btn')?.addEventListener('click', setCheckmate);
        document.getElementById('remove-checkmate-btn')?.addEventListener('click', removeCheckmate);
        document.getElementById('toggle-damage-to-heal-btn')?.addEventListener('click', toggleDamageToHeal);
        document.getElementById('toggle-sun-armor-btn')?.addEventListener('click', toggleSunArmor);
        document.getElementById('toggle-moon-armor-btn')?.addEventListener('click', toggleMoonArmor);
        
        // Event Listeners Nuove Meccaniche
        document.getElementById('toggle-cessate-fuoco-btn')?.addEventListener('click', toggleCessateFuoco);
        document.getElementById('toggle-pari-pazzo-btn')?.addEventListener('click', togglePariPazzo);
        document.getElementById('toggle-bambola-voodoo-btn')?.addEventListener('click', toggleBambolaVoodoo);
        document.getElementById('toggle-cannone-karma-btn')?.addEventListener('click', toggleCannoneKarma);
        document.getElementById('toggle-pioggia-acida-btn')?.addEventListener('click', togglePioggiaAcida);
        document.getElementById('toggle-capsula-rigenerativa-btn')?.addEventListener('click', toggleCapsulaRigenerativa);
        document.getElementById('toggle-saldi-estivi-btn')?.addEventListener('click', toggleSaldiEstivi);
        document.getElementById('toggle-gioco-pulito-btn')?.addEventListener('click', toggleGiocoPulito);
        document.getElementById('trottola-impazzita-btn')?.addEventListener('click', activateTrottolaImpazzita);
        document.getElementById('tartaruga-lepre-btn')?.addEventListener('click', activateTartarugaLepre);
        document.getElementById('yin-yang-btn')?.addEventListener('click', activateYinYang);
        document.getElementById('bilancia-fato-btn')?.addEventListener('click', activateBilanciaFato);
        document.getElementById('uguaglianza-btn')?.addEventListener('click', activateUguaglianza);
        document.getElementById('geyser-fuoco-btn')?.addEventListener('click', activateGeyserFuoco);
        document.getElementById('toggle-mare-guai-btn')?.addEventListener('click', toggleMareGuai);
        document.getElementById('set-talismano-ra-btn')?.addEventListener('click', setTalismanRa);
        document.getElementById('remove-talismano-ra-btn')?.addEventListener('click', removeTalismanRa);
        document.getElementById('set-dado-avvelenato-btn')?.addEventListener('click', setDadoAvvelenato);
        document.getElementById('remove-dado-avvelenato-btn')?.addEventListener('click', removeDadoAvvelenato);
        document.getElementById('set-interferenza-btn')?.addEventListener('click', setInterferenza);
        document.getElementById('remove-interferenza-btn')?.addEventListener('click', removeInterferenza);
        document.getElementById('toggle-volo-fenice-btn')?.addEventListener('click', toggleVoloFenice);
        document.getElementById('toggle-cactus-amari-btn')?.addEventListener('click', toggleCactusAmari);
        document.getElementById('toggle-catena-maledetta-btn')?.addEventListener('click', toggleCatenaMaledetta);
        document.getElementById('set-alta-marea-btn')?.addEventListener('click', setAltaMarea);
        document.getElementById('remove-alta-marea-btn')?.addEventListener('click', removeAltaMarea);
        document.getElementById('set-zebratura-btn')?.addEventListener('click', setZebratura);
        document.getElementById('remove-zebratura-btn')?.addEventListener('click', removeZebratura);
        document.getElementById('toggle-rifletti-danni-btn')?.addEventListener('click', toggleRiflettiDanni);
        document.getElementById('set-boomerang-btn')?.addEventListener('click', setBoomerang);
        document.getElementById('remove-boomerang-btn')?.addEventListener('click', removeBoomerang);
        document.getElementById('set-armatura-specchio-btn')?.addEventListener('click', setArmaturaSpecchio);
        document.getElementById('remove-armatura-specchio-btn')?.addEventListener('click', removeArmaturaSpecchio);
        document.getElementById('set-sabbie-mobili-btn')?.addEventListener('click', setSabbieMobili);
        document.getElementById('remove-sabbie-mobili-btn')?.addEventListener('click', removeSabbieMobili);
        document.getElementById('toggle-canto-cigno-btn')?.addEventListener('click', toggleCantoCigno);
        document.getElementById('toggle-patto-diavolo-btn')?.addEventListener('click', togglePattoDiavolo);
        document.getElementById('toggle-tomba-tutankhamon-btn')?.addEventListener('click', toggleTombaTutankhamon);
        document.getElementById('toggle-reincarnazione-btn')?.addEventListener('click', toggleReincarnazione);
        document.getElementById('toggle-boia-esecutore-btn')?.addEventListener('click', toggleBoiaEsecutore);
        
        // Close modal clicking outside
        document.getElementById('qr-modal')?.addEventListener('click', function(e) {
            if (e.target === this) {
                closeQRModal();
            }
        });

        // Auto-detect role from URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const gameCode = urlParams.get('game');
        const playerNameFromURL = urlParams.get('player');
        
        if (gameCode) {
            // Player joining via QR code
            document.getElementById('player-join').classList.remove('hidden');
            document.getElementById('display-game-code').textContent = gameCode;
            loadAvailablePlayers(gameCode);
            
            // Auto-join if player name is in URL
            if (playerNameFromURL) {
                setTimeout(() => {
                    joinGame();
                }, 500);
            }
        } else {
            // Master creating new game
            document.getElementById('master-setup').classList.remove('hidden');
            generatePlayerNameInputs();
        }

        function loadAvailablePlayers(code) {
            database.ref('games/' + code).on('value', (snapshot) => {
                if (!snapshot.exists()) {
                    return;
                }

                const gameData = snapshot.val();
                const select = document.getElementById('player-name-select');
                
                if (!select) return;
                
                select.innerHTML = '<option value="">Seleziona il tuo nome...</option>';
                
                gameData.players.forEach((player) => {
                    const option = document.createElement('option');
                    option.value = player.name;
                    option.textContent = player.name + (player.connected ? ' ‚úì' : '');
                    option.disabled = player.connected;
                    select.appendChild(option);
                });
                
                // Update connected players list for master
                const connectedList = document.getElementById('connected-players-list');
                if (connectedList) {
                    connectedList.innerHTML = gameData.players
                        .map(p => `<div style="color: ${p.connected ? '#4ecca3' : '#888'}; padding: 5px;">
                            ${p.connected ? '‚úì' : '‚óã'} ${p.name}
                        </div>`)
                        .join('');
                }
            });
        }

        function generatePlayerNameInputs() {
            const numPlayers = parseInt(document.getElementById('num-players').value);
            const container = document.getElementById('player-names-container');
            container.innerHTML = '<div class="input-group"><label>Nomi degli altri giocatori:</label></div>';
            
            for (let i = 1; i < numPlayers; i++) {
                const div = document.createElement('div');
                div.className = 'player-input';
                div.innerHTML = `
                    <input type="text" placeholder="Giocatore ${i + 1}" id="player-${i}">
                `;
                container.appendChild(div);
            }

            // Auto-suggest HP based on number of players
            const hpInput = document.getElementById('initial-hp');
            if (numPlayers === 4) {
                hpInput.value = 60;
            } else if (numPlayers >= 5 && numPlayers <= 6) {
                hpInput.value = 70;
            } else if (numPlayers >= 7 && numPlayers <= 8) {
                hpInput.value = 80;
            } else if (numPlayers >= 9) {
                hpInput.value = 85;
            }
        }

        function createGame() {
            const masterName = document.getElementById('master-name').value.trim();
            const numPlayers = parseInt(document.getElementById('num-players').value);
            const initialHP = parseInt(document.getElementById('initial-hp').value);

            if (!masterName) {
                alert('Inserisci il tuo nome!');
                return;
            }

            const players = [{ 
                name: masterName, 
                hp: initialHP, 
                isEliminated: false, 
                isMaster: true, 
                connected: true, 
                isImmortal: false, 
                multiplier: 1,
                multiplierAppliedBy: null,
                skipTurn: false,
                customDiceCount: null,
                krakenMark: false,
                checkmateHP: null,
                damageToHeal: false,
                sunArmor: false,
                moonArmor: false,
                mareGuai: false,
                voloFenice: false,
                cactusAmari: false,
                catenaMaledetta: false,
                rifletteDanni: false,
                talismanRa: false,
                talismanRaValues: [],
                dadoAvvelenato: false,
                dadoAvvelenatotValues: [],
                interferenza: false,
                interferenzaPartner: null,
                cantoDelCigno: false,
                pattoDiavolo: false,
                pattoDiavoloUsed: false,
                tombaTutankhamon: false,
                reincarnazione: false,
                reincarnazioneUsed: false,
                boiaEsecutore: false,
                boiaEsecutoreTurns: 0,
                temporaryEffects: {
                    immortal: false,
                    multiplier: false,
                    skipTurn: false,
                    customDice: false,
                    damageToHeal: false,
                    sunArmor: false,
                    moonArmor: false,
                    mareGuai: false,
                    voloFenice: false,
                    cactusAmari: false,
                    catenaMaledetta: false,
                    rifletteDanni: false,
                    talismanRa: false,
                    dadoAvvelenato: false
                }
            }];
            
            for (let i = 1; i < numPlayers; i++) {
                const playerName = document.getElementById(`player-${i}`).value.trim();
                if (playerName) {
                    players.push({ 
                        name: playerName, 
                        hp: initialHP, 
                        isEliminated: false, 
                        isMaster: false, 
                        connected: false, 
                        isImmortal: false, 
                        multiplier: 1,
                        multiplierAppliedBy: null,
                        skipTurn: false,
                        customDiceCount: null,
                        krakenMark: false,
                        checkmateHP: null,
                        damageToHeal: false,
                        sunArmor: false,
                        moonArmor: false,
                        mareGuai: false,
                        voloFenice: false,
                        cactusAmari: false,
                        catenaMaledetta: false,
                        rifletteDanni: false,
                        talismanRa: false,
                        talismanRaValues: [],
                        dadoAvvelenato: false,
                        dadoAvvelenatotValues: [],
                        interferenza: false,
                        interferenzaPartner: null,
                        cantoDelCigno: false,
                        pattoDiavolo: false,
                        pattoDiavoloUsed: false,
                        tombaTutankhamon: false,
                        reincarnazione: false,
                        reincarnazioneUsed: false,
                        boiaEsecutore: false,
                        boiaEsecutoreTurns: 0,
                        temporaryEffects: {
                            immortal: false,
                            multiplier: false,
                            skipTurn: false,
                            customDice: false,
                            damageToHeal: false,
                            sunArmor: false,
                            moonArmor: false,
                            mareGuai: false,
                            voloFenice: false,
                            cactusAmari: false,
                            catenaMaledetta: false,
                            rifletteDanni: false,
                            talismanRa: false,
                            dadoAvvelenato: false
                        }
                    });
                }
            }

            if (players.length < 2) {
                alert('Servono almeno 2 giocatori!');
                return;
            }

            const code = generateGameCode();
            gameState.gameCode = code;
            gameState.isMaster = true;
            gameState.playerName = masterName;

            const gameData = {
                players: players,
                currentTurn: 0,
                direction: 'clockwise',
                diceCount: 3,
                history: [],
                startTime: null,
                started: false,
                initialHP: initialHP
            };

            database.ref('games/' + code).set(gameData).then(() => {
                showQRCode(code);
            });
        }

        function generateGameCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function showQRCode(code) {
            document.getElementById('master-setup').classList.add('hidden');
            document.getElementById('qr-display').classList.remove('hidden');
            document.getElementById('game-code-display').textContent = code;

            const url = window.location.origin + window.location.pathname + '?game=' + code;
            
            new QRCode(document.getElementById('qrcode'), {
                text: url,
                width: 200,
                height: 200,
                colorDark: "#000000",
                colorLight: "#ffffff"
            });

            listenToGameChanges(code);
        }

        function joinGame() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('game');
            const playerNameFromURL = urlParams.get('player');
            
            // If player name is in URL, use it directly
            let playerName = playerNameFromURL;
            
            // Otherwise get from select
            if (!playerName) {
                playerName = document.getElementById('player-name-select').value;
            }

            if (!playerName || !code) {
                alert('Seleziona il tuo nome!');
                return;
            }

            database.ref('games/' + code).once('value').then((snapshot) => {
                if (!snapshot.exists()) {
                    alert('Partita non trovata!');
                    return;
                }

                const gameData = snapshot.val();
                
                // Find player by name (regardless of connection status)
                const playerIndex = gameData.players.findIndex(p => p.name === playerName);
                
                if (playerIndex < 0) {
                    alert('Giocatore non trovato in questa partita!');
                    return;
                }

                // Mark player as connected (reconnection allowed)
                gameData.players[playerIndex].connected = true;
                database.ref('games/' + code + '/players/' + playerIndex).update({ connected: true });

                gameState.gameCode = code;
                gameState.isMaster = false;
                gameState.playerName = playerName;

                listenToGameChanges(code);
                
                if (gameData.started) {
                    showGameScreen();
                } else {
                    // Show waiting screen
                    document.getElementById('setup-screen').innerHTML = `
                        <div style="text-align: center; padding: 40px;">
                            <h2 style="color: #ffd700; margin-bottom: 20px;">‚úÖ Connesso come ${playerName}!</h2>
                            <p style="font-size: 1.2em; margin-bottom: 30px;">In attesa che il Master avvii la partita...</p>
                            <div style="font-size: 3em; animation: pulse 2s infinite;">‚è≥</div>
                        </div>
                    `;
                }
            });
        }

        function startGame() {
            if (!gameState.gameCode) return;

            const startTime = Date.now();
            database.ref('games/' + gameState.gameCode).update({
                started: true,
                startTime: startTime
            });

            showGameScreen();
        }

        function showGameScreen() {
            document.getElementById('setup-screen').classList.add('hidden');
            document.getElementById('game-screen').classList.remove('hidden');

            if (gameState.isMaster) {
                document.getElementById('master-controls').classList.remove('hidden');
            }

            renderDiceInputs();
        }

        function listenToGameChanges(code) {
            database.ref('games/' + code).on('value', (snapshot) => {
                if (!snapshot.exists()) return;

                const data = snapshot.val();
                gameState.players = data.players || [];
                gameState.currentTurn = data.currentTurn || 0;
                gameState.direction = data.direction || 'clockwise';
                gameState.diceCount = data.diceCount || 3;
                gameState.history = data.history || [];
                gameState.startTime = data.startTime;
                gameState.initialHP = data.initialHP || 70;
                gameState.stats = data.stats || {};

                if (data.started && document.getElementById('setup-screen').classList.contains('hidden') === false) {
                    showGameScreen();
                }
                
                // Show winner notification when game ends
                if (data.gameEnded && data.winner) {
                    const isYou = data.winner === gameState.playerName;
                    showWinnerNotification(data.winner, isYou);
                }

                renderPlayers();
                renderLeaderboard();
                renderHistory();
                updateTurnDisplay();
                updateDirectionDisplay();
                renderDiceInputs();
                updateMasterControls();

                if (gameState.startTime && !timerInterval) {
                    startTimer();
                }
            });
        }

        function renderPlayers() {
            const container = document.getElementById('players-list');
            container.innerHTML = '';

            gameState.players.forEach((player, index) => {
                const card = document.createElement('div');
                card.className = 'player-card';
                card.id = `player-card-${index}`;
                
                if (index === gameState.currentTurn && !player.isEliminated) {
                    card.classList.add('active-turn');
                }
                
                if (player.isEliminated) {
                    card.classList.add('eliminated');
                }

                const hpClass = player.hp < 30 ? 'low' : '';
                
                card.innerHTML = `
                    <div class="player-info">
                        <div class="player-name">${player.name}${player.isMaster ? ' üëë' : ''}${player.isImmortal ? ' ‚≠ê' : ''}${(player.multiplier > 1 || player.multiplier < 1) ? ' ‚ú®x' + player.multiplier : ''}${player.skipTurn ? ' ‚è≠Ô∏è' : ''}${player.customDiceCount ? ' üé≤√ó' + player.customDiceCount : ''}${player.krakenMark ? ' üêô' : ''}${player.checkmateHP ? ' ‚ôüÔ∏è' : ''}${player.damageToHeal ? ' üí´' : ''}${player.sunArmor ? ' ‚òÄÔ∏è' : ''}${player.moonArmor ? ' üåô' : ''}</div>
                        <div class="player-hp ${hpClass}">${player.hp} HP</div>
                    </div>
                    ${player.isEliminated ? '<div style="color: #dc3545; margin-top: 5px;">‚ò†Ô∏è Eliminato</div>' : ''}
                    ${player.isImmortal ? '<div style="color: #ffd700; margin-top: 5px;">‚≠ê Immortale' + (player.temporaryEffects?.immortal ? ' (temp)' : '') + '</div>' : ''}
                    ${player.multiplier > 1 || player.multiplier < 1 ? '<div style="color: #ff00ff; margin-top: 5px;">‚ú® Moltiplicatore x' + player.multiplier + (player.temporaryEffects?.multiplier ? ' (temp)' : '') + '</div>' : ''}
                    ${player.skipTurn ? '<div style="color: #ff9800; margin-top: 5px;">‚è≠Ô∏è Salta Turno' + (player.temporaryEffects?.skipTurn ? ' (temp)' : '') + '</div>' : ''}
                    ${player.customDiceCount ? '<div style="color: #00ffff; margin-top: 5px;">üé≤ Dadi: ' + player.customDiceCount + ' (temp)</div>' : ''}
                    ${player.krakenMark ? '<div style="color: #9933ff; margin-top: 5px; font-weight: bold;">üêô Marchio del Kraken (‚â§10 HP = morte)</div>' : ''}
                    ${player.checkmateHP ? '<div style="color: #ff0000; margin-top: 5px; font-weight: bold;">‚ôüÔ∏è Scacco Matto (' + player.checkmateHP + ' HP = morte)</div>' : ''}
                    ${player.damageToHeal ? '<div style="color: #ff69b4; margin-top: 5px;">üí´ Conversione Danni‚ÜíCure (temp)</div>' : ''}
                    ${player.sunArmor ? '<div style="color: #ffa500; margin-top: 5px;">‚òÄÔ∏è Armatura del Sole (temp)</div>' : ''}
                    ${player.moonArmor ? '<div style="color: #87ceeb; margin-top: 5px;">üåô Armatura della Luna (temp)</div>' : ''}
                `;
                
                container.appendChild(card);
            });
        }

        function renderLeaderboard() {
            const container = document.getElementById('leaderboard-list');
            const sorted = [...gameState.players].sort((a, b) => b.hp - a.hp);
            
            container.innerHTML = '';
            sorted.forEach((player, index) => {
                const item = document.createElement('div');
                item.className = 'leaderboard-item';
                if (index === 0) item.classList.add('winner');
                
                item.innerHTML = `
                    <span>${index + 1}. ${player.name}</span>
                    <span>${player.hp} HP</span>
                `;
                container.appendChild(item);
            });
        }

        function renderHistory() {
            const container = document.getElementById('history');
            container.innerHTML = '';
            
            const recent = gameState.history.slice(-20).reverse();
            recent.forEach(item => {
                const div = document.createElement('div');
                div.className = 'history-item';
                
                // Determine icon and class based on content
                let icon = 'üé≤';
                let itemClass = '';
                
                if (item.includes('riceve') && item.includes('danni')) {
                    icon = 'üí•';
                    itemClass = 'damage';
                } else if (item.includes('si cura') || item.includes('recupera')) {
                    icon = 'üíö';
                    itemClass = 'heal';
                } else if (item.includes('Coppia') || item.includes('Tris') || item.includes('POKER')) {
                    icon = '‚ú®';
                    itemClass = 'special';
                } else if (item.includes('rianimato')) {
                    icon = 'üîÑ';
                    itemClass = 'heal';
                } else if (item.includes('scambiato')) {
                    icon = 'üîÑ';
                    itemClass = 'special';
                } else if (item.includes('Nuova partita') || item.includes('terminata')) {
                    icon = 'üèÅ';
                    itemClass = 'special';
                } else if (item.includes('Direzione')) {
                    icon = '‚≠Æ';
                    itemClass = 'special';
                }
                
                div.className += ' ' + itemClass;
                div.innerHTML = `<span class="icon">${icon}</span><span>${item}</span>`;
                container.appendChild(div);
            });
        }

        function updateTurnDisplay() {
            const currentPlayer = gameState.players[gameState.currentTurn];
            if (currentPlayer) {
                document.getElementById('turn-player').textContent = currentPlayer.name;
                
                // Visual turn indicator - green pulsing border
                if (currentPlayer.name === gameState.playerName) {
                    document.body.classList.add('my-turn');
                } else {
                    document.body.classList.remove('my-turn');
                }
            }
        }

        function updateDirectionDisplay() {
            const arrow = gameState.direction === 'clockwise' ? '‚≠Æ' : '‚≠Ø';
            const text = gameState.direction === 'clockwise' ? 'Oraria' : 'Antioraria';
            document.getElementById('direction').innerHTML = `Direzione: ${arrow} ${text}`;
        }

        function renderDiceInputs() {
            const container = document.getElementById('dice-inputs');
            container.innerHTML = '';
            
            // Check if current player has custom dice count
            const currentPlayer = gameState.players[gameState.currentTurn];
            const diceCount = currentPlayer?.customDiceCount || gameState.diceCount;
            
            for (let i = 0; i < diceCount; i++) {
                const div = document.createElement('div');
                div.className = 'dice-input';
                div.innerHTML = `<input type="number" min="1" max="6" id="dice-${i}" placeholder="D${i + 1}">`;
                container.appendChild(div);
            }
            
            // Show indicator if using custom dice
            if (currentPlayer?.customDiceCount) {
                const indicator = document.createElement('div');
                indicator.style.cssText = 'color: #00ffff; font-size: 0.9em; margin-top: 10px; text-align: center;';
                indicator.textContent = `üé≤ Dadi personalizzati: ${currentPlayer.customDiceCount} (questo turno)`;
                container.appendChild(indicator);
            }
        }

        function updateMasterControls() {
            if (!gameState.isMaster) return;

            // Update turn change selector
            const turnSelect = document.getElementById('next-turn-player');
            turnSelect.innerHTML = '';
            
            gameState.players.forEach((player, index) => {
                if (!player.isEliminated) {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name;
                    turnSelect.appendChild(option);
                }
            });

            // Update multi-select for HP modification
            const multiSelect = document.getElementById('target-players');
            multiSelect.innerHTML = '';
            
            gameState.players.forEach((player, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = player.name + (player.isEliminated ? ' (Eliminato)' : '');
                multiSelect.appendChild(option);
            });

            // Update damage activator select
            const damageActivatorSelect = document.getElementById('damage-activator-select');
            if (damageActivatorSelect) {
                damageActivatorSelect.innerHTML = '';
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.isEliminated ? ' (Eliminato)' : '');
                    damageActivatorSelect.appendChild(option);
                });
                // Seleziona il giocatore di turno per default
                damageActivatorSelect.value = gameState.currentTurn;
            }

            // Update swap HP selects
            const swapSelect1 = document.getElementById('swap-player-1');
            const swapSelect2 = document.getElementById('swap-player-2');
            
            if (swapSelect1 && swapSelect2) {
                swapSelect1.innerHTML = '';
                swapSelect2.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option1 = document.createElement('option');
                    option1.value = index;
                    option1.textContent = player.name;
                    swapSelect1.appendChild(option1);
                    
                    const option2 = document.createElement('option');
                    option2.value = index;
                    option2.textContent = player.name;
                    swapSelect2.appendChild(option2);
                });
            }
            
            // Update QR player select
            const qrSelect = document.getElementById('qr-player-select');
            if (qrSelect) {
                qrSelect.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name;
                    qrSelect.appendChild(option);
                });
            }
            
            // Update immortality select
            const immortalSelect = document.getElementById('immortal-players');
            if (immortalSelect) {
                immortalSelect.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.isImmortal ? ' ‚≠ê' : '');
                    if (player.isImmortal) {
                        option.selected = true;
                    }
                    immortalSelect.appendChild(option);
                });
            }
            
            // Update multiplier select
            const multiplierSelect = document.getElementById('multiplier-players');
            if (multiplierSelect) {
                multiplierSelect.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + ((player.multiplier > 1 || player.multiplier < 1) ? ' ‚ú®x' + player.multiplier : '');
                    multiplierSelect.appendChild(option);
                });
            }
            
            // Update skip turn select
            const skipTurnSelect = document.getElementById('skip-turn-players');
            if (skipTurnSelect) {
                skipTurnSelect.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.skipTurn ? ' ‚è≠Ô∏è' : '');
                    if (player.skipTurn) {
                        option.selected = true;
                    }
                    skipTurnSelect.appendChild(option);
                });
            }
            
            // Update custom dice select
            const customDiceSelect = document.getElementById('custom-dice-players');
            if (customDiceSelect) {
                customDiceSelect.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.customDiceCount ? ' üé≤√ó' + player.customDiceCount : '');
                    customDiceSelect.appendChild(option);
                });
            }
            
            // Update kraken mark select
            const krakenMarkSelect = document.getElementById('kraken-mark-players');
            if (krakenMarkSelect) {
                krakenMarkSelect.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.krakenMark ? ' üêô' : '');
                    if (player.krakenMark) {
                        option.selected = true;
                    }
                    krakenMarkSelect.appendChild(option);
                });
            }
            
            // Update checkmate select
            const checkmateSelect = document.getElementById('checkmate-players');
            if (checkmateSelect) {
                checkmateSelect.innerHTML = '';
                
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.checkmateHP ? ' ‚ôüÔ∏è' + player.checkmateHP : '');
                    checkmateSelect.appendChild(option);
                });
            }
            
            // Update damage-to-heal select
            const damageToHealSelect = document.getElementById('damage-to-heal-players');
            if (damageToHealSelect) {
                damageToHealSelect.innerHTML = '';
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.damageToHeal ? ' üí´' : '');
                    if (player.damageToHeal) option.selected = true;
                    damageToHealSelect.appendChild(option);
                });
            }
            
            // Update sun armor select
            const sunArmorSelect = document.getElementById('sun-armor-players');
            if (sunArmorSelect) {
                sunArmorSelect.innerHTML = '';
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.sunArmor ? ' ‚òÄÔ∏è' : '');
                    if (player.sunArmor) option.selected = true;
                    sunArmorSelect.appendChild(option);
                });
            }
            
            // Update moon armor select
            const moonArmorSelect = document.getElementById('moon-armor-players');
            if (moonArmorSelect) {
                moonArmorSelect.innerHTML = '';
                gameState.players.forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = player.name + (player.moonArmor ? ' üåô' : '');
                    if (player.moonArmor) option.selected = true;
                    moonArmorSelect.appendChild(option);
                });
            }
            
            // Update nuove meccaniche selects
            const nuoviSelectMultipli = [
                { id: 'mare-guai-players', prop: 'mareGuai', emoji: 'üåä' },
                { id: 'volo-fenice-players', prop: 'voloFenice', emoji: 'ü¶Ö' },
                { id: 'cactus-amari-players', prop: 'cactusAmari', emoji: 'üåµ' },
                { id: 'catena-maledetta-players', prop: 'catenaMaledetta', emoji: '‚õìÔ∏è' },
                { id: 'rifletti-danni-players', prop: 'rifletteDanni', emoji: 'üõ°Ô∏è' }
            ];
            
            nuoviSelectMultipli.forEach(({ id, prop, emoji }) => {
                const select = document.getElementById(id);
                if (select) {
                    select.innerHTML = '';
                    gameState.players.forEach((player, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = player.name + (player[prop] ? ` ${emoji}` : '');
                        if (player[prop]) option.selected = true;
                        select.appendChild(option);
                    });
                }
            });
            
            // Update select singoli
            const selectSingoli = ['talismano-ra-player', 'dado-avvelenato-player', 'interferenza-player1', 
                                   'interferenza-player2', 'alta-marea-player', 'zebratura-player', 
                                   'boomerang-player', 'armatura-specchio-player', 'sabbie-mobili-player'];
            
            selectSingoli.forEach(selectId => {
                const select = document.getElementById(selectId);
                if (select) {
                    select.innerHTML = '';
                    gameState.players.forEach((player, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = player.name;
                        select.appendChild(option);
                    });
                }
            });
            
            // Update carte resurrezione
            const selectResurrezione = [
                { id: 'canto-cigno-players', prop: 'cantoDelCigno', emoji: 'ü¶¢' },
                { id: 'patto-diavolo-players', prop: 'pattoDiavolo', emoji: 'üòà' },
                { id: 'tomba-tutankhamon-players', prop: 'tombaTutankhamon', emoji: 'üè∫' },
                { id: 'reincarnazione-players', prop: 'reincarnazione', emoji: '‚ôªÔ∏è' },
                { id: 'boia-esecutore-players', prop: 'boiaEsecutore', emoji: 'ü™ì' }
            ];
            
            selectResurrezione.forEach(({ id, prop, emoji }) => {
                const select = document.getElementById(id);
                if (select) {
                    select.innerHTML = '';
                    gameState.players.forEach((player, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = player.name + (player[prop] ? ` ${emoji}` : '');
                        select.appendChild(option);
                    });
                }
            });
            
            // Update select attivatori effetti globali
            const activatorSelects = [
                'cessate-fuoco-activator',
                'pari-pazzo-activator',
                'bambola-voodoo-activator',
                'cannone-karma-activator',
                'pioggia-acida-activator',
                'capsula-rigenerativa-activator',
                'saldi-estivi-activator',
                'gioco-pulito-activator'
            ];
            
            activatorSelects.forEach(selectId => {
                const select = document.getElementById(selectId);
                if (select) {
                    select.innerHTML = '<option value="">Seleziona Attivatore</option>';
                    gameState.players.forEach((player, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = player.name;
                        select.appendChild(option);
                    });
                }
            });
        }

        function calculateDice() {
            const currentPlayerIndex = gameState.currentTurn;
            const currentPlayer = gameState.players[currentPlayerIndex];

            if (!gameState.isMaster && currentPlayer.name !== gameState.playerName) {
                alert('Non √® il tuo turno!');
                return;
            }

            if (currentPlayer.isEliminated) {
                alert('Il giocatore corrente √® eliminato!');
                return;
            }
            
            if (currentPlayer.skipTurn) {
                alert('Questo giocatore deve saltare il turno!');
                return;
            }

            const diceValues = [];
            const diceCount = currentPlayer.customDiceCount || gameState.diceCount;
            
            for (let i = 0; i < diceCount; i++) {
                const value = parseInt(document.getElementById(`dice-${i}`).value);
                if (!value || value < 1 || value > 6) {
                    alert('Inserisci valori validi per tutti i dadi (1-6)!');
                    return;
                }
                diceValues.push(value);
            }

            const result = processDiceRoll(diceValues, currentPlayerIndex);
            displayResult(result);
            applyResult(result);
        }

        function processDiceRoll(dice, shooterIndex) {
            const sum = dice.reduce((a, b) => a + b, 0);
            const counts = {};
            dice.forEach(d => counts[d] = (counts[d] || 0) + 1);
            
            const maxCount = Math.max(...Object.values(counts));
            const pairValue = maxCount >= 2 ? parseInt(Object.keys(counts).find(k => counts[k] === maxCount)) : null;

            let damage = sum;
            let specialEffect = null;
            let selfHeal = 0;
            let cardsDrawn = 0;
            let isPoker = false;

            // POKER - 4 dadi uguali = VITTORIA ISTANTANEA
            if (maxCount === 4) {
                isPoker = true;
                specialEffect = 'POKER - VITTORIA!';
                damage = 0; // No damage, instant win
            } else if (maxCount === 3) {
                // Tris: (valore √ó valore) + valore del terzo dado
                const trisDice = dice.filter(d => d === pairValue);
                damage = (pairValue * pairValue) + trisDice[2];
                selfHeal = damage;
                cardsDrawn = 2;
                specialEffect = 'Tris';
            } else if (maxCount === 2) {
                // Coppia: (valore √ó valore) + altro dado
                const otherDice = dice.find(d => d !== pairValue);
                damage = (pairValue * pairValue) + (otherDice || 0);
                cardsDrawn = 1;
                specialEffect = 'Coppia';
            }

            const targetIndex = !isPoker ? findTarget(sum, shooterIndex) : -1;

            return {
                dice,
                sum,
                damage,
                specialEffect,
                selfHeal,
                cardsDrawn,
                shooterIndex,
                targetIndex,
                isPoker
            };
        }

        function findTarget(sum, shooterIndex) {
            const activePlayers = gameState.players
                .map((p, i) => ({ player: p, index: i }))
                .filter(({ player, index }) => !player.isEliminated && index !== shooterIndex);

            if (activePlayers.length === 0) return -1;

            let count = sum % activePlayers.length;
            if (count === 0) count = activePlayers.length;

            if (gameState.direction === 'clockwise') {
                // Senso orario: ordina per index crescente, partendo da dopo lo shooter
                const sorted = [...activePlayers].sort((a, b) => {
                    // Metti prima quelli dopo lo shooter, poi quelli prima
                    const aAfter = a.index > shooterIndex ? a.index : a.index + 1000;
                    const bAfter = b.index > shooterIndex ? b.index : b.index + 1000;
                    return aAfter - bAfter;
                });
                
                const targetPos = (count - 1) % sorted.length;
                return sorted[targetPos].index;
            } else {
                // Senso antiorario: ordina per index decrescente, partendo da prima dello shooter
                const sorted = [...activePlayers].sort((a, b) => {
                    // Metti prima quelli prima dello shooter, poi quelli dopo (ma in ordine inverso)
                    const aValue = a.index < shooterIndex ? (shooterIndex - a.index) : (shooterIndex + gameState.players.length - a.index);
                    const bValue = b.index < shooterIndex ? (shooterIndex - b.index) : (shooterIndex + gameState.players.length - b.index);
                    return aValue - bValue;
                });
                
                const targetPos = (count - 1) % sorted.length;
                return sorted[targetPos].index;
            }
        }

        function displayResult(result) {
            const display = document.getElementById('result-display');
            const text = document.getElementById('result-text');
            
            const shooter = gameState.players[result.shooterIndex];
            const target = result.targetIndex >= 0 ? gameState.players[result.targetIndex] : null;

            let message = `üé≤ Dadi: ${result.dice.join(', ')}<br>`;
            
            if (result.isPoker) {
                message += `<br>üèÜüèÜüèÜ POKER! üèÜüèÜüèÜ<br>`;
                message += `<strong style="font-size: 1.5em; color: #ffd700;">VITTORIA ISTANTANEA!</strong><br>`;
                message += `${shooter.name} vince la partita!<br>`;
            } else {
                message += `üìä Somma: ${result.sum}<br>`;
                
                if (result.specialEffect) {
                    message += `‚ú® ${result.specialEffect}!<br>`;
                }
                
                if (target) {
                    message += `üéØ Bersaglio: ${target.name}<br>`;
                    message += `üí• Danno: ${result.damage}<br>`;
                }
                
                if (result.selfHeal > 0) {
                    message += `üíö Cura: ${result.selfHeal} HP<br>`;
                }
                
                if (result.cardsDrawn > 0) {
                    message += `üÉè Pesca ${result.cardsDrawn} carta/e del fato<br>`;
                }
            }

            text.innerHTML = message;
            display.classList.remove('hidden');
        }

        function applyResult(result) {
            // Save current state for rollback (Master only)
            if (gameState.isMaster) {
                gameState.previousState = {
                    players: JSON.parse(JSON.stringify(gameState.players)),
                    currentTurn: gameState.currentTurn,
                    history: [...gameState.history],
                    stats: JSON.parse(JSON.stringify(gameState.stats))
                };
            }
            
            const shooter = gameState.players[result.shooterIndex];
            
            // Initialize stats for shooter if not exists
            if (!gameState.stats[shooter.name]) {
                gameState.stats[shooter.name] = {
                    damageDealt: 0,
                    damageTaken: 0,
                    healingDone: 0,
                    specialMoves: 0,
                    turns: 0
                };
            }
            
            gameState.stats[shooter.name].turns++;
            
            // POKER = INSTANT WIN
            if (result.isPoker) {
                gameState.stats[shooter.name].specialMoves++;
                gameState.history.push(`üèÜ ${shooter.name} ha ottenuto POKER (${result.dice.join(',')}) e VINCE LA PARTITA!`);
                
                database.ref('games/' + gameState.gameCode).update({
                    history: gameState.history,
                    gameEnded: true,
                    winner: shooter.name,
                    stats: gameState.stats
                });
                
                playSound('poker');
                
                setTimeout(() => {
                    const isYou = shooter.name === gameState.playerName;
                    showWinnerNotification(shooter.name, isYou);
                }, 1000);
                
                return;
            }
            
            const target = result.targetIndex >= 0 ? gameState.players[result.targetIndex] : null;
            
            // ===== APPLICAZIONE EFFETTI GLOBALI =====
            const gfx = gameState.globalEffects;
            
            // CESSATE IL FUOCO - tutti curano invece di danneggiare
            if (gfx.cessateFuoco && result.shooterIndex !== gfx.cessateFuocoActivator && result.damage > 0) {
                result.damage = -Math.abs(result.damage); // Converti in cura
                // Attivatore si cura della met√† del danno generato
                const activator = gameState.players[gfx.cessateFuocoActivator];
                if (activator && !activator.isEliminated) {
                    const heal = Math.floor(Math.abs(result.damage) / 2);
                    activator.hp += heal;
                    gameState.history.push(`üïäÔ∏è [Cessate Fuoco] ${activator.name} si auto-cura +${heal} HP`);
                }
            }
            
            // BAMBOLA VOODOO - infliggi danni a te stesso
            if (gfx.bambolaVoodoo && result.shooterIndex !== gfx.bambolaVoodooActivator && target && result.damage > 0) {
                const originalTarget = target.name;
                result.targetIndex = result.shooterIndex; // Cambia target a s√© stesso
                // Importante: riassegna target dopo aver cambiato targetIndex
                const newTarget = gameState.players[result.targetIndex];
                gameState.history.push(`ü™Ü [Bambola Voodoo] ${shooter.name} colpisce s√© stesso invece di ${originalTarget}!`);
                // Nota: la variabile target verr√† riassegnata nella sezione "Apply damage"
            }
            
            // CAPSULA RIGENERATIVA - tutti curano
            if (gfx.capsulaRigenerativa && result.damage > 0) {
                result.damage = -Math.abs(result.damage); // Converti in cura
            }
            
            // SALDI ESTIVI - danni E cure dimezzati
            let alreadyHalvedDamage = false; // Flag per tracciare dimezzamento
            if (gfx.saldiEstivi && result.damage > 0) {
                const originalDamage = result.damage;
                result.damage = Math.floor(result.damage / 2);
                alreadyHalvedDamage = true;
                gameState.history.push(`üèñÔ∏è [Saldi Estivi] Danni ridotti: ${originalDamage} ‚Üí ${result.damage}`);
            }
            if (gfx.saldiEstivi && result.selfHeal > 0) {
                const originalHeal = result.selfHeal;
                result.selfHeal = Math.floor(result.selfHeal / 2);
                gameState.history.push(`üèñÔ∏è [Saldi Estivi] Cura ridotta: ${originalHeal} ‚Üí ${result.selfHeal}`);
            }
            
            // GIOCO PULITO - annulla coppie e tris
            if (gfx.giocoPulito) {
                if (result.specialEffect === 'Coppia' || result.specialEffect === 'Tris') {
                    result.specialEffect = null;
                    result.selfHeal = 0;
                    result.cardsDrawn = 0;
                    const newDamage = result.sum;
                    gameState.history.push(`‚öñÔ∏è [Gioco Pulito] Effetto speciale annullato, danno base: ${newDamage}`);
                    result.damage = newDamage; // Ricalcola come somma semplice
                }
            }
            
            // ZEBRATURA - somme pari curano, dispari danneggiano
            if (gfx.zebratura && result.damage > 0) {
                if (result.sum % 2 === 0) {
                    result.damage = -Math.abs(result.damage); // Pari = cura
                    gameState.history.push(`ü¶ì [Zebratura] Somma pari (${result.sum}) ‚Üí conversione in cura`);
                } else {
                    gameState.history.push(`ü¶ì [Zebratura] Somma dispari (${result.sum}) ‚Üí mantiene danno`);
                }
            }
            
            // ALTA MAREA - modifica danni in base agli HP
            if (gfx.altaMarea && target && result.damage > 0) {
                const halfInitialHP = Math.ceil(gameState.initialHP / 2); // Arrotonda per ECCESSO
                const originalDamage = result.damage;
                if (target.hp > halfInitialHP) {
                    // HP alti: raddoppia (se Saldi attivo: √ó2 poi √∑2 = normale)
                    result.damage = Math.floor(result.damage * 2);
                    gameState.history.push(`üåä [Alta Marea] ${target.name} (${target.hp}>${halfInitialHP}) ‚Üí danni x2: ${originalDamage} ‚Üí ${result.damage}`);
                } else if (target.hp <= halfInitialHP && !alreadyHalvedDamage) {
                    // HP bassi: dimezza SOLO se non gi√† dimezzato da Saldi
                    result.damage = Math.floor(result.damage / 2);
                    gameState.history.push(`üåä [Alta Marea] ${target.name} (${target.hp}‚â§${halfInitialHP}) ‚Üí danni /2: ${originalDamage} ‚Üí ${result.damage}`);
                } else if (target.hp <= halfInitialHP && alreadyHalvedDamage) {
                    // Gi√† dimezzato: non dimezzare di nuovo
                    gameState.history.push(`üåä [Alta Marea] ${target.name} (${target.hp}‚â§${halfInitialHP}) ‚Üí gi√† dimezzato (Saldi Estivi)`);
                }
            }
            
            // PARI PAZZO - somme pari subiscono danno pari alla giocata
            if (gfx.pariPazzo && result.sum % 2 === 0 && result.damage > 0) {
                shooter.hp = Math.max(0, shooter.hp - result.damage);
                // Traccia statistiche auto-danni
                if (!gameState.stats[shooter.name]) {
                    gameState.stats[shooter.name] = { damageDealt: 0, damageTaken: 0, healingDone: 0, specialMoves: 0, turns: 0 };
                }
                gameState.stats[shooter.name].damageTaken += result.damage;
                gameState.history.push(`üé≤ [Pari Pazzo] ${shooter.name} ha ottenuto somma pari (${result.sum}) ‚Üí subisce ${result.damage} danni auto-inflitti`);
                if (shooter.hp === 0 && !shooter.isEliminated) {
                    shooter.isEliminated = true;
                    gameState.history.push(`üíÄ ${shooter.name} √® stato eliminato dall'effetto Pari Pazzo!`);
                }
            }
            
            // PIOGGIA ACIDA - tutti subiscono danno = dado pi√π alto
            if (gfx.pioggiaAcida && result.shooterIndex !== gfx.pioggiaAcidaActivator) {
                const maxDice = Math.max(...result.dice);
                let affectedPlayers = [];
                gameState.players.forEach((p, idx) => {
                    if (!p.isEliminated && idx !== gfx.pioggiaAcidaActivator) {
                        p.hp = Math.max(0, p.hp - maxDice);
                        affectedPlayers.push(p.name);
                        if (p.hp === 0 && !p.isEliminated) p.isEliminated = true;
                    }
                });
                gameState.history.push(`‚òî [Pioggia Acida] Tutti (escluso attivatore) subiscono ${maxDice} danni: ${affectedPlayers.join(', ')}`);
            }
            
            // CANNONE KARMA - danni a bersaglio E a s√© stesso
            if (gfx.cannoneKarma && result.shooterIndex !== gfx.cannoneKarmaActivator && result.damage > 0) {
                shooter.hp = Math.max(0, shooter.hp - result.damage);
                // Traccia statistiche auto-danni
                if (!gameState.stats[shooter.name]) {
                    gameState.stats[shooter.name] = { damageDealt: 0, damageTaken: 0, healingDone: 0, specialMoves: 0, turns: 0 };
                }
                gameState.stats[shooter.name].damageTaken += result.damage;
                gameState.history.push(`üí• [Cannone Karma] ${shooter.name} subisce ${result.damage} danni auto-inflitti (stesso danno del bersaglio)`);
                if (shooter.hp === 0 && !shooter.isEliminated) {
                    shooter.isEliminated = true;
                    gameState.history.push(`üíÄ ${shooter.name} √® stato eliminato dal Cannone Karma!`);
                }
            }
            
            // TALISMANO DI RA E DADO AVVELENATO - controllo per tutti i giocatori
            gameState.players.forEach((p, idx) => {
                if (p.talismanRa && p.talismanRaValues.length === 2 && idx !== result.shooterIndex) {
                    const [val1, val2] = p.talismanRaValues;
                    let matchCount = 0;
                    result.dice.forEach(d => {
                        if (d === val1 || d === val2) matchCount++;
                    });
                    if (matchCount > 0) {
                        const heal = val1 * val2 * matchCount;
                        p.hp += heal;
                        gameState.history.push(`üåû [Talismano Ra] ${p.name} guadagna +${heal} HP (dadi ${val1},${val2} √ó ${matchCount} match)`);
                    }
                }
                
                if (p.dadoAvvelenato && p.dadoAvvelenatotValues.length === 2 && idx === result.shooterIndex) {
                    const [val1, val2] = p.dadoAvvelenatotValues;
                    let matchCount = 0;
                    result.dice.forEach(d => {
                        if (d === val1 || d === val2) matchCount++;
                    });
                    if (matchCount > 0) {
                        const damage = val1 * val2 * matchCount;
                        shooter.hp = Math.max(0, shooter.hp - damage);
                        gameState.history.push(`‚ò†Ô∏è [Dado Avvelenato] ${shooter.name} subisce -${damage} danni (dadi ${val1},${val2} √ó ${matchCount} match)`);
                        if (shooter.hp === 0 && !shooter.isEliminated) {
                            shooter.isEliminated = true;
                            gameState.history.push(`üíÄ ${shooter.name} √® stato eliminato dal Dado Avvelenato!`);
                        }
                    }
                }
            });

            // IMPORTANTE: Riassegna target dopo effetti globali (Bambola Voodoo pu√≤ cambiare targetIndex)
            const finalTarget = result.targetIndex >= 0 ? gameState.players[result.targetIndex] : null;

            // Apply damage
            if (finalTarget) {
                // Initialize stats for target if not exists
                if (!gameState.stats[finalTarget.name]) {
                    gameState.stats[finalTarget.name] = {
                        damageDealt: 0,
                        damageTaken: 0,
                        healingDone: 0,
                        specialMoves: 0,
                        turns: 0
                    };
                }
                
                // Apply multiplier to damage (calcolo anticipato per Volo Fenice)
                const multiplier = finalTarget.multiplier || 1;
                let actualDamage = Math.ceil(result.damage * multiplier);
                
                // BOOMERANG - accumula invece di applicare (PRIORIT√Ä MASSIMA - sempre prima di tutto)
                if (gfx.boomerang && result.targetIndex === gfx.boomerangActivator && actualDamage > 0) {
                    gfx.boomerangDamage += actualDamage;
                    gameState.history.push(`ü™É [Boomerang] ${finalTarget.name} accumula ${actualDamage} danni (totale accumulato: ${gfx.boomerangDamage})`);
                    // Non applicare danno ora, verr√† applicato alla fine del turno dell'attivatore
                    database.ref('games/' + gameState.gameCode).update({
                        globalEffects: gameState.globalEffects,
                        history: gameState.history
                    });
                    return; // Esce dalla funzione - Boomerang accumula SEMPRE, anche se immortale
                }
                
                // VOLO DELLA FENICE - cure raddoppiate al posto dei danni (PRIORIT√Ä ALTA)
                if (finalTarget.voloFenice && actualDamage > 0) {
                    const heal = actualDamage * 2;
                    finalTarget.hp += heal;
                    gameState.history.push(`ü¶Ö [Volo Fenice] ${finalTarget.name} converte ${actualDamage} danni in +${heal} HP di cura`);
                    animateHP(result.targetIndex, heal);
                    playSound('heal');
                    if (finalTarget.name === gameState.playerName) {
                        screenFlash('heal');
                        createParticles(window.innerWidth / 2, window.innerWidth / 2, 'heal');
                    }
                    database.ref('games/' + gameState.gameCode).update({
                        players: gameState.players,
                        history: gameState.history
                    });
                    // Non fare altro, il danno √® stato convertito
                } 
                // Check if target is immortal
                else if (finalTarget.isImmortal) {
                    // Immortal player takes no damage
                    gameState.history.push(`‚≠ê ${finalTarget.name} √® immortale e non subisce danni!`);
                    playSound('heal'); // Suono positivo per indicare l'immortalit√†
                    
                    // Visual effect for immortal player
                    if (finalTarget.name === gameState.playerName) {
                        screenFlash('heal');
                        createParticles(window.innerWidth / 2, window.innerHeight / 2, 'heal');
                    }
                } else {

                    const wasAlive = !finalTarget.isEliminated;
                    
                    // === MECCANICHE INDIVIDUALI DEL TARGET ===
                    
                    // INTERFERENZA - trasferisci danno al partner
                    if (finalTarget.interferenza && finalTarget.interferenzaPartner !== null && actualDamage > 0) {
                        const partner = gameState.players[finalTarget.interferenzaPartner];
                        if (partner && !partner.isEliminated) {
                            const originalTargetName = finalTarget.name;
                            result.targetIndex = finalTarget.interferenzaPartner;
                            // Aggiorna il target
                            const newTarget = partner;
                            gameState.history.push(`üîÄ [Interferenza] Danno trasferito da ${originalTargetName} a ${partner.name}`);
                            // Applica il danno al partner invece che continuare con il target originale
                            newTarget.hp = Math.max(0, newTarget.hp - actualDamage);
                            if (newTarget.hp === 0 && !newTarget.isEliminated) {
                                newTarget.isEliminated = true;
                                gameState.history.push(`üíÄ ${newTarget.name} √® stato eliminato!`);
                            }
                            animateHP(finalTarget.interferenzaPartner, -actualDamage);
                            playSound('damage');
                            if (newTarget.name === gameState.playerName) {
                                screenFlash('damage');
                            }
                            // Salta il resto della logica per il target originale
                            database.ref('games/' + gameState.gameCode).update({
                                players: gameState.players,
                                history: gameState.history,
                                stats: gameState.stats
                            });
                            return;
                        } else {
                            // Partner eliminato: disattiva Interferenza
                            finalTarget.interferenza = false;
                            finalTarget.interferenzaPartner = null;
                            gameState.history.push(`‚ùå [Interferenza] Effetto disattivato (partner ${partner ? partner.name : 'sconosciuto'} eliminato)`);
                            // Continua con danno normale a finalTarget
                        }
                    }
                    
                    
                    // ARMATURA SPECCHIO - distribuisci danno a tutti
                    if (gfx.armaturaSpecchio && result.targetIndex === gfx.armaturaSpecchioActivator && actualDamage > 0) {
                        const activePlayers = gameState.players.filter(p => !p.isEliminated);
                        const damagePerPlayer = Math.ceil(actualDamage / activePlayers.length);
                        let affectedNames = [];
                        activePlayers.forEach(p => {
                            p.hp = Math.max(0, p.hp - damagePerPlayer);
                            affectedNames.push(p.name);
                            if (p.hp === 0 && !p.isEliminated) {
                                p.isEliminated = true;
                                gameState.history.push(`üíÄ ${p.name} √® stato eliminato!`);
                            }
                        });
                        gameState.history.push(`ü™û [Armatura Specchio] ${damagePerPlayer} danni distribuiti a tutti: ${affectedNames.join(', ')}`);
                        playSound('damage');
                        database.ref('games/' + gameState.gameCode).update({
                            players: gameState.players,
                            history: gameState.history
                        });
                        return; // Esce dalla funzione
                    }
                    
                    // RIFLETTI DANNI - rifletti sull'attaccante
                    if (finalTarget.rifletteDanni && actualDamage > 0) {
                        shooter.hp = Math.max(0, shooter.hp - actualDamage);
                        gameState.history.push(`üõ°Ô∏è [Rifletti Danni] ${shooter.name} subisce ${actualDamage} danni riflessi da ${finalTarget.name}`);
                        if (shooter.hp === 0 && !shooter.isEliminated) {
                            shooter.isEliminated = true;
                            gameState.history.push(`üíÄ ${shooter.name} √® stato eliminato dal riflesso!`);
                        }
                        animateHP(result.shooterIndex, -actualDamage);
                        playSound('damage');
                        database.ref('games/' + gameState.gameCode).update({
                            players: gameState.players,
                            history: gameState.history
                        });
                        return; // Target non subisce danno
                    }
                    
                    // MARE DI GUAI - applica moltiplicatore x2 all'attaccante e salta turno
                    if (finalTarget.mareGuai && actualDamage > 0) {
                        // Applica moltiplicatore x2 solo se l'attaccante non ne ha gi√† uno
                        if (shooter.multiplier === 1) {
                            shooter.multiplier = 2;
                            shooter.multiplierAppliedBy = result.shooterIndex; // Si auto-applica
                            shooter.temporaryEffects.multiplier = true; // Dura 1 turno dell'attaccante
                            gameState.history.push(`üåä [Mare di Guai] ${shooter.name} ottiene moltiplicatore danni x2 per il prossimo turno`);
                        } else {
                            gameState.history.push(`üåä [Mare di Guai] ${shooter.name} ha gi√† un moltiplicatore attivo (x${shooter.multiplier}) - Mare di Guai non ha effetto`);
                        }
                        // Far saltare il turno (solo se non sta gi√† saltando)
                        if (!shooter.skipTurn) {
                            shooter.skipTurn = true;
                            gameState.history.push(`üåä [Mare di Guai] ${shooter.name} salter√† il prossimo turno`);
                        } else {
                            gameState.history.push(`üåä [Mare di Guai] ${shooter.name} sta gi√† saltando il prossimo turno`);
                        }
                        // Il target subisce comunque i danni normalmente (continua con il flusso)
                    }
                    
                    // CACTUS AMARI - subisce e riflette il doppio
                    if (finalTarget.cactusAmari && actualDamage > 0) {
                        const reflectedDamage = actualDamage * 2;
                        shooter.hp = Math.max(0, shooter.hp - reflectedDamage);
                        // Traccia statistiche riflessi
                        if (!gameState.stats[shooter.name]) {
                            gameState.stats[shooter.name] = { damageDealt: 0, damageTaken: 0, healingDone: 0, specialMoves: 0, turns: 0 };
                        }
                        if (!gameState.stats[finalTarget.name]) {
                            gameState.stats[finalTarget.name] = { damageDealt: 0, damageTaken: 0, healingDone: 0, specialMoves: 0, turns: 0 };
                        }
                        gameState.stats[shooter.name].damageTaken += reflectedDamage;
                        gameState.stats[finalTarget.name].damageDealt += reflectedDamage;
                        gameState.history.push(`üåµ [Cactus Amari] ${shooter.name} subisce ${reflectedDamage} danni riflessi (x2) da ${finalTarget.name}`);
                        if (shooter.hp === 0 && !shooter.isEliminated) {
                            shooter.isEliminated = true;
                            gameState.history.push(`üíÄ ${shooter.name} √® stato eliminato dalle spine!`);
                        }
                        animateHP(result.shooterIndex, -reflectedDamage);
                        // Il target subisce comunque il danno normale
                    }
                    
                    // CATENA MALEDETTA - infligge danno ai giocatori adiacenti
                    if (finalTarget.catenaMaledetta && actualDamage > 0) {
                        const targetIdx = result.targetIndex;
                        const prevIdx = (targetIdx - 1 + gameState.players.length) % gameState.players.length;
                        const nextIdx = (targetIdx + 1) % gameState.players.length;
                        
                        let chainedPlayers = [];
                        [prevIdx, nextIdx].forEach(idx => {
                            const adjacent = gameState.players[idx];
                            if (adjacent && !adjacent.isEliminated && idx !== result.targetIndex) {
                                adjacent.hp = Math.max(0, adjacent.hp - actualDamage);
                                chainedPlayers.push(adjacent.name);
                                if (adjacent.hp === 0 && !adjacent.isEliminated) {
                                    adjacent.isEliminated = true;
                                    gameState.history.push(`üíÄ ${adjacent.name} √® stato eliminato dalla catena!`);
                                }
                            }
                        });
                        if (chainedPlayers.length > 0) {
                            gameState.history.push(`‚õìÔ∏è [Catena Maledetta] Giocatori adiacenti colpiti (${actualDamage} danni): ${chainedPlayers.join(', ')}`);
                        }
                    }
                    
                    // SABBIE MOBILI - chi viene colpito salta il turno
                    if (gfx.sabbieMobili && result.shooterIndex !== gfx.sabbieMobiliActivator && actualDamage > 0) {
                        if (result.targetIndex !== gfx.sabbieMobiliActivator) {
                            if (!finalTarget.skipTurn) {
                                finalTarget.skipTurn = true;
                                gameState.history.push(`‚è≥ [Sabbie Mobili] ${finalTarget.name} salter√† il prossimo turno`);
                            } else {
                                gameState.history.push(`‚è≥ [Sabbie Mobili] ${finalTarget.name} sta gi√† saltando il prossimo turno`);
                            }
                        }
                    }
                    
                    // Check for damage conversion effects
                    let shouldConvertToHeal = false;
                    let conversionReason = '';
                    
                    // 1. Conversione Danni‚ÜíCure (üí´) - Converte TUTTI i danni
                    if (finalTarget.damageToHeal) {
                        shouldConvertToHeal = true;
                        conversionReason = 'üí´ Conversione Danni‚ÜíCure';
                    }
                    // 2. Armatura del Sole (‚òÄÔ∏è) - Converte solo danni DISPARI
                    else if (finalTarget.sunArmor && actualDamage % 2 !== 0) {
                        shouldConvertToHeal = true;
                        conversionReason = `‚òÄÔ∏è Armatura del Sole (${actualDamage} dispari)`;
                    }
                    // 3. Armatura della Luna (üåô) - Converte solo danni PARI
                    else if (finalTarget.moonArmor && actualDamage % 2 === 0) {
                        shouldConvertToHeal = true;
                        conversionReason = `üåô Armatura della Luna (${actualDamage} pari)`;
                    }
                    
                    if (shouldConvertToHeal) {
                        // Converti danno in cura (NON aggiornare damageDealt/Taken!)
                        finalTarget.hp += actualDamage;
                        gameState.history.push(`${conversionReason}: ${finalTarget.name} si cura di ${actualDamage} HP invece di subirli!`);
                        animateHP(result.targetIndex, actualDamage);
                        playSound('heal');
                        
                        // Visual effects for heal
                        if (finalTarget.name === gameState.playerName) {
                            screenFlash('heal');
                            createParticles(window.innerWidth / 2, window.innerHeight / 2, 'heal');
                        }
                    } else {
                        // Applica danno normalmente - SOLO QUI aggiorniamo le stats
                        gameState.stats[shooter.name].damageDealt += actualDamage;
                        gameState.stats[finalTarget.name].damageTaken += actualDamage;
                        
                        finalTarget.hp = Math.max(0, finalTarget.hp - actualDamage);
                        
                        // Check Checkmate - auto-eliminate at exact HP value
                        if (finalTarget.checkmateHP && finalTarget.hp === finalTarget.checkmateHP && !finalTarget.isEliminated) {
                            finalTarget.hp = 0;
                            finalTarget.isEliminated = true;
                            gameState.history.push(`‚ôüÔ∏è ${finalTarget.name} √® stato eliminato dallo Scacco Matto! (${finalTarget.checkmateHP} HP)`);
                            
                            // Show elimination notification
                            if (finalTarget.name === gameState.playerName && !gameState.isMaster) {
                                setTimeout(() => showEliminatedNotification(), 500);
                            }
                            
                            playSound('elimination');
                        }
                        // Check Kraken Mark - auto-eliminate at 10 HP or less
                        else if (finalTarget.krakenMark && finalTarget.hp <= 10 && finalTarget.hp > 0 && !finalTarget.isEliminated) {
                            finalTarget.hp = 0;
                            finalTarget.isEliminated = true;
                            gameState.history.push(`üêô ${finalTarget.name} √® stato eliminato dal Marchio del Kraken! (HP ‚â§ 10)`);
                            
                            // Show elimination notification
                            if (finalTarget.name === gameState.playerName && !gameState.isMaster) {
                                setTimeout(() => showEliminatedNotification(), 500);
                            }
                            
                            playSound('elimination');
                        } else if (finalTarget.hp === 0 && wasAlive) {
                            // === RESET TUTTI GLI EFFETTI QUANDO ELIMINATO ===
                            finalTarget.isImmortal = false;
                            finalTarget.multiplier = 1;
                            finalTarget.multiplierAppliedBy = null;
                            finalTarget.skipTurn = false;
                            finalTarget.customDiceCount = null;
                            finalTarget.krakenMark = false;
                            finalTarget.checkmateHP = null;
                            finalTarget.damageToHeal = false;
                            finalTarget.sunArmor = false;
                            finalTarget.moonArmor = false;
                            finalTarget.mareGuai = false;
                            finalTarget.voloFenice = false;
                            finalTarget.cactusAmari = false;
                            finalTarget.catenaMaledetta = false;
                            finalTarget.rifletteDanni = false;
                            target.talismanRa = false;
                            target.talismanRaValues = [];
                            target.dadoAvvelenato = false;
                            target.dadoAvvelenatotValues = [];
                            finalTarget.interferenza = false;
                            finalTarget.interferenzaPartner = null;
                            finalTarget.temporaryEffects = {
                                immortal: false, multiplier: false, skipTurn: false, customDice: false,
                                damageToHeal: false, sunArmor: false, moonArmor: false,
                                mareGuai: false, voloFenice: false, cactusAmari: false,
                                catenaMaledetta: false, rifletteDanni: false,
                                talismanRa: false, dadoAvvelenato: false
                            };
                            
                            // === CARTE RESURREZIONE (in ordine di priorit√†) ===
                            let resurrected = false;
                            
                            // 1. CANTO DEL CIGNO
                            if (finalTarget.cantoDelCigno) {
                                finalTarget.hp = 1;
                                finalTarget.isEliminated = false;
                                finalTarget.cantoDelCigno = false;
                                gameState.history.push(`ü¶¢ [Canto del Cigno] ${finalTarget.name} torna in vita con 1 HP!`);
                                playSound('revive');
                                if (finalTarget.name === gameState.playerName) {
                                    screenFlash('revive');
                                }
                                resurrected = true;
                            }
                            // 2. PATTO CON IL DIAVOLO
                            else if (finalTarget.pattoDiavolo && !finalTarget.pattoDiavoloUsed) {
                                finalTarget.hp = 20;
                                finalTarget.isEliminated = false;
                                finalTarget.customDiceCount = 2; // Solo 2 dadi per sempre
                                finalTarget.pattoDiavolo = false;
                                finalTarget.pattoDiavoloUsed = true;
                                gameState.history.push(`üòà [Patto col Diavolo] ${finalTarget.name} torna con 20 HP, ma user√† solo 2 dadi per sempre`);
                                playSound('revive');
                                if (finalTarget.name === gameState.playerName) {
                                    screenFlash('revive');
                                }
                                resurrected = true;
                            }
                            // 3. TOMBA DI TUTANKHAMON
                            else if (finalTarget.tombaTutankhamon) {
                                finalTarget.hp = Math.ceil(gameState.initialHP / 2);
                                finalTarget.isEliminated = false;
                                finalTarget.skipTurn = true;
                                finalTarget.tombaTutankhamon = false;
                                gameState.history.push(`üè∫ [Tomba Tutankhamon] ${finalTarget.name} torna con ${finalTarget.hp} HP, ma salter√† il prossimo turno`);
                                playSound('revive');
                                if (finalTarget.name === gameState.playerName) {
                                    screenFlash('revive');
                                }
                                resurrected = true;
                            }
                            // 4. REINCARNAZIONE
                            else if (finalTarget.reincarnazione && !finalTarget.reincarnazioneUsed) {
                                finalTarget.hp = gameState.initialHP;
                                finalTarget.isEliminated = false;
                                finalTarget.multiplier = 2; // Danni x2 permanenti
                                finalTarget.reincarnazione = false;
                                finalTarget.reincarnazioneUsed = true;
                                gameState.history.push(`‚ôªÔ∏è [Reincarnazione] ${finalTarget.name} torna con ${finalTarget.hp} HP, ma subir√† danni x2 permanentemente`);
                                playSound('revive');
                                if (finalTarget.name === gameState.playerName) {
                                    screenFlash('revive');
                                }
                                resurrected = true;
                            }
                            
                            // Nessuna resurrezione - eliminato definitivamente
                            if (!resurrected) {
                                finalTarget.isEliminated = true;
                                gameState.history.push(`üíÄ ${finalTarget.name} √® stato eliminato!`);
                                
                                // Show elimination notification
                                if (finalTarget.name === gameState.playerName && !gameState.isMaster) {
                                    setTimeout(() => showEliminatedNotification(), 500);
                                }
                                
                                playSound('elimination');
                            }
                            
                            // === BOIA ESECUTORE ===
                            if (shooter.boiaEsecutore && shooter.boiaEsecutoreTurns > 0 && finalTarget.isEliminated) {
                                let nextPlayerIndex = (result.targetIndex + 1) % gameState.players.length;
                                let attempts = 0;
                                // Salta giocatori eliminati E l'attivatore del Boia Esecutore
                                while ((gameState.players[nextPlayerIndex].isEliminated || nextPlayerIndex === result.shooterIndex) && attempts < gameState.players.length) {
                                    nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;
                                    attempts++;
                                }
                                
                                const nextPlayer = gameState.players[nextPlayerIndex];
                                // Verifica che non sia l'attivatore e che sia vivo
                                if (nextPlayer && !nextPlayer.isEliminated && nextPlayerIndex !== result.shooterIndex) {
                                    nextPlayer.hp = 0;
                                    nextPlayer.isEliminated = true;
                                    // Reset effetti anche per questo giocatore
                                    nextPlayer.isImmortal = false;
                                    nextPlayer.multiplier = 1;
                                    nextPlayer.multiplierAppliedBy = null;
                                    nextPlayer.skipTurn = false;
                                    nextPlayer.customDiceCount = null;
                                    nextPlayer.krakenMark = false;
                                    nextPlayer.checkmateHP = null;
                                    nextPlayer.damageToHeal = false;
                                    nextPlayer.sunArmor = false;
                                    nextPlayer.moonArmor = false;
                                    nextPlayer.mareGuai = false;
                                    nextPlayer.voloFenice = false;
                                    nextPlayer.cactusAmari = false;
                                    nextPlayer.catenaMaledetta = false;
                                    nextPlayer.rifletteDanni = false;
                                    nextPlayer.talismanRa = false;
                                    nextPlayer.talismanRaValues = [];
                                    nextPlayer.dadoAvvelenato = false;
                                    nextPlayer.dadoAvvelenatotValues = [];
                                    nextPlayer.interferenza = false;
                                    nextPlayer.interferenzaPartner = null;
                                    nextPlayer.cantoDelCigno = false;
                                    nextPlayer.pattoDiavolo = false;
                                    nextPlayer.tombaTutankhamon = false;
                                    nextPlayer.reincarnazione = false;
                                    
                                    gameState.history.push(`ü™ì [Boia Esecutore] ${shooter.name} elimina istantaneamente anche ${nextPlayer.name}!`);
                                    playSound('elimination');
                                }
                            }
                        } else {
                            playSound('hit');
                            
                            // Visual effects for the player who got hit
                            if (finalTarget.name === gameState.playerName) {
                                screenFlash('damage');
                                createParticles(window.innerWidth / 2, window.innerHeight / 2, 'damage');
                            }
                        }
                        
                        animateHP(result.targetIndex, -actualDamage);
                        
                        // Add multiplier info to history
                        if (multiplier !== 1) {
                            gameState.history.push(`‚ú® ${finalTarget.name} ha un moltiplicatore x${multiplier}! Danno effettivo: ${actualDamage}`);
                        }
                    }
                }
            }

            // Apply heal
            if (result.selfHeal > 0) {
                // Apply multiplier to heal
                const multiplier = shooter.multiplier || 1;
                const actualHeal = Math.ceil(result.selfHeal * multiplier); // Arrotonda per eccesso
                
                shooter.hp += actualHeal;
                gameState.stats[shooter.name].healingDone += actualHeal;
                animateHP(result.shooterIndex, actualHeal);
                playSound('heal');
                
                // Visual effects for healer
                if (shooter.name === gameState.playerName) {
                    screenFlash('heal');
                    createParticles(window.innerWidth / 2, window.innerHeight / 2, 'heal');
                }
                
                // Add multiplier info to history
                if (multiplier !== 1) {
                    gameState.history.push(`‚ú® ${shooter.name} ha un moltiplicatore x${multiplier}! Cura effettiva: ${actualHeal}`);
                }
            }
            
            // Track special moves
            if (result.specialEffect === 'Coppia' || result.specialEffect === 'Tris') {
                gameState.stats[shooter.name].specialMoves++;
            }

            // History - Messaggio principale del turno
            let historyText = `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
            historyText += `üéÆ TURNO ${gameState.stats[shooter.name]?.turns || 1} - ${shooter.name.toUpperCase()}\n`;
            historyText += `üé≤ Dadi lanciati: ${result.dice.join(' ¬∑ ')} = ${result.sum}`;
            
            if (result.specialEffect) {
                if (result.specialEffect === 'Tris') {
                    historyText += `\n‚ú® TRIS! ${result.specialEffect}`;
                } else if (result.specialEffect === 'Coppia') {
                    historyText += `\n‚ú® COPPIA! ${result.specialEffect}`;
                }
            }
            
            if (target) {
                if (result.damage > 0) {
                    historyText += `\nüí• DANNO: ${result.damage} ‚Üí ${target.name}`;
                } else if (result.damage < 0) {
                    historyText += `\nüíö CURA: ${Math.abs(result.damage)} ‚Üí ${target.name}`;
                }
            }
            
            if (result.selfHeal > 0) {
                historyText += `\n‚ù§Ô∏è AUTO-CURA: +${result.selfHeal} HP`;
            }
            
            if (result.cardsDrawn > 0) {
                historyText += `\nüÉè Pesca ${result.cardsDrawn} carta${result.cardsDrawn > 1 ? 'e' : ''} del Fato`;
            }
            
            gameState.history.push(historyText);

            // Reset temporary effects for the player who just played
            resetTemporaryEffects(result.shooterIndex);

            // Next turn
            const nextTurn = getNextActiveTurn();

            // Update Firebase
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                currentTurn: nextTurn,
                history: gameState.history,
                stats: gameState.stats
            });
        }

        function showEliminatedNotification() {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'hit-overlay';
            document.body.appendChild(overlay);
            
            setTimeout(() => overlay.classList.add('show'), 10);

            // Create notification
            const notification = document.createElement('div');
            notification.className = 'eliminated-notification';
            notification.innerHTML = `
                <h2>‚ò†Ô∏è SEI STATO ELIMINATO! ‚ò†Ô∏è</h2>
                <div style="font-size: 1.3em; color: #ff6b6b; margin-top: 20px;">
                    La partita continua...
                </div>
            `;
            document.body.appendChild(notification);

            // Show animation
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);

            // Vibrate if supported
            if (navigator.vibrate) {
                navigator.vibrate([300, 100, 300, 100, 500]);
            }

            // Remove after 4 seconds
            setTimeout(() => {
                overlay.style.opacity = '0';
                notification.style.transform = 'translate(-50%, -50%) scale(0)';
                setTimeout(() => {
                    notification.remove();
                    overlay.remove();
                }, 400);
            }, 4000);
        }

        function showWinnerNotification(winnerName, isYou = false) {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'hit-overlay';
            document.body.appendChild(overlay);
            
            setTimeout(() => overlay.classList.add('show'), 10);

            // Build statistics HTML
            let statsHTML = '';
            if (Object.keys(gameState.stats).length > 0) {
                // Find MVP (most damage dealt)
                let mvpName = '';
                let maxDamage = 0;
                let mostHealing = 0;
                let healerName = '';
                let mostSpecials = 0;
                let specialistName = '';
                
                Object.keys(gameState.stats).forEach(name => {
                    const stats = gameState.stats[name];
                    if (stats.damageDealt > maxDamage) {
                        maxDamage = stats.damageDealt;
                        mvpName = name;
                    }
                    if (stats.healingDone > mostHealing) {
                        mostHealing = stats.healingDone;
                        healerName = name;
                    }
                    if (stats.specialMoves > mostSpecials) {
                        mostSpecials = stats.specialMoves;
                        specialistName = name;
                    }
                });
                
                statsHTML = `
                    <div class="game-stats">
                        <h3>üìä Statistiche Partita</h3>
                        ${mvpName ? `<div class="stat-item">
                            <span class="label">üèÖ MVP (Pi√π Danni)</span>
                            <span class="value">${mvpName} - ${maxDamage} danni</span>
                        </div>` : ''}
                        ${healerName && mostHealing > 0 ? `<div class="stat-item">
                            <span class="label">üíö Miglior Guaritore</span>
                            <span class="value">${healerName} - ${mostHealing} HP</span>
                        </div>` : ''}
                        ${specialistName && mostSpecials > 0 ? `<div class="stat-item">
                            <span class="label">‚ú® Re delle Combo</span>
                            <span class="value">${specialistName} - ${mostSpecials} speciali</span>
                        </div>` : ''}
                        <div class="stat-item">
                            <span class="label">‚è±Ô∏è Durata Partita</span>
                            <span class="value">${getGameDuration()}</span>
                        </div>
                    </div>
                `;
            }

            // Create notification
            const notification = document.createElement('div');
            notification.className = 'winner-notification';
            notification.innerHTML = `
                <h2>üèÜ ${isYou ? 'HAI VINTO!' : 'PARTITA TERMINATA!'} üèÜ</h2>
                <div class="winner-name">${winnerName}</div>
                <div style="font-size: 1.2em; color: #1a1a2e; margin-top: 20px; font-weight: 600;">
                    ${isYou ? 'Complimenti campione!' : '√® il vincitore!'}
                </div>
                ${statsHTML}
            `;
            document.body.appendChild(notification);

            // Show animation
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);

            // Vibrate if supported
            if (navigator.vibrate && isYou) {
                navigator.vibrate([100, 50, 100, 50, 100, 50, 500]);
            }

            // Add new game button for master after 3 seconds
            if (gameState.isMaster) {
                setTimeout(() => {
                    const newGameBtn = document.createElement('button');
                    newGameBtn.textContent = 'üéÆ Nuova Partita';
                    newGameBtn.style.cssText = 'margin-top: 20px; width: auto; padding: 15px 30px;';
                    newGameBtn.onclick = () => {
                        startNewGame();
                    };
                    notification.appendChild(newGameBtn);
                }, 3000);
            }
        }
        
        function startNewGame() {
            if (!gameState.isMaster) return;
            
            if (!confirm('Vuoi iniziare una nuova partita con gli stessi giocatori?')) return;
            
            // Reset game state keeping players connected
            const resetPlayers = gameState.players.map(player => ({
                ...player,
                hp: gameState.initialHP || 70,
                isEliminated: false,
                isImmortal: false,
                multiplier: 1,
                multiplierAppliedBy: null,
                skipTurn: false,
                customDiceCount: null,
                krakenMark: false,
                checkmateHP: null,
                damageToHeal: false,
                sunArmor: false,
                moonArmor: false,
                temporaryEffects: {
                    immortal: false,
                    multiplier: false,
                    skipTurn: false,
                    customDice: false,
                    damageToHeal: false,
                    sunArmor: false,
                    moonArmor: false
                }
                // Mantiene: name, isMaster, connected
            }));
            
            // Reset game data
            database.ref('games/' + gameState.gameCode).update({
                players: resetPlayers,
                currentTurn: 0,
                history: ['üéÆ Nuova partita iniziata!'],
                stats: {},
                gameEnded: false,
                winner: null,
                startTime: Date.now(),
                direction: 'clockwise'
            });
            
            // Reload page to reset UI
            location.reload();
        }
        
        function getGameDuration() {
            if (!gameState.startTime) return '0:00';
            const duration = Date.now() - gameState.startTime;
            const minutes = Math.floor(duration / 60000);
            const seconds = Math.floor((duration % 60000) / 1000);
            return `${minutes}:${String(seconds).padStart(2, '0')}`;
        }

        function getNextActiveTurn() {
            const activePlayers = gameState.players.map((p, i) => i).filter(i => !gameState.players[i].isEliminated);
            
            if (activePlayers.length <= 1) return gameState.currentTurn;

            let nextIndex = gameState.currentTurn;
            let attempts = 0;
            
            do {
                if (gameState.direction === 'clockwise') {
                    nextIndex = (nextIndex + 1) % gameState.players.length;
                } else {
                    nextIndex = (nextIndex - 1 + gameState.players.length) % gameState.players.length;
                }
                attempts++;
                
                // Se il giocatore ha skipTurn attivo, aggiungilo alla history e continua
                if (gameState.players[nextIndex].skipTurn && !gameState.players[nextIndex].isEliminated) {
                    gameState.history.push(`‚è≠Ô∏è ${gameState.players[nextIndex].name} salta il turno`);
                }
                
            } while ((gameState.players[nextIndex].isEliminated || gameState.players[nextIndex].skipTurn) && attempts < gameState.players.length);

            return nextIndex;
        }

        function animateHP(playerIndex, amount) {
            const card = document.getElementById(`player-card-${playerIndex}`);
            if (!card) return;

            if (amount < 0) {
                card.classList.add('animate-damage');
                setTimeout(() => card.classList.remove('animate-damage'), 500);
            } else {
                card.classList.add('animate-heal');
                setTimeout(() => card.classList.remove('animate-heal'), 500);
            }

            showFloatingNumber(card, amount);
        }

        function showFloatingNumber(element, amount) {
            const rect = element.getBoundingClientRect();
            const floater = document.createElement('div');
            floater.className = `floating-number ${amount < 0 ? 'damage' : 'heal'}`;
            floater.textContent = amount > 0 ? `+${amount}` : amount;
            floater.style.left = rect.left + rect.width / 2 + 'px';
            floater.style.top = rect.top + 'px';
            
            document.body.appendChild(floater);
            setTimeout(() => floater.remove(), 1000);
        }

        function playSound(type) {
            if (!window.AudioContext && !window.webkitAudioContext) return;
            
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            switch(type) {
                case 'hit':
                    // Suono di colpo potenziato - effetto esplosivo
                    const hitOsc = audioContext.createOscillator();
                    const hitGain = audioContext.createGain();
                    const hitNoise = audioContext.createBufferSource();
                    const hitNoiseGain = audioContext.createGain();
                    
                    // Crea rumore bianco per l'impatto
                    const hitBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
                    const hitData = hitBuffer.getChannelData(0);
                    for (let i = 0; i < hitBuffer.length; i++) {
                        hitData[i] = Math.random() * 2 - 1;
                    }
                    hitNoise.buffer = hitBuffer;
                    
                    hitOsc.connect(hitGain);
                    hitGain.connect(audioContext.destination);
                    hitNoise.connect(hitNoiseGain);
                    hitNoiseGain.connect(audioContext.destination);
                    
                    hitOsc.frequency.setValueAtTime(500, audioContext.currentTime);
                    hitOsc.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.15);
                    hitGain.gain.setValueAtTime(0.4, audioContext.currentTime);
                    hitGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    hitNoiseGain.gain.setValueAtTime(0.3, audioContext.currentTime);
                    hitNoiseGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
                    
                    hitOsc.type = 'sawtooth';
                    hitOsc.start(audioContext.currentTime);
                    hitOsc.stop(audioContext.currentTime + 0.15);
                    hitNoise.start(audioContext.currentTime);
                    hitNoise.stop(audioContext.currentTime + 0.08);
                    break;
                    
                case 'heal':
                    // Suono di cura magico - arpeggio ascendente con riverbero
                    const healFreqs = [261.63, 329.63, 392.00, 523.25]; // C4, E4, G4, C5
                    healFreqs.forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.value = freq;
                        osc.type = 'sine';
                        const delay = i * 0.08;
                        gain.gain.setValueAtTime(0.2, audioContext.currentTime + delay);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + delay + 0.4);
                        osc.start(audioContext.currentTime + delay);
                        osc.stop(audioContext.currentTime + delay + 0.4);
                    });
                    break;
                    
                case 'elimination':
                    // Suono di eliminazione epico - discesa drammatica
                    const elimOsc1 = audioContext.createOscillator();
                    const elimOsc2 = audioContext.createOscillator();
                    const elimGain = audioContext.createGain();
                    
                    elimOsc1.connect(elimGain);
                    elimOsc2.connect(elimGain);
                    elimGain.connect(audioContext.destination);
                    
                    elimOsc1.frequency.setValueAtTime(800, audioContext.currentTime);
                    elimOsc1.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + 0.6);
                    elimOsc2.frequency.setValueAtTime(400, audioContext.currentTime);
                    elimOsc2.frequency.exponentialRampToValueAtTime(20, audioContext.currentTime + 0.6);
                    
                    elimGain.gain.setValueAtTime(0.5, audioContext.currentTime);
                    elimGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
                    
                    elimOsc1.type = 'sawtooth';
                    elimOsc2.type = 'square';
                    elimOsc1.start(audioContext.currentTime);
                    elimOsc2.start(audioContext.currentTime);
                    elimOsc1.stop(audioContext.currentTime + 0.6);
                    elimOsc2.stop(audioContext.currentTime + 0.6);
                    break;
                    
                case 'revive':
                    // Suono di rianimazione celestiale - campane magiche
                    const reviveFreqs = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
                    reviveFreqs.forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.value = freq;
                        osc.type = 'triangle';
                        const delay = i * 0.1;
                        gain.gain.setValueAtTime(0.25, audioContext.currentTime + delay);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + delay + 0.5);
                        osc.start(audioContext.currentTime + delay);
                        osc.stop(audioContext.currentTime + delay + 0.5);
                    });
                    break;
                    
                case 'poker':
                    // Suono di vittoria epico - fanfara orchestrale
                    const victorySequence = [
                        { freq: 523.25, time: 0 },     // C5
                        { freq: 659.25, time: 0.12 },  // E5
                        { freq: 783.99, time: 0.24 },  // G5
                        { freq: 1046.50, time: 0.36 }, // C6
                        { freq: 1318.51, time: 0.48 }  // E6
                    ];
                    
                    victorySequence.forEach(note => {
                        const osc1 = audioContext.createOscillator();
                        const osc2 = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        
                        osc1.connect(gain);
                        osc2.connect(gain);
                        gain.connect(audioContext.destination);
                        
                        osc1.frequency.value = note.freq;
                        osc2.frequency.value = note.freq * 1.5;
                        osc1.type = 'sine';
                        osc2.type = 'triangle';
                        
                        gain.gain.setValueAtTime(0.35, audioContext.currentTime + note.time);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + note.time + 0.4);
                        
                        osc1.start(audioContext.currentTime + note.time);
                        osc2.start(audioContext.currentTime + note.time);
                        osc1.stop(audioContext.currentTime + note.time + 0.4);
                        osc2.stop(audioContext.currentTime + note.time + 0.4);
                    });
                    return;
            }
        }
        
        function screenFlash(type) {
            const flash = document.createElement('div');
            flash.className = `screen-flash ${type}`;
            document.body.appendChild(flash);
            
            setTimeout(() => flash.remove(), 1500);
            
            // Add shake effect for damage
            if (type === 'damage') {
                document.body.classList.add('shake');
                setTimeout(() => document.body.classList.remove('shake'), 500);
            }
        }
        
        function createParticles(x, y, type) {
            const particles = type === 'damage' ? ['üí•', 'üí¢', '‚ö°'] : 
                             type === 'heal' ? ['üíö', '‚ú®', 'üí´'] :
                             ['üåü', '‚ú®', '‚≠ê'];
            
            const count = type === 'revive' ? 12 : 8;
            
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = particles[Math.floor(Math.random() * particles.length)];
                
                const angle = (360 / count) * i;
                const distance = 100 + Math.random() * 50;
                const tx = Math.cos(angle * Math.PI / 180) * distance;
                const ty = Math.sin(angle * Math.PI / 180) * distance;
                
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.setProperty('--tx', tx + 'px');
                particle.style.setProperty('--ty', ty + 'px');
                
                document.body.appendChild(particle);
                
                setTimeout(() => particle.remove(), 1500);
            }
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                if (!gameState.startTime) return;
                
                const elapsed = Date.now() - gameState.startTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                
                document.getElementById('timer').textContent = 
                    `Tempo: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }

        // Master Controls
        function reverseDirection() {
            if (!gameState.isMaster) return;
            
            const newDirection = gameState.direction === 'clockwise' ? 'counterclockwise' : 'clockwise';
            database.ref('games/' + gameState.gameCode).update({ direction: newDirection });
            
            gameState.history.push('‚≠Æ Direzione invertita');
            database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
        }
        
        function rollbackLastTurn() {
            if (!gameState.isMaster) return;
            
            if (!gameState.previousState) {
                alert('Nessuna azione da annullare!');
                return;
            }
            
            if (!confirm('Vuoi annullare l\'ultima giocata e far ripetere il turno?')) return;
            
            // Restore previous state
            gameState.players = gameState.previousState.players;
            gameState.currentTurn = gameState.previousState.currentTurn;
            gameState.history = gameState.previousState.history;
            gameState.stats = gameState.previousState.stats;
            
            gameState.history.push('‚Ü©Ô∏è Ultima giocata annullata dal Master');
            
            // Update Firebase
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                currentTurn: gameState.currentTurn,
                history: gameState.history,
                stats: gameState.stats
            });
            
            // Clear previous state
            gameState.previousState = null;
        }

        function changeTurn() {
            if (!gameState.isMaster) return;
            
            const nextTurnIndex = parseInt(document.getElementById('next-turn-player').value);
            database.ref('games/' + gameState.gameCode).update({ currentTurn: nextTurnIndex });
            
            const playerName = gameState.players[nextTurnIndex].name;
            gameState.history.push(`‚è≠Ô∏è Turno cambiato a ${playerName}`);
            database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
        }

        function modifyHP(type) {
            if (!gameState.isMaster) return;
            
            const selectedOptions = document.getElementById('target-players').selectedOptions;
            const amount = parseInt(document.getElementById('hp-amount').value);
            const activatorIndex = parseInt(document.getElementById('damage-activator-select').value);
            
            if (!amount || amount <= 0) {
                alert('Inserisci un valore valido!');
                return;
            }
            
            if (selectedOptions.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            const playerIndices = Array.from(selectedOptions).map(opt => parseInt(opt.value));
            
            if (type === 'damage') {
                // USA applyResult PER ATTIVARE TUTTI GLI EFFETTI
                playerIndices.forEach(targetIndex => {
                    const result = {
                        shooterIndex: activatorIndex,
                        targetIndex: targetIndex,
                        damage: amount,
                        sum: amount, // Per consistenza
                        diceValues: [], // Nessun dado
                        specialEffect: 'Danno Manuale Master',
                        selfHeal: 0,
                        isPoker: false
                    };
                    
                    gameState.history.push(`üéØ [Master] ${gameState.players[activatorIndex].name} infligge ${amount} danni manuali a ${gameState.players[targetIndex].name}`);
                    applyResult(result);
                });
            } else {
                // CURE - funzionamento normale (non attiva effetti)
                playerIndices.forEach(playerIndex => {
                    const player = gameState.players[playerIndex];
                    player.hp += amount;
                    gameState.history.push(`üíö ${player.name} recupera ${amount} HP (Master)`);
                    animateHP(playerIndex, amount);
                    playSound('heal');
                });
                
                database.ref('games/' + gameState.gameCode).update({
                    players: gameState.players,
                    history: gameState.history
                });
            }
            
            // Clear input
            document.getElementById('hp-amount').value = '';
        }

        function revivePlayer() {
            if (!gameState.isMaster) return;
            
            const selectedOptions = document.getElementById('target-players').selectedOptions;
            
            if (selectedOptions.length === 0) {
                alert('Seleziona almeno un giocatore da rianimare!');
                return;
            }
            
            const playerIndices = Array.from(selectedOptions).map(opt => parseInt(opt.value));
            
            playerIndices.forEach(playerIndex => {
                const player = gameState.players[playerIndex];
                
                if (!player.isEliminated) {
                    return; // Skip non-eliminated players
                }
                
                player.isEliminated = false;
                player.hp = 20;
                
                animateHP(playerIndex, 20);
                gameState.history.push(`üîÑ ${player.name} √® stato rianimato con 20 HP`);
            });
            
            playSound('revive');
            screenFlash('revive');
            createParticles(window.innerWidth / 2, window.innerHeight / 2, 'revive');
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function endGame() {
            if (!gameState.isMaster) return;
            
            if (!confirm('Sei sicuro di voler terminare la partita?')) return;
            
            const sorted = [...gameState.players].sort((a, b) => b.hp - a.hp);
            const winner = sorted[0];
            
            gameState.history.push(`üèÅ Partita terminata. Vincitore: ${winner.name} con ${winner.hp} HP`);
            
            database.ref('games/' + gameState.gameCode).update({
                history: gameState.history,
                gameEnded: true,
                winner: winner.name
            });
            
            // Show winner notification to all players
            setTimeout(() => {
                const isYou = winner.name === gameState.playerName;
                showWinnerNotification(winner.name, isYou);
            }, 500);
        }

        function swapHP() {
            if (!gameState.isMaster) return;
            
            const player1Index = parseInt(document.getElementById('swap-player-1').value);
            const player2Index = parseInt(document.getElementById('swap-player-2').value);
            
            if (player1Index === player2Index) {
                alert('Seleziona due giocatori diversi!');
                return;
            }
            
            const player1 = gameState.players[player1Index];
            const player2 = gameState.players[player2Index];
            
            // Swap HP values
            const tempHP = player1.hp;
            player1.hp = player2.hp;
            player2.hp = tempHP;
            
            gameState.history.push(`üîÑ ${player1.name} e ${player2.name} hanno scambiato HP (${player2.hp} ‚Üî ${player1.hp})`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
            
            // Animate both players
            animateHP(player1Index, 0);
            animateHP(player2Index, 0);
        }

        function newGame() {
            if (!gameState.isMaster) return;
            
            if (!confirm('Vuoi iniziare una nuova partita? Gli HP e tutti gli effetti saranno resettati.')) return;
            
            // Use the initial HP that was set when the game was created
            const resetHP = gameState.initialHP || 70;
            
            // Reset all players - HP + TUTTI GLI EFFETTI
            gameState.players.forEach(player => {
                player.hp = resetHP;
                player.isEliminated = false;
                // Reset effetti individuali
                player.isImmortal = false;
                player.multiplier = 1;
                player.multiplierAppliedBy = null;
                player.skipTurn = false;
                player.customDiceCount = null;
                player.krakenMark = false;
                player.krakenMarkThreshold = 10;
                player.checkmateHP = null;
                player.damageToHeal = false;
                player.sunArmor = false;
                player.moonArmor = false;
                player.mareGuai = false;
                player.voloFenice = false;
                player.cactusAmari = false;
                player.catenaMaledetta = false;
                player.rifletteDanni = false;
                player.talismanRa = false;
                player.talismanRaValues = [];
                player.dadoAvvelenato = false;
                player.dadoAvvelenatotValues = [];
                player.interferenza = false;
                player.interferenzaPartner = null;
                player.cantoDelCigno = false;
                player.pattoDiavolo = false;
                player.pattoDiavoloUsed = false;
                player.tombaTutankhamon = false;
                player.reincarnazione = false;
                player.reincarnazioneUsed = false;
                player.boiaEsecutore = false;
                player.boiaEsecutoreTurns = 0;
                // Reset effetti temporanei
                player.temporaryEffects = {
                    immortal: false,
                    multiplier: false,
                    skipTurn: false,
                    customDice: false,
                    damageToHeal: false,
                    sunArmor: false,
                    moonArmor: false,
                    mareGuai: false,
                    voloFenice: false,
                    cactusAmari: false,
                    catenaMaledetta: false,
                    rifletteDanni: false,
                    talismanRa: false,
                    dadoAvvelenato: false
                };
            });
            
            // Reset TUTTI gli effetti globali
            gameState.globalEffects = {
                cessateFuoco: false,
                cessateFuocoActivator: null,
                pariPazzo: false,
                pariPazzoActivator: null,
                pioggiaAcida: false,
                pioggiaAcidaActivator: null,
                cannoneKarma: false,
                cannoneKarmaActivator: null,
                bambolaVoodoo: false,
                bambolaVoodooActivator: null,
                capsulaRigenerativa: false,
                capsulaRigenerativaActivator: null,
                saldiEstivi: false,
                saldiEstiviActivator: null,
                giocoPulito: false,
                giocoPulitoActivator: null,
                altaMarea: false,
                altaMareaActivator: null,
                zebratura: false,
                zebraturaActivator: null,
                boomerang: false,
                boomerangActivator: null,
                boomerangDamage: 0,
                armaturaSpecchio: false,
                armaturaSpecchioActivator: null,
                sabbieMobili: false,
                sabbieMobiliActivator: null
            };
            
            // Reset game state
            gameState.currentTurn = 0;
            gameState.direction = 'clockwise';
            gameState.history = ['üéÆ Nuova partita iniziata! Tutti gli effetti resettati.'];
            gameState.startTime = Date.now();
            gameState.stats = {}; // Reset statistiche
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                globalEffects: gameState.globalEffects,
                currentTurn: 0,
                direction: 'clockwise',
                history: gameState.history,
                startTime: gameState.startTime,
                gameEnded: false,
                winner: null,
                stats: gameState.stats
            });
            
            // Restart timer
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            startTimer();
        }
        
        function showQRModal() {
            if (!gameState.isMaster) return;
            
            const selectedIndex = parseInt(document.getElementById('qr-player-select').value);
            const selectedPlayer = gameState.players[selectedIndex];
            
            if (!selectedPlayer) {
                alert('Seleziona un giocatore!');
                return;
            }
            
            const modal = document.getElementById('qr-modal');
            const qrcodeContainer = document.getElementById('qrcode-modal');
            const gameCodeDisplay = document.getElementById('modal-game-code');
            
            // Clear previous QR code
            qrcodeContainer.innerHTML = '';
            
            // Generate new QR code with player name
            const gameUrl = window.location.origin + window.location.pathname + '?game=' + gameState.gameCode + '&player=' + encodeURIComponent(selectedPlayer.name);
            new QRCode(qrcodeContainer, {
                text: gameUrl,
                width: 256,
                height: 256,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
            
            // Display game code and player name
            gameCodeDisplay.textContent = gameState.gameCode + ' - ' + selectedPlayer.name;
            
            // Show modal
            modal.classList.add('show');
        }
        
        function closeQRModal() {
            const modal = document.getElementById('qr-modal');
            modal.classList.remove('show');
        }
        
        function toggleImmortality() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('immortal-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            // Toggle immortality for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.isImmortal = !player.isImmortal;
                
                // Mark as temporary effect
                if (!player.temporaryEffects) {
                    player.temporaryEffects = {};
                }
                player.temporaryEffects.immortal = player.isImmortal;
            });
            
            // Update Firebase
            database.ref('games/' + gameState.gameCode + '/players').set(gameState.players);
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].isImmortal ? 'attivata' : 'disattivata';
            gameState.history.push(`‚≠ê Immortalit√† ${status} per: ${playerNames} (temp)`);
            database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
        }
        
        function setMultiplier(multiplierValue) {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('multiplier-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            // Set multiplier for selected players
            const currentPlayerIndex = gameState.currentTurn;
            
            let alreadyHasMultiplier = [];
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                if (player.multiplier !== 1) {
                    alreadyHasMultiplier.push(player.name);
                }
                player.multiplier = multiplierValue;
                player.multiplierAppliedBy = currentPlayerIndex; // Salva chi ha applicato il moltiplicatore
                
                // Mark as temporary effect
                if (!player.temporaryEffects) {
                    player.temporaryEffects = {};
                }
                player.temporaryEffects.multiplier = true;
            });
            
            // Avvisa se alcuni giocatori avevano gi√† un moltiplicatore
            if (alreadyHasMultiplier.length > 0) {
                gameState.history.push(`‚ö†Ô∏è Moltiplicatore precedente sovrascritto per: ${alreadyHasMultiplier.join(', ')}`);
            }
            
            // Update Firebase
            database.ref('games/' + gameState.gameCode + '/players').set(gameState.players);
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const applierName = gameState.players[currentPlayerIndex].name;
            const multiplierText = multiplierValue === 0.5 ? '0.5 (met√† danni)' : '2 (danni doppi)';
            gameState.history.push(`‚ú® ${applierName} applica moltiplicatore x${multiplierText} a: ${playerNames} (fino al suo prossimo turno)`);
            database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
        }
        
        function removeMultiplier() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('multiplier-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            // Remove multiplier (set to 1) for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.multiplier = 1;
                player.multiplierAppliedBy = null;
                if (player.temporaryEffects) {
                    player.temporaryEffects.multiplier = false;
                }
            });
            
            // Update Firebase
            database.ref('games/' + gameState.gameCode + '/players').set(gameState.players);
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            gameState.history.push(`‚ùå Moltiplicatore rimosso per: ${playerNames}`);
            database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
        }
        
        function toggleSkipTurn() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('skip-turn-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            // Toggle skip turn for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.skipTurn = !player.skipTurn;
                
                // Mark as temporary effect
                if (!player.temporaryEffects) {
                    player.temporaryEffects = {};
                }
                player.temporaryEffects.skipTurn = player.skipTurn;
            });
            
            // Update Firebase
            database.ref('games/' + gameState.gameCode + '/players').set(gameState.players);
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].skipTurn ? 'attivato' : 'disattivato';
            gameState.history.push(`‚è≠Ô∏è Salta turno ${status} per: ${playerNames}`);
            database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
        }
        
        function setCustomDice() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('custom-dice-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            const diceValue = parseInt(document.getElementById('custom-dice-value').value);
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            if (!diceValue || diceValue < 1 || diceValue > 6) {
                alert('Inserisci un numero di dadi valido (1-6)!');
                return;
            }
            
            // Set custom dice for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.customDiceCount = diceValue;
                
                // Mark as temporary effect
                if (!player.temporaryEffects) {
                    player.temporaryEffects = {};
                }
                player.temporaryEffects.customDice = true;
            });
            
            // Update Firebase
            database.ref('games/' + gameState.gameCode + '/players').set(gameState.players);
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            gameState.history.push(`üé≤ Dadi personalizzati (${diceValue}) assegnati a: ${playerNames} (temp)`);
            database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
        }
        
        function removeCustomDice() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('custom-dice-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            // Remove custom dice for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.customDiceCount = null;
                if (player.temporaryEffects) {
                    player.temporaryEffects.customDice = false;
                }
            });
            
            // Update Firebase
            database.ref('games/' + gameState.gameCode + '/players').set(gameState.players);
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            gameState.history.push(`‚ùå Dadi personalizzati rimossi per: ${playerNames}`);
            database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
        }
        
        function resetTemporaryEffects(playerIndex) {
            const player = gameState.players[playerIndex];
            if (!player || !player.temporaryEffects) return;
            
            let resetMessage = [];
            
            // Reset immortality if temporary (only for the player who just played)
            if (player.temporaryEffects.immortal && player.isImmortal) {
                player.isImmortal = false;
                resetMessage.push('immortalit√†');
            }
            
            // Reset multipliers for ALL players if this player applied them
            // (moltiplicatori durano fino al turno del giocatore che li ha applicati)
            let multiplierResetPlayers = [];
            gameState.players.forEach((p, index) => {
                if (p.multiplierAppliedBy === playerIndex && p.multiplier !== 1) {
                    multiplierResetPlayers.push(p.name);
                    p.multiplier = 1;
                    p.multiplierAppliedBy = null;
                    if (p.temporaryEffects) {
                        p.temporaryEffects.multiplier = false;
                    }
                }
            });
            
            if (multiplierResetPlayers.length > 0) {
                gameState.history.push(`‚è±Ô∏è Moltiplicatori rimossi da: ${multiplierResetPlayers.join(', ')} (fine effetto di ${player.name})`);
            }
            
            // Reset skip turn if temporary (but only after it was skipped)
            // Skip turn will be handled separately in getNextActiveTurn
            
            // Reset custom dice if temporary (only for the player who just played)
            // ECCEZIONE: Non resettare se Patto Diavolo √® stato usato (2 dadi permanenti)
            if (player.temporaryEffects.customDice && player.customDiceCount) {
                if (!player.pattoDiavoloUsed) {
                    player.customDiceCount = null;
                    resetMessage.push('dadi personalizzati');
                }
                // Se pattoDiavoloUsed = true, mantieni customDiceCount = 2 per sempre
            }
            
            // Reset damage-to-heal if temporary
            if (player.temporaryEffects.damageToHeal && player.damageToHeal) {
                player.damageToHeal = false;
                resetMessage.push('conversione danni‚Üícure');
            }
            
            // Reset sun armor if temporary
            if (player.temporaryEffects.sunArmor && player.sunArmor) {
                player.sunArmor = false;
                resetMessage.push('armatura del sole');
            }
            
            // Reset moon armor if temporary
            if (player.temporaryEffects.moonArmor && player.moonArmor) {
                player.moonArmor = false;
                resetMessage.push('armatura della luna');
            }
            
            // Reset nuove meccaniche temporanee
            if (player.temporaryEffects.mareGuai && player.mareGuai) {
                player.mareGuai = false;
                resetMessage.push('mare di guai');
            }
            if (player.temporaryEffects.voloFenice && player.voloFenice) {
                player.voloFenice = false;
                resetMessage.push('volo della fenice');
            }
            if (player.temporaryEffects.cactusAmari && player.cactusAmari) {
                player.cactusAmari = false;
                resetMessage.push('cactus amari');
            }
            if (player.temporaryEffects.catenaMaledetta && player.catenaMaledetta) {
                player.catenaMaledetta = false;
                resetMessage.push('catena maledetta');
            }
            if (player.temporaryEffects.rifletteDanni && player.rifletteDanni) {
                player.rifletteDanni = false;
                resetMessage.push('rifletti danni');
            }
            if (player.temporaryEffects.talismanRa && player.talismanRa) {
                player.talismanRa = false;
                player.talismanRaValues = [];
                resetMessage.push('talismano di ra');
            }
            if (player.temporaryEffects.dadoAvvelenato && player.dadoAvvelenato) {
                player.dadoAvvelenato = false;
                player.dadoAvvelenatotValues = [];
                resetMessage.push('dado avvelenato');
            }
            if (player.interferenza) {
                player.interferenza = false;
                player.interferenzaPartner = null;
                resetMessage.push('interferenza');
            }
            
            // Reset effetti globali se questo giocatore √® l'attivatore
            let globalReset = [];
            const gfx = gameState.globalEffects;
            
            if (gfx.cessateFuocoActivator === playerIndex && gfx.cessateFuoco) {
                gfx.cessateFuoco = false;
                gfx.cessateFuocoActivator = null;
                globalReset.push('cessate il fuoco');
            }
            if (gfx.pariPazzoActivator === playerIndex && gfx.pariPazzo) {
                gfx.pariPazzo = false;
                gfx.pariPazzoActivator = null;
                globalReset.push('pari pazzo');
            }
            if (gfx.bambolaVoodooActivator === playerIndex && gfx.bambolaVoodoo) {
                gfx.bambolaVoodoo = false;
                gfx.bambolaVoodooActivator = null;
                globalReset.push('bambola voodoo');
            }
            if (gfx.cannoneKarmaActivator === playerIndex && gfx.cannoneKarma) {
                gfx.cannoneKarma = false;
                gfx.cannoneKarmaActivator = null;
                globalReset.push('cannone karma');
            }
            if (gfx.pioggiaAcidaActivator === playerIndex && gfx.pioggiaAcida) {
                gfx.pioggiaAcida = false;
                gfx.pioggiaAcidaActivator = null;
                globalReset.push('pioggia acida');
            }
            if (gfx.capsulaRigenerativaActivator === playerIndex && gfx.capsulaRigenerativa) {
                gfx.capsulaRigenerativa = false;
                gfx.capsulaRigenerativaActivator = null;
                globalReset.push('capsula rigenerativa');
            }
            if (gfx.saldiEstiviActivator === playerIndex && gfx.saldiEstivi) {
                gfx.saldiEstivi = false;
                gfx.saldiEstiviActivator = null;
                globalReset.push('saldi estivi');
            }
            if (gfx.giocoPulitoActivator === playerIndex && gfx.giocoPulito) {
                gfx.giocoPulito = false;
                gfx.giocoPulitoActivator = null;
                globalReset.push('gioco pulito');
            }
            if (gfx.altaMareaActivator === playerIndex && gfx.altaMarea) {
                gfx.altaMarea = false;
                gfx.altaMareaActivator = null;
                globalReset.push('alta marea');
            }
            if (gfx.zebraturaActivator === playerIndex && gfx.zebratura) {
                gfx.zebratura = false;
                gfx.zebraturaActivator = null;
                globalReset.push('zebratura');
            }
            if (gfx.boomerangActivator === playerIndex && gfx.boomerang) {
                if (gfx.boomerangDamage > 0) {
                    gameState.players.forEach((p, idx) => {
                        if (idx !== playerIndex && !p.isEliminated) {
                            p.hp = Math.max(0, p.hp - gfx.boomerangDamage);
                            if (p.hp === 0) p.isEliminated = true;
                        }
                    });
                    gameState.history.push(`ü™É Boomerang: ${gfx.boomerangDamage} danni inflitti a tutti!`);
                }
                gfx.boomerang = false;
                gfx.boomerangActivator = null;
                gfx.boomerangDamage = 0;
                globalReset.push('boomerang');
            }
            if (gfx.armaturaSpecchioActivator === playerIndex && gfx.armaturaSpecchio) {
                gfx.armaturaSpecchio = false;
                gfx.armaturaSpecchioActivator = null;
                globalReset.push('armatura specchio');
            }
            if (gfx.sabbieMobiliActivator === playerIndex && gfx.sabbieMobili) {
                gfx.sabbieMobili = false;
                gfx.sabbieMobiliActivator = null;
                globalReset.push('sabbie mobili');
            }
            
            if (globalReset.length > 0) {
                gameState.history.push(`‚è±Ô∏è Effetti globali terminati: ${globalReset.join(', ')}`);
            }
            
            // Decrementa turni Boia Esecutore
            if (player.boiaEsecutore && player.boiaEsecutoreTurns > 0) {
                player.boiaEsecutoreTurns--;
                if (player.boiaEsecutoreTurns === 0) {
                    player.boiaEsecutore = false;
                    gameState.history.push(`ü™ì Boia Esecutore terminato per ${player.name}`);
                }
            }
            
            // Clear temporary flags for the player who just played
            player.temporaryEffects = {
                immortal: false,
                multiplier: false,
                skipTurn: player.temporaryEffects.skipTurn,
                customDice: false,
                damageToHeal: false,
                sunArmor: false,
                moonArmor: false,
                mareGuai: false,
                voloFenice: false,
                cactusAmari: false,
                catenaMaledetta: false,
                rifletteDanni: false,
                talismanRa: false,
                dadoAvvelenato: false
            };
            
            // Add history message if something was reset for this player
            if (resetMessage.length > 0) {
                gameState.history.push(`‚è±Ô∏è ${player.name}: reset ${resetMessage.join(', ')}`);
            }
        }
        
        function toggleKrakenMark() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('kraken-mark-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            // Toggle kraken mark for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.krakenMark = !player.krakenMark;
            });
            
            // Update Firebase
            database.ref('games/' + gameState.gameCode + '/players').set(gameState.players);
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].krakenMark ? 'applicato' : 'rimosso';
            gameState.history.push(`üêô Marchio del Kraken ${status} a: ${playerNames}`);
            database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
        }
        
        function setCheckmate() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('checkmate-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            const checkmateValue = parseInt(document.getElementById('checkmate-value').value);
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            if (!checkmateValue || checkmateValue < 1 || checkmateValue > 100) {
                alert('Inserisci un valore HP valido (1-100)!');
                return;
            }
            
            // Set checkmate for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.checkmateHP = checkmateValue;
            });
            
            // Update Firebase
            database.ref('games/' + gameState.gameCode + '/players').set(gameState.players);
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            gameState.history.push(`‚ôüÔ∏è Scacco Matto (${checkmateValue} HP) applicato a: ${playerNames}`);
            database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
        }
        
        function removeCheckmate() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('checkmate-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            // Remove checkmate for selected players
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.checkmateHP = null;
            });
            
            // Update Firebase
            database.ref('games/' + gameState.gameCode + '/players').set(gameState.players);
            
            // Add to history
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            gameState.history.push(`‚ùå Scacco Matto rimosso da: ${playerNames}`);
            database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
        }
        
        function toggleDamageToHeal() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('damage-to-heal-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.damageToHeal = !player.damageToHeal;
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.damageToHeal = player.damageToHeal;
            });
            database.ref('games/' + gameState.gameCode + '/players').set(gameState.players);
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].damageToHeal ? 'attivata' : 'disattivata';
            gameState.history.push(`üí´ Conversione Danni‚ÜíCure ${status} per: ${playerNames} (temp)`);
            database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
        }
        
        function toggleSunArmor() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('sun-armor-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.sunArmor = !player.sunArmor;
                // CONFLITTO: Se attivo Sole, disattivo Luna
                if (player.sunArmor && player.moonArmor) {
                    player.moonArmor = false;
                    if (player.temporaryEffects) player.temporaryEffects.moonArmor = false;
                    gameState.history.push(`‚ö†Ô∏è Armatura della Luna disattivata per ${player.name} (conflitto con Armatura del Sole)`);
                }
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.sunArmor = player.sunArmor;
            });
            database.ref('games/' + gameState.gameCode + '/players').set(gameState.players);
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].sunArmor ? 'indossata' : 'rimossa';
            gameState.history.push(`‚òÄÔ∏è Armatura del Sole ${status} da: ${playerNames} (temp)`);
            database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
        }
        
        function toggleMoonArmor() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('moon-armor-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.moonArmor = !player.moonArmor;
                // CONFLITTO: Se attivo Luna, disattivo Sole
                if (player.moonArmor && player.sunArmor) {
                    player.sunArmor = false;
                    if (player.temporaryEffects) player.temporaryEffects.sunArmor = false;
                    gameState.history.push(`‚ö†Ô∏è Armatura del Sole disattivata per ${player.name} (conflitto con Armatura della Luna)`);
                }
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.moonArmor = player.moonArmor;
            });
            database.ref('games/' + gameState.gameCode + '/players').set(gameState.players);
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].moonArmor ? 'indossata' : 'rimossa';
            gameState.history.push(`üåô Armatura della Luna ${status} da: ${playerNames} (temp)`);
            database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
        }
    
        
        // ========== FUNZIONI CALCOLATRICE E STRUMENTI ==========
        
        function calculateExpression() {
            const input = document.getElementById('calc-input').value.trim();
            const resultDiv = document.getElementById('calc-result');
            
            if (!input) {
                alert('Inserisci un\'espressione da calcolare!');
                return;
            }
            
            try {
                const cleanInput = input.replace(/\s+/g, '');
                if (!/^[\d+\-*/().]+$/.test(cleanInput)) {
                    throw new Error('Caratteri non validi nell\'espressione');
                }
                
                const numbers = cleanInput.split(/[+\-*/()]/).filter(n => n !== '');
                if (numbers.length > 20) {
                    throw new Error('Troppi numeri! Massimo 20 numeri consentiti');
                }
                
                const result = eval(cleanInput);
                resultDiv.style.display = 'block';
                resultDiv.textContent = `Risultato: ${result}`;
                
                if (gameState.isMaster) {
                    gameState.history.push(`üßÆ Calcolo: ${input} = ${result}`);
                    database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
                }
            } catch (error) {
                resultDiv.style.display = 'block';
                resultDiv.textContent = `Errore: ${error.message}`;
                resultDiv.style.color = '#ff0000';
                setTimeout(() => {
                    resultDiv.style.color = '#00ffff';
                }, 2000);
            }
        }

        function clearCalculator() {
            document.getElementById('calc-input').value = '';
            document.getElementById('calc-result').style.display = 'none';
        }

        function calculateTargetOnly() {
            const dice1 = parseInt(document.getElementById('tcalc-dice-0').value);
            const dice2 = parseInt(document.getElementById('tcalc-dice-1').value);
            const dice3 = parseInt(document.getElementById('tcalc-dice-2').value);
            const selectedDirection = document.getElementById('target-calc-direction').value;
            const resultDiv = document.getElementById('target-calc-result');
            
            const diceValues = [];
            if (dice1 >= 1 && dice1 <= 6) diceValues.push(dice1);
            if (dice2 >= 1 && dice2 <= 6) diceValues.push(dice2);
            if (dice3 >= 1 && dice3 <= 6) diceValues.push(dice3);
            
            if (diceValues.length === 0) {
                alert('Inserisci almeno un dado valido (1-6)!');
                return;
            }
            
            const sum = diceValues.reduce((a, b) => a + b, 0);
            const targetInfo = findTargetInfo(sum, gameState.currentTurn, selectedDirection);
            
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = `
                <div style="font-size: 1.1em; margin-bottom: 8px;">
                    Dadi: ${diceValues.join(', ')} = <strong>${sum}</strong>
                </div>
                <div style="color: #00ff88; font-size: 1.2em;">
                    üéØ Bersaglio: <strong>${targetInfo.targetName}</strong>
                </div>
                <div style="font-size: 0.9em; margin-top: 8px; opacity: 0.8;">
                    (${targetInfo.position}¬∞ giocatore attivo in senso ${selectedDirection === 'clockwise' ? 'orario' : 'antiorario'})
                </div>
            `;
            
            if (gameState.isMaster) {
                const directionText = selectedDirection === 'clockwise' ? 'orario' : 'antiorario';
                gameState.history.push(`üéØ Calcolo bersaglio (${directionText}): ${diceValues.join(',')} = ${sum} ‚Üí ${targetInfo.targetName}`);
                database.ref('games/' + gameState.gameCode + '/history').set(gameState.history);
            }
        }

        function findTargetInfo(sum, shooterIndex, direction = null) {
            const activePlayers = gameState.players
                .map((p, i) => ({ player: p, index: i }))
                .filter(({ player, index }) => !player.isEliminated && index !== shooterIndex);

            if (activePlayers.length === 0) return { targetName: 'Nessuno', position: 0 };

            let count = sum % activePlayers.length;
            if (count === 0) count = activePlayers.length;

            // Usa la direzione passata come parametro, altrimenti usa quella di gameState
            const actualDirection = direction || gameState.direction;
            
            let sorted;
            if (actualDirection === 'clockwise') {
                sorted = [...activePlayers].sort((a, b) => {
                    const aAfter = a.index > shooterIndex ? a.index : a.index + 1000;
                    const bAfter = b.index > shooterIndex ? b.index : b.index + 1000;
                    return aAfter - bAfter;
                });
            } else {
                sorted = [...activePlayers].sort((a, b) => {
                    const aBefore = a.index < shooterIndex ? a.index : a.index - 1000;
                    const bBefore = b.index < shooterIndex ? b.index : b.index - 1000;
                    return bBefore - aBefore;
                });
            }

            const targetPos = (count - 1) % sorted.length;
            const target = sorted[targetPos];

            return {
                targetName: target.player.name,
                position: count,
                targetIndex: target.index
            };
        }

        // ========== MECCANICHE GLOBALI ==========
        
        function toggleCessateFuoco() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('cessate-fuoco-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            
            gameState.globalEffects.cessateFuoco = !gameState.globalEffects.cessateFuoco;
            
            if (gameState.globalEffects.cessateFuoco) {
                // Disattiva Zebratura se attiva (conflitto)
                if (gameState.globalEffects.zebratura) {
                    gameState.globalEffects.zebratura = false;
                    gameState.globalEffects.zebraturaActivator = null;
                    gameState.history.push(`‚ö†Ô∏è Zebratura disattivata (conflitto con Cessate il Fuoco)`);
                }
                gameState.globalEffects.cessateFuocoActivator = activatorIndex;
                gameState.history.push(`üïäÔ∏è Cessate il Fuoco attivato per 1 turno completo! Attivatore: ${gameState.players[activatorIndex].name}`);
            } else {
                gameState.globalEffects.cessateFuocoActivator = null;
                gameState.history.push(`üïäÔ∏è Cessate il Fuoco disattivato`);
            }
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function togglePariPazzo() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('pari-pazzo-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            gameState.globalEffects.pariPazzo = !gameState.globalEffects.pariPazzo;
            
            if (gameState.globalEffects.pariPazzo) {
                gameState.globalEffects.pariPazzoActivator = activatorIndex;
                gameState.history.push(`üé≤ Di Pari Pazzo attivato per 1 turno completo! Attivatore: ${gameState.players[activatorIndex].name}`);
            } else {
                gameState.globalEffects.pariPazzoActivator = null;
                gameState.history.push(`üé≤ Di Pari Pazzo disattivato`);
            }
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function toggleBambolaVoodoo() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('bambola-voodoo-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            gameState.globalEffects.bambolaVoodoo = !gameState.globalEffects.bambolaVoodoo;
            
            if (gameState.globalEffects.bambolaVoodoo) {
                gameState.globalEffects.bambolaVoodooActivator = activatorIndex;
                gameState.history.push(`ü™Ü Bambola Voodoo attivata per 1 turno completo (escluso attivatore)! Attivatore: ${gameState.players[currentPlayerIndex].name}`);
            } else {
                gameState.globalEffects.bambolaVoodooActivator = null;
                gameState.history.push(`ü™Ü Bambola Voodoo disattivata`);
            }
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function toggleCannoneKarma() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('cannone-karma-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            gameState.globalEffects.cannoneKarma = !gameState.globalEffects.cannoneKarma;
            
            if (gameState.globalEffects.cannoneKarma) {
                gameState.globalEffects.cannoneKarmaActivator = activatorIndex;
                gameState.history.push(`üí• Cannone del Karma attivato per 1 turno completo (escluso attivatore)! Attivatore: ${gameState.players[currentPlayerIndex].name}`);
            } else {
                gameState.globalEffects.cannoneKarmaActivator = null;
                gameState.history.push(`üí• Cannone del Karma disattivato`);
            }
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function togglePioggiaAcida() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('pioggia-acida-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            gameState.globalEffects.pioggiaAcida = !gameState.globalEffects.pioggiaAcida;
            
            if (gameState.globalEffects.pioggiaAcida) {
                gameState.globalEffects.pioggiaAcidaActivator = activatorIndex;
                gameState.history.push(`‚òî Pioggia Acida attivata per 1 turno completo (escluso attivatore)! Attivatore: ${gameState.players[currentPlayerIndex].name}`);
            } else {
                gameState.globalEffects.pioggiaAcidaActivator = null;
                gameState.history.push(`‚òî Pioggia Acida disattivata`);
            }
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function toggleCapsulaRigenerativa() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('capsula-rigenerativa-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            gameState.globalEffects.capsulaRigenerativa = !gameState.globalEffects.capsulaRigenerativa;
            
            if (gameState.globalEffects.capsulaRigenerativa) {
                // Disattiva Zebratura se attiva (conflitto)
                if (gameState.globalEffects.zebratura) {
                    gameState.globalEffects.zebratura = false;
                    gameState.globalEffects.zebraturaActivator = null;
                    gameState.history.push(`‚ö†Ô∏è Zebratura disattivata (conflitto con Capsula Rigenerativa)`);
                }
                gameState.globalEffects.capsulaRigenerativaActivator = activatorIndex;
                gameState.history.push(`üíä Capsula Rigenerativa attivata per 1 turno completo (incluso attivatore)! Attivatore: ${gameState.players[activatorIndex].name}`);
            } else {
                gameState.globalEffects.capsulaRigenerativaActivator = null;
                gameState.history.push(`üíä Capsula Rigenerativa disattivata`);
            }
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function toggleSaldiEstivi() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('saldi-estivi-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            gameState.globalEffects.saldiEstivi = !gameState.globalEffects.saldiEstivi;
            
            if (gameState.globalEffects.saldiEstivi) {
                gameState.globalEffects.saldiEstiviActivator = activatorIndex;
                gameState.history.push(`üèñÔ∏è Saldi Estivi attivati per 1 turno completo! Tutti i danni dimezzati. Attivatore: ${gameState.players[currentPlayerIndex].name}`);
            } else {
                gameState.globalEffects.saldiEstiviActivator = null;
                gameState.history.push(`üèñÔ∏è Saldi Estivi disattivati`);
            }
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        function toggleGiocoPulito() {
            if (!gameState.isMaster) return;
            
            const activatorSelect = document.getElementById('gioco-pulito-activator');
            const activatorIndex = parseInt(activatorSelect.value);
            
            if (isNaN(activatorIndex)) {
                alert('Seleziona prima un attivatore!');
                return;
            }
            gameState.globalEffects.giocoPulito = !gameState.globalEffects.giocoPulito;
            
            if (gameState.globalEffects.giocoPulito) {
                gameState.globalEffects.giocoPulitoActivator = activatorIndex;
                gameState.history.push(`‚öñÔ∏è Gioco Pulito attivato per 1 turno completo! Coppie/tris annullati, effetti disattivati. Attivatore: ${gameState.players[currentPlayerIndex].name}`);
                
                // Disattiva tutti gli altri effetti (tranne Gioco Pulito stesso)
                gameState.globalEffects.cessateFuoco = false;
                gameState.globalEffects.pariPazzo = false;
                gameState.globalEffects.bambolaVoodoo = false;
                gameState.globalEffects.cannoneKarma = false;
                gameState.globalEffects.pioggiaAcida = false;
                gameState.globalEffects.capsulaRigenerativa = false;
                gameState.globalEffects.saldiEstivi = false;
            } else {
                gameState.globalEffects.giocoPulitoActivator = null;
                gameState.history.push(`‚öñÔ∏è Gioco Pulito disattivato`);
            }
            
            database.ref('games/' + gameState.gameCode).update({
                globalEffects: gameState.globalEffects,
                history: gameState.history
            });
        }

        // ========== MECCANICHE IMMEDIATE ==========

        function activateTrottolaImpazzita() {
            if (!gameState.isMaster) return;
            
            if (!confirm('Attivare Trottola Impazzita? Tutti gli HP saranno trasferiti al giocatore successivo!')) return;
            
            const activePlayers = gameState.players.filter(p => !p.isEliminated);
            if (activePlayers.length < 2) {
                alert('Servono almeno 2 giocatori attivi!');
                return;
            }
            
            // Salva tutti gli HP attuali
            const hpValues = activePlayers.map(p => p.hp);
            
            // Trasferisci gli HP al giocatore successivo (in senso orario)
            activePlayers.forEach((player, index) => {
                const nextIndex = (index + 1) % activePlayers.length;
                player.hp = hpValues[nextIndex];
            });
            
            gameState.history.push(`üåÄ Trottola Impazzita! Tutti gli HP trasferiti al giocatore successivo`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
            
            // Anima tutti i giocatori
            activePlayers.forEach((player, index) => {
                const playerIndex = gameState.players.findIndex(p => p.name === player.name);
                animateHP(playerIndex, 0);
            });
        }

        function activateTartarugaLepre() {
            if (!gameState.isMaster) return;
            
            const activePlayers = gameState.players.filter(p => !p.isEliminated);
            if (activePlayers.length < 2) {
                alert('Servono almeno 2 giocatori attivi!');
                return;
            }
            
            // Trova il giocatore con pi√π HP
            let maxHP = 0;
            let maxHPPlayer = null;
            activePlayers.forEach(p => {
                if (p.hp > maxHP) {
                    maxHP = p.hp;
                    maxHPPlayer = p;
                }
            });
            
            if (!maxHPPlayer) return;
            
            // Calcola HP da perdere (met√†)
            const hpLost = Math.floor(maxHPPlayer.hp / 2);
            maxHPPlayer.hp -= hpLost;
            
            // Distribuisci equamente agli altri
            const otherPlayers = activePlayers.filter(p => p.name !== maxHPPlayer.name);
            const hpPerPlayer = Math.ceil(hpLost / otherPlayers.length);
            
            otherPlayers.forEach(p => {
                p.hp += hpPerPlayer;
            });
            
            gameState.history.push(`üê¢üê∞ Tartaruga e Lepre! ${maxHPPlayer.name} perde ${hpLost} HP, distribuiti agli altri (+${hpPerPlayer} HP ciascuno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
            
            // Anima tutti i giocatori
            activePlayers.forEach(player => {
                const playerIndex = gameState.players.findIndex(p => p.name === player.name);
                animateHP(playerIndex, 0);
            });
        }

        function activateYinYang() {
            if (!gameState.isMaster) return;
            
            if (!confirm('Attivare Yin e Yang? Tutti i giocatori avranno met√† HP iniziali!')) return;
            
            const activePlayers = gameState.players.filter(p => !p.isEliminated);
            const halfInitialHP = Math.ceil(gameState.initialHP / 2);
            
            activePlayers.forEach(p => {
                p.hp = halfInitialHP;
            });
            
            gameState.history.push(`‚òØÔ∏è Yin e Yang! Tutti i giocatori impostati a ${halfInitialHP} HP`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
            
            // Anima tutti i giocatori
            activePlayers.forEach(player => {
                const playerIndex = gameState.players.findIndex(p => p.name === player.name);
                animateHP(playerIndex, 0);
            });
        }

        function activateBilanciaFato() {
            if (!gameState.isMaster) return;
            
            if (!confirm('Attivare Bilancia del Fato? La differenza tra HP iniziali e attuali diventer√† il nuovo valore HP!')) return;
            
            const activePlayers = gameState.players.filter(p => !p.isEliminated);
            
            activePlayers.forEach(p => {
                const difference = Math.abs(gameState.initialHP - p.hp);
                p.hp = difference;
                
                // Previeni HP a 0 (minimo 1)
                if (p.hp === 0) p.hp = 1;
            });
            
            gameState.history.push(`‚öñÔ∏è Bilancia del Fato! HP = |HP iniziali - HP attuali|`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
            
            // Anima tutti i giocatori
            activePlayers.forEach(player => {
                const playerIndex = gameState.players.findIndex(p => p.name === player.name);
                animateHP(playerIndex, 0);
            });
        }

        function activateUguaglianza() {
            if (!gameState.isMaster) return;
            
            const divisor = parseInt(document.getElementById('uguaglianza-divisor').value);
            
            if (!divisor || divisor < 1 || divisor > 18) {
                alert('Inserisci un divisore valido (1-18)!');
                return;
            }
            
            const activePlayers = gameState.players.filter(p => !p.isEliminated);
            
            // Somma tutti gli HP
            const totalHP = activePlayers.reduce((sum, p) => sum + p.hp, 0);
            
            // Dividi e distribuisci
            const hpPerPlayer = Math.ceil(totalHP / divisor);
            
            activePlayers.forEach(p => {
                p.hp = hpPerPlayer;
            });
            
            gameState.history.push(`‚öñÔ∏è Uguaglianza! HP totali (${totalHP}) √∑ ${divisor} = ${hpPerPlayer} HP per tutti`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
            
            // Anima tutti i giocatori
            activePlayers.forEach(player => {
                const playerIndex = gameState.players.findIndex(p => p.name === player.name);
                animateHP(playerIndex, 0);
            });
        }

        function activateGeyserFuoco() {
            if (!gameState.isMaster) return;
            
            const baseDamage = parseInt(document.getElementById('geyser-damage').value);
            
            if (!baseDamage || baseDamage < 1 || baseDamage > 100) {
                alert('Inserisci un danno base valido (1-100)!');
                return;
            }
            
            const currentPlayerIndex = gameState.currentTurn;
            const currentPlayer = gameState.players[currentPlayerIndex];
            
            if (!confirm(`Attivare Geyser di Fuoco con danno base ${baseDamage}? ${currentPlayer.name} sar√† immune.`)) return;
            
            // Applica danni progressivi a tutti tranne l'attivatore
            let multiplier = 1;
            const startIndex = (currentPlayerIndex + 1) % gameState.players.length;
            
            for (let i = 0; i < gameState.players.length - 1; i++) {
                const playerIndex = (startIndex + i) % gameState.players.length;
                const player = gameState.players[playerIndex];
                
                if (player.isEliminated) continue;
                
                const damage = baseDamage * multiplier;
                player.hp = Math.max(0, player.hp - damage);
                
                if (player.hp === 0) {
                    player.isEliminated = true;
                    gameState.history.push(`üî• Geyser di Fuoco: ${player.name} eliminato (${damage} danni)`);
                } else {
                    gameState.history.push(`üî• Geyser di Fuoco: ${player.name} subisce ${damage} danni`);
                }
                
                animateHP(playerIndex, -damage);
                multiplier++;
            }
            
            gameState.history.push(`üî• Geyser di Fuoco attivato! Danno base: ${baseDamage}. Attivatore immune: ${currentPlayer.name}`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

// Continua nel prossimo file...
        // ========== MECCANICHE SU SINGOLI GIOCATORI ==========

        function toggleMareGuai() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('mare-guai-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            const currentPlayerIndex = gameState.currentTurn;
            
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.mareGuai = !player.mareGuai;
                
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.mareGuai = player.mareGuai;
            });
            
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].mareGuai ? 'attivato' : 'disattivato';
            gameState.history.push(`üåä Un Mare di Guai ${status} per: ${playerNames} (temp - 1 turno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function setTalismanRa() {
            if (!gameState.isMaster) return;
            
            const playerIndex = parseInt(document.getElementById('talismano-ra-player').value);
            const val1 = parseInt(document.getElementById('talismano-ra-val1').value);
            const val2 = parseInt(document.getElementById('talismano-ra-val2').value);
            
            if (isNaN(playerIndex)) {
                alert('Seleziona un giocatore!');
                return;
            }
            
            if (!val1 || val1 < 1 || val1 > 6 || !val2 || val2 < 1 || val2 > 6) {
                alert('Inserisci valori validi per i dadi (1-6)!');
                return;
            }
            
            const player = gameState.players[playerIndex];
            player.talismanRa = true;
            player.talismanRaValues = [val1, val2];
            
            if (!player.temporaryEffects) player.temporaryEffects = {};
            player.temporaryEffects.talismanRa = true;
            
            gameState.history.push(`üåû Talismano di Ra attivato per ${player.name}! Valori: ${val1}, ${val2} (temp - 1 turno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function removeTalismanRa() {
            if (!gameState.isMaster) return;
            
            const playerIndex = parseInt(document.getElementById('talismano-ra-player').value);
            
            if (isNaN(playerIndex)) {
                alert('Seleziona un giocatore!');
                return;
            }
            
            const player = gameState.players[playerIndex];
            player.talismanRa = false;
            player.talismanRaValues = [];
            
            if (player.temporaryEffects) player.temporaryEffects.talismanRa = false;
            
            gameState.history.push(`‚ùå Talismano di Ra rimosso da ${player.name}`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function setDadoAvvelenato() {
            if (!gameState.isMaster) return;
            
            const playerIndex = parseInt(document.getElementById('dado-avvelenato-player').value);
            const val1 = parseInt(document.getElementById('dado-avvelenato-val1').value);
            const val2 = parseInt(document.getElementById('dado-avvelenato-val2').value);
            
            if (isNaN(playerIndex)) {
                alert('Seleziona un giocatore!');
                return;
            }
            
            if (!val1 || val1 < 1 || val1 > 6 || !val2 || val2 < 1 || val2 > 6) {
                alert('Inserisci valori validi per i dadi (1-6)!');
                return;
            }
            
            const player = gameState.players[playerIndex];
            player.dadoAvvelenato = true;
            player.dadoAvvelenatotValues = [val1, val2];
            
            if (!player.temporaryEffects) player.temporaryEffects = {};
            player.temporaryEffects.dadoAvvelenato = true;
            
            gameState.history.push(`‚ò†Ô∏è Dado Avvelenato attivato per ${player.name}! Valori: ${val1}, ${val2} (temp - 1 turno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function removeDadoAvvelenato() {
            if (!gameState.isMaster) return;
            
            const playerIndex = parseInt(document.getElementById('dado-avvelenato-player').value);
            
            if (isNaN(playerIndex)) {
                alert('Seleziona un giocatore!');
                return;
            }
            
            const player = gameState.players[playerIndex];
            player.dadoAvvelenato = false;
            player.dadoAvvelenatotValues = [];
            
            if (player.temporaryEffects) player.temporaryEffects.dadoAvvelenato = false;
            
            gameState.history.push(`‚ùå Dado Avvelenato rimosso da ${player.name}`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function setInterferenza() {
            if (!gameState.isMaster) return;
            
            const player1Index = parseInt(document.getElementById('interferenza-player1').value);
            const player2Index = parseInt(document.getElementById('interferenza-player2').value);
            
            if (isNaN(player1Index) || isNaN(player2Index)) {
                alert('Seleziona entrambi i giocatori!');
                return;
            }
            
            if (player1Index === player2Index) {
                alert('Seleziona due giocatori diversi!');
                return;
            }
            
            const player1 = gameState.players[player1Index];
            const player2 = gameState.players[player2Index];
            
            player1.interferenza = true;
            player1.interferenzaPartner = player2Index;
            
            gameState.history.push(`üîÄ Interferenza attivata! ${player1.name} trasferisce danni a ${player2.name} (temp - 1 turno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function removeInterferenza() {
            if (!gameState.isMaster) return;
            
            const player1Index = parseInt(document.getElementById('interferenza-player1').value);
            
            if (isNaN(player1Index)) {
                alert('Seleziona il giocatore!');
                return;
            }
            
            const player1 = gameState.players[player1Index];
            player1.interferenza = false;
            player1.interferenzaPartner = null;
            
            gameState.history.push(`‚ùå Interferenza rimossa da ${player1.name}`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function toggleVoloFenice() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('volo-fenice-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.voloFenice = !player.voloFenice;
                
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.voloFenice = player.voloFenice;
            });
            
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].voloFenice ? 'attivato' : 'disattivato';
            gameState.history.push(`ü¶Ö Volo della Fenice ${status} per: ${playerNames} (temp - 1 turno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function toggleCactusAmari() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('cactus-amari-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.cactusAmari = !player.cactusAmari;
                
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.cactusAmari = player.cactusAmari;
            });
            
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].cactusAmari ? 'attivato' : 'disattivato';
            gameState.history.push(`üåµ Cactus Amari ${status} per: ${playerNames} (temp - 1 turno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function toggleCatenaMaledetta() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('catena-maledetta-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.catenaMaledetta = !player.catenaMaledetta;
                
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.catenaMaledetta = player.catenaMaledetta;
            });
            
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].catenaMaledetta ? 'attivata' : 'disattivata';
            gameState.history.push(`‚õìÔ∏è Catena Maledetta ${status} per: ${playerNames} (temp - 1 turno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

        function toggleRiflettiDanni() {
            if (!gameState.isMaster) return;
            
            const select = document.getElementById('rifletti-danni-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            
            if (selectedIndices.length === 0) {
                alert('Seleziona almeno un giocatore!');
                return;
            }
            
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.rifletteDanni = !player.rifletteDanni;
                
                if (!player.temporaryEffects) player.temporaryEffects = {};
                player.temporaryEffects.rifletteDanni = player.rifletteDanni;
            });
            
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].rifletteDanni ? 'attivato' : 'disattivato';
            gameState.history.push(`üõ°Ô∏è Rifletti Danni ${status} per: ${playerNames} (temp - 1 turno)`);
            
            database.ref('games/' + gameState.gameCode).update({
                players: gameState.players,
                history: gameState.history
            });
        }

// Continua...

        
        function setAltaMarea() {
            if (!gameState.isMaster) return;
            const playerIndex = parseInt(document.getElementById('alta-marea-player').value);
            if (isNaN(playerIndex)) { alert('Seleziona un giocatore!'); return; }
            gameState.globalEffects.altaMarea = true;
            gameState.globalEffects.altaMareaActivator = playerIndex;
            gameState.history.push(`üåä Alta Marea attivata! Attivatore: ${gameState.players[playerIndex].name} (fino al suo prossimo turno)`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function removeAltaMarea() {
            if (!gameState.isMaster) return;
            gameState.globalEffects.altaMarea = false;
            gameState.globalEffects.altaMareaActivator = null;
            gameState.history.push(`‚ùå Alta Marea rimossa`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function setZebratura() {
            if (!gameState.isMaster) return;
            const playerIndex = parseInt(document.getElementById('zebratura-player').value);
            if (isNaN(playerIndex)) { alert('Seleziona un giocatore!'); return; }
            // Disattiva Capsula Rigenerativa se attiva (conflitto)
            if (gameState.globalEffects.capsulaRigenerativa) {
                gameState.globalEffects.capsulaRigenerativa = false;
                gameState.globalEffects.capsulaRigenerativaActivator = null;
                gameState.history.push(`‚ö†Ô∏è Capsula Rigenerativa disattivata (conflitto con Zebratura)`);
            }
            // Disattiva Cessate Fuoco se attivo (conflitto)
            if (gameState.globalEffects.cessateFuoco) {
                gameState.globalEffects.cessateFuoco = false;
                gameState.globalEffects.cessateFuocoActivator = null;
                gameState.history.push(`‚ö†Ô∏è Cessate il Fuoco disattivato (conflitto con Zebratura)`);
            }
            gameState.globalEffects.zebratura = true;
            gameState.globalEffects.zebraturaActivator = playerIndex;
            gameState.history.push(`ü¶ì Zebratura attivata! Attivatore: ${gameState.players[playerIndex].name} (fino al suo prossimo turno)`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function removeZebratura() {
            if (!gameState.isMaster) return;
            gameState.globalEffects.zebratura = false;
            gameState.globalEffects.zebraturaActivator = null;
            gameState.history.push(`‚ùå Zebratura rimossa`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function setBoomerang() {
            if (!gameState.isMaster) return;
            const playerIndex = parseInt(document.getElementById('boomerang-player').value);
            if (isNaN(playerIndex)) { alert('Seleziona un giocatore!'); return; }
            // Disattiva Armatura Specchio se attiva (conflitto)
            if (gameState.globalEffects.armaturaSpecchio) {
                gameState.globalEffects.armaturaSpecchio = false;
                gameState.globalEffects.armaturaSpecchioActivator = null;
                gameState.history.push(`‚ö†Ô∏è Armatura Specchio disattivata (conflitto con Boomerang)`);
            }
            gameState.globalEffects.boomerang = true;
            gameState.globalEffects.boomerangActivator = playerIndex;
            gameState.globalEffects.boomerangDamage = 0;
            gameState.history.push(`ü™É Boomerang attivato! ${gameState.players[playerIndex].name} non subisce danni (fino al suo prossimo turno)`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function removeBoomerang() {
            if (!gameState.isMaster) return;
            gameState.globalEffects.boomerang = false;
            gameState.globalEffects.boomerangActivator = null;
            gameState.globalEffects.boomerangDamage = 0;
            gameState.history.push(`‚ùå Boomerang rimosso`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function setArmaturaSpecchio() {
            if (!gameState.isMaster) return;
            const playerIndex = parseInt(document.getElementById('armatura-specchio-player').value);
            if (isNaN(playerIndex)) { alert('Seleziona un giocatore!'); return; }
            // Disattiva Boomerang se attivo (conflitto)
            if (gameState.globalEffects.boomerang) {
                gameState.globalEffects.boomerang = false;
                gameState.globalEffects.boomerangActivator = null;
                gameState.globalEffects.boomerangDamage = 0;
                gameState.history.push(`‚ö†Ô∏è Boomerang disattivato (conflitto con Armatura Specchio)`);
            }
            gameState.globalEffects.armaturaSpecchio = true;
            gameState.globalEffects.armaturaSpecchioActivator = playerIndex;
            gameState.history.push(`ü™û Armatura a Specchio attivata! ${gameState.players[playerIndex].name} distribuisce danni (fino al suo prossimo turno)`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function removeArmaturaSpecchio() {
            if (!gameState.isMaster) return;
            gameState.globalEffects.armaturaSpecchio = false;
            gameState.globalEffects.armaturaSpecchioActivator = null;
            gameState.history.push(`‚ùå Armatura a Specchio rimossa`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function setSabbieMobili() {
            if (!gameState.isMaster) return;
            const playerIndex = parseInt(document.getElementById('sabbie-mobili-player').value);
            if (isNaN(playerIndex)) { alert('Seleziona un giocatore!'); return; }
            gameState.globalEffects.sabbieMobili = true;
            gameState.globalEffects.sabbieMobiliActivator = playerIndex;
            gameState.history.push(`‚è≥ Sabbie Mobili attivate! (fino al prossimo turno di ${gameState.players[playerIndex].name})`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function removeSabbieMobili() {
            if (!gameState.isMaster) return;
            gameState.globalEffects.sabbieMobili = false;
            gameState.globalEffects.sabbieMobiliActivator = null;
            gameState.history.push(`‚ùå Sabbie Mobili rimosse`);
            database.ref('games/' + gameState.gameCode).update({ globalEffects: gameState.globalEffects, history: gameState.history });
        }

        function toggleCantoCigno() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('canto-cigno-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.cantoDelCigno = !player.cantoDelCigno;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].cantoDelCigno ? 'attivato' : 'disattivato';
            gameState.history.push(`ü¶¢ Canto del Cigno ${status} per: ${playerNames}`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

        function togglePattoDiavolo() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('patto-diavolo-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.pattoDiavolo = !player.pattoDiavolo;
                player.pattoDiavoloUsed = false;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].pattoDiavolo ? 'attivato' : 'disattivato';
            gameState.history.push(`üòà Patto con il Diavolo ${status} per: ${playerNames}`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

        function toggleTombaTutankhamon() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('tomba-tutankhamon-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.tombaTutankhamon = !player.tombaTutankhamon;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].tombaTutankhamon ? 'attivata' : 'disattivata';
            gameState.history.push(`üè∫ Tomba di Tutankhamon ${status} per: ${playerNames}`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

        function toggleReincarnazione() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('reincarnazione-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.reincarnazione = !player.reincarnazione;
                player.reincarnazioneUsed = false;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].reincarnazione ? 'attivata' : 'disattivata';
            gameState.history.push(`‚ôªÔ∏è Reincarnazione ${status} per: ${playerNames}`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

        function toggleBoiaEsecutore() {
            if (!gameState.isMaster) return;
            const select = document.getElementById('boia-esecutore-players');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            if (selectedIndices.length === 0) { alert('Seleziona almeno un giocatore!'); return; }
            selectedIndices.forEach(index => {
                const player = gameState.players[index];
                player.boiaEsecutore = !player.boiaEsecutore;
                player.boiaEsecutoreTurns = player.boiaEsecutore ? 2 : 0;
            });
            const playerNames = selectedIndices.map(i => gameState.players[i].name).join(', ');
            const status = gameState.players[selectedIndices[0]].boiaEsecutore ? 'attivato' : 'disattivato';
            gameState.history.push(`ü™ì Boia Esecutore ${status} per: ${playerNames} (dura 2 turni)`);
            database.ref('games/' + gameState.gameCode).update({ players: gameState.players, history: gameState.history });
        }

    </script>
</body>
</html>
